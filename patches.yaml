---
perl-Alien-SDL:
  '1.446':
  - content: |
      https://github.com/PerlGameDev/Alien-SDL/pull/6
      https://rt.cpan.org/Public/Bug/Display.html?id=119888


      From 573a2c6971d78a751238a1b408d588769e6710d6 Mon Sep 17 00:00:00 2001
      From: "Bernhard M. Wiedemann" <bwiedemann@suse.de>
      Date: Mon, 18 Sep 2017 10:36:16 +0200
      Subject: [PATCH 1/2] Sort hash keys

      When building packages (e.g. for openSUSE Linux) in disposable VMs
      every build gave a different result.
      This patch fixes this by sorting hash keys

      See https://reproducible-builds.org/ for why this matters.

      was also filed at
      https://rt.cpan.org/Public/Bug/Display.html?id=119888
      ---
       inc/My/Builder/Unix.pm | 4 ++--
       1 file changed, 2 insertions(+), 2 deletions(-)

      diff --git a/inc/My/Builder/Unix.pm b/inc/My/Builder/Unix.pm
      index 15291d5..ad3e600 100644
      --- a/inc/My/Builder/Unix.pm
      +++ b/inc/My/Builder/Unix.pm
      @@ -18,7 +18,7 @@ sub get_additional_cflags {
         my $self = shift;
         my @list = ();
         ### any platform specific -L/path/to/libs shoud go here
      -  for (keys %$inc_lib_candidates) {
      +  for (sort keys %$inc_lib_candidates) {
           push @list, "-I$_" if (-d $_);
         }
         return join(' ', @list);
      @@ -36,7 +36,7 @@ sub get_additional_libs {
             $rv{"-Wl,-rpath,$ld"} = 1 if $^O =~ /^linux|dragonfly|.+bsd$/;
           }
         }
      -  push @list, (keys %rv);
      +  push @list, sort (keys %rv);
         if ($^O eq 'openbsd') {
           my $osver = `uname -r 2>/dev/null`;
           if ($self->notes('perl_libs')->{pthread} || ($osver && $osver < 5.0)) {

      From 088244849360b485c56268d2e497563d52868fb0 Mon Sep 17 00:00:00 2001
      From: "Bernhard M. Wiedemann" <bwiedemann@suse.de>
      Date: Wed, 19 Jun 2019 14:39:41 +0200
      Subject: [PATCH 2/2] Sort find_file file list

      so that ConfigData.pm ld_shared_libs builds in a reproducible way
      in spite of indeterministic filesystem readdir order.

      See https://reproducible-builds.org/ for why this is good.
      ---
       inc/My/Utility.pm | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/inc/My/Utility.pm b/inc/My/Utility.pm
      index 6d10d6d..328567f 100644
      --- a/inc/My/Utility.pm
      +++ b/inc/My/Utility.pm
      @@ -477,7 +477,7 @@ sub find_file {
           no warnings;
           find({ wanted => sub { push @files, rel2abs($_) if /$re/ }, follow => 1, no_chdir => 1 , follow_skip => 2}, $dir);
         };
      -  return @files;
      +  return @files = sort @files; # enforce list context, see `perldoc -f sort`
       }
       
       sub find_SDL_dir {
    name: reproducible.patch
    opt: -p1
perl-Alien-wxWidgets:
  '0.69':
  - content: |
      --- Build.PL.orig	2010-12-27 01:18:00.000000000 +0100
      +++ Build.PL	2010-12-27 01:18:20.000000000 +0100
      @@ -123,7 +123,7 @@
       # if anything went wrong in the autodetection, revert to the correct
       # default
       if( !$ok ) {
      -    $build_wx_dflt = 'yes';
      +    die "not ok";
       }
       
       # detect wxWidgets using WXDIR/WXWIN environment variables on Win32
    name: perl-Alien-wxWidgets-do_not_build_wxgtk.patch
    opt: null
  - content: |
      --- lib/Alien/wxWidgets.pm.orig	2016-11-23 16:54:35.940061462 +0100
      +++ lib/Alien/wxWidgets.pm	2016-11-23 16:55:14.383929523 +0100
      @@ -132,6 +132,8 @@
           my @configs = $class->get_configurations( @_ );
       
           require Data::Dumper;
      +    # sort output, to have same output as from My::Build::Base
      +    $Data::Dumper::Sortkeys = 1;
           print Data::Dumper->Dump( \@configs );
       }
       
      --- inc/My/Build/Base.pm.orig	2016-11-24 14:43:52.306654279 +0100
      +++ inc/My/Build/Base.pm	2016-11-24 14:44:09.806598987 +0100
      @@ -218,6 +218,8 @@
           my %config = $self->_init_config;
           my $base = $self->awx_key;
       
      +    # sort output for reproducible builds
      +    $Data::Dumper::Sortkeys = 1;
           my $body = Data::Dumper->Dump( [ \%config ] );
           $body =~ s/rEpLaCe/$base/g;
       
    name: perl-Alien-wxWidgets-dump_sorted_config.patch
    opt: null
  - content: |
      --- Build.PL.orig	2019-08-21 13:20:23.591141429 +0200
      +++ Build.PL	2019-08-21 13:20:25.603152873 +0200
      @@ -54,7 +54,7 @@
                                'Module::Pluggable'              => '2.6',
                               },
           build_requires  => { 'Module::Build'                  => '0.28',
      -                         'ExtUtils::CBuilder'             => '0.24',
      +                         'ExtUtils::CBuilder'             => 0,
                                'File::Spec'                     => '1.50',
                                'LWP::Protocol::https'           => '0',
                                },
    name: perl-Alien-wxWidgets-ignore_cbuilder_version.patch
    opt: null
perl-Apache-DBI:
  '1.12':
  - content: |
      --- eg/startup.pl.orig	2011-10-20 14:02:32.000000000 -0400
      +++ eg/startup.pl	2011-10-20 14:02:40.000000000 -0400
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl -w
      +#!/usr/bin/perl -w
       
       # to load this file when the server starts, add this to httpd.conf:
       # PerlRequire /path/to/startup.pl
    name: Apache-DBI-1.11-path.patch
    opt: null
perl-Apache-Test:
  '1.43':
  - content: |
      Index: Apache-Test-1.36/lib/Apache/Test5005compat.pm
      ===================================================================
      --- Apache-Test-1.36.orig/lib/Apache/Test5005compat.pm	2011-02-01 08:51:44.000000000 +0100
      +++ Apache-Test-1.36/lib/Apache/Test5005compat.pm	2011-04-14 11:51:40.672730852 +0200
      @@ -72,7 +72,8 @@ sub warnings_pm {
           my $fh = open_file(shift);
       
           print $fh <<'EOF';
      -package warnings;
      +package 
      +   warnings;
       
       sub import {}
       
      Index: Apache-Test-1.36/lib/Apache/TestRequest.pm
      ===================================================================
      --- Apache-Test-1.36.orig/lib/Apache/TestRequest.pm	2011-02-01 08:51:44.000000000 +0100
      +++ Apache-Test-1.36/lib/Apache/TestRequest.pm	2011-04-14 11:47:55.317641991 +0200
      @@ -43,7 +43,8 @@ unless ($ENV{APACHE_TEST_PRETEND_NO_LWP}
               require HTTP::Request::Common;
       
               unless (defined &HTTP::Request::Common::OPTIONS) {
      -            package HTTP::Request::Common;
      +            package
      +               HTTP::Request::Common;
                   no strict 'vars';
                   *OPTIONS = sub { _simple_req(OPTIONS => @_) };
                   push @EXPORT, 'OPTIONS';
    name: fix-provides.diff
    opt: -p1
perl-Audio-Mixer:
  '0.7':
  - content: |
      Description: fix FTBFS with clang instead of gcc
      Bug-Debian: http://bugs.debian.org/742537
      Author: Nicolas SÃ©velin-Radiguet <nicosr@free.fr>
      Reviewed-by: gregor herrmann <gregoa@debian.org>
      Last-Update: 2014-03-24

      --- a/Mix.c
      +++ b/Mix.c
      @@ -78,7 +78,7 @@
       #ifdef DEBUG
         fprintf(stderr, "close_mixer()\n");
       #endif
      -  if (mixer_fd < 0) return;
      +  if (mixer_fd < 0) return(0);
         close(mixer_fd);
         init_flag = 0;
         mixer_fd = -1;
    name: clang_FTBFS_Wreturn-type.patch
    opt: null
perl-Authen-PAM:
  '0.16':
  - content: |
      diff -up Authen-PAM-0.16/Makefile.PL.orig Authen-PAM-0.16/Makefile.PL
      --- Authen-PAM-0.16/Makefile.PL.orig	2017-05-15 16:02:18.933440522 +0200
      +++ Authen-PAM-0.16/Makefile.PL	2017-05-15 16:17:41.513263075 +0200
      @@ -10,7 +10,7 @@ sub configure {
       
           # returns a reference to anonymous hash which is then interpreted as
           # additional options to the WriteMakeFile
      -    $options = require "pam.cfg";
      +    $options = require "./pam.cfg";
       
           if ( $Config{'osname'} eq 'solaris' && $Config{'osvers'} eq '2.6') {
             print "Adding a workaround for a bug in the Solaris 2.6 pam library\n";
    name: Authen-PAM-0.16-Fix-building-on-Perl-without-dot-in-INC.patch
    opt: -p1 PATCH-FIX-UPSTREAM load config with full path
perl-B-Lint:
  '1.20':
  - content: |
      diff -urN '--exclude=CVS' '--exclude=.cvsignore' '--exclude=.svn' '--exclude=.svnignore' old/B-Lint-1.20/Changes new/B-Lint-1.22/Changes
      --- old/B-Lint-1.20/Changes	2014-10-26 21:00:05.000000000 +0100
      +++ new/B-Lint-1.22/Changes	2017-11-13 17:36:52.000000000 +0100
      @@ -1,5 +1,11 @@
       Revision history for B-Lint
       
      +1.22    2017-11-13 rurban
      +      - fix wrong return @array scalar context warning (Closes RT#97873)
      +
      +1.21    2017-11-13 rurban
      +      - skip $hash{bare} as BARE word test since 5.22 (Closes RT#101115)
      +
       1.20    2014-10-26
             - install to archlib, as was done in 1.17 and previous, to avoid being
               skipped over because of and older install appearing first in @INC
      diff -urN '--exclude=CVS' '--exclude=.cvsignore' '--exclude=.svn' '--exclude=.svnignore' old/B-Lint-1.20/lib/B/Lint.pm new/B-Lint-1.22/lib/B/Lint.pm
      --- old/B-Lint-1.20/lib/B/Lint.pm	2014-10-26 21:00:14.000000000 +0100
      +++ new/B-Lint-1.22/lib/B/Lint.pm	2017-11-13 17:35:48.000000000 +0100
      @@ -1,7 +1,7 @@
       package B::Lint;
       use if $] > 5.017, 'deprecate';
       
      -our $VERSION = '1.20';    ## no critic
      +our $VERSION = '1.22';    ## no critic
       
       =head1 NAME
       
      @@ -85,6 +85,10 @@
       
       Neither of these will do what a naive user would expect.
       
      +Notice: Perl 5.22.0 does not report C<foo> in C<$b{foo}> as BARE token
      +anymore. Therefore L<B::Lint> test is not reliable here. See
      +L<CPAN RT#101115|https://rt.cpan.org/Public/Bug/Display.html?id=101115>.
      +
       =item B<dollar-underscore>
       
       This option warns whenever C<$_> is used either explicitly anywhere or
      @@ -411,14 +415,16 @@
       
               next if $implies_ok_context{$pname};
       
      -        # Three special cases to deal with: "foreach (@foo)", "delete
      +        # Four special cases to deal with: "foreach (@foo)", "delete
               # $a{$b}", and "exists $a{$b}" null out the parent so we have to
               # check for a parent of pp_null and a grandparent of
      -        # pp_enteriter, pp_delete, pp_exists
      +        # pp_enteriter, pp_delete, pp_exists.
      +        # return @array is also wrong, return has always list context.
       
               next
                   if $pname eq "null"
                   and $gparent->name =~ m/\A(?:delete|enteriter|exists)\z/xms;
      +        next if $pname eq "return";
       
               # our( @bar ); would also trigger this error so I exclude
               # that.
      diff -urN '--exclude=CVS' '--exclude=.cvsignore' '--exclude=.svn' '--exclude=.svnignore' old/B-Lint-1.20/META.json new/B-Lint-1.22/META.json
      --- old/B-Lint-1.20/META.json	2014-10-26 21:03:30.000000000 +0100
      +++ new/B-Lint-1.22/META.json	2017-11-13 17:42:02.000000000 +0100
      @@ -4,7 +4,7 @@
             "Joshua ben Jore <jjore@cpan.org>"
          ],
          "dynamic_config" : 1,
      -   "generated_by" : "ExtUtils::MakeMaker version 6.98, CPAN::Meta::Converter version 2.142690",
      +   "generated_by" : "ExtUtils::MakeMaker version 7.3, CPAN::Meta::Converter version 2.150010",
          "license" : [
             "perl_5"
          ],
      @@ -38,5 +38,6 @@
             }
          },
          "release_status" : "stable",
      -   "version" : "1.20"
      +   "version" : "1.22",
      +   "x_serialization_backend" : "JSON::PP version 2.27400_02"
       }
      diff -urN '--exclude=CVS' '--exclude=.cvsignore' '--exclude=.svn' '--exclude=.svnignore' old/B-Lint-1.20/META.yml new/B-Lint-1.22/META.yml
      --- old/B-Lint-1.20/META.yml	2014-10-26 21:03:30.000000000 +0100
      +++ new/B-Lint-1.22/META.yml	2017-11-13 17:42:02.000000000 +0100
      @@ -7,7 +7,7 @@
       configure_requires:
         ExtUtils::MakeMaker: '0'
       dynamic_config: 1
      -generated_by: 'ExtUtils::MakeMaker version 6.98, CPAN::Meta::Converter version 2.142690'
      +generated_by: 'ExtUtils::MakeMaker version 7.3, CPAN::Meta::Converter version 2.150010'
       license: perl
       meta-spec:
         url: http://module-build.sourceforge.net/META-spec-v1.4.html
      @@ -20,4 +20,5 @@
       requires:
         Module::Pluggable: '0'
         if: '0'
      -version: '1.20'
      +version: '1.22'
      +x_serialization_backend: 'CPAN::Meta::YAML version 0.018'
      diff -urN '--exclude=CVS' '--exclude=.cvsignore' '--exclude=.svn' '--exclude=.svnignore' old/B-Lint-1.20/t/lint.t new/B-Lint-1.22/t/lint.t
      --- old/B-Lint-1.20/t/lint.t	2013-01-24 02:29:37.000000000 +0100
      +++ new/B-Lint-1.22/t/lint.t	2017-11-13 17:40:46.000000000 +0100
      @@ -14,7 +14,7 @@
       use strict;
       use warnings;
       
      -plan tests => 29;
      +plan tests => 31;
       
       # Runs a separate perl interpreter with the appropriate lint options
       # turned on
      @@ -53,6 +53,8 @@
       
       runlint 'context', 'exists $BAR{BAZ}', '';
       
      +runlint 'context', 'sub foo{return @_}', ''; # return CPAN RT#97873
      +
       runlint 'implicit-read', '/foo/', <<'RESULT';
       Implicit match on $_ at -e line 1
       RESULT
      @@ -116,13 +118,19 @@
       
       runlint 'bare-subs', 'sub bare(){1};$x=bare', '';
       
      -runlint 'bare-subs', 'sub bare(){1}; $x=[bare=>0]; $x=$y{bare}', <<'RESULT';
      +runlint 'bare-subs', 'sub bare(){1}; $x=[bare=>0]', <<'RESULT';
       Bare sub name 'bare' interpreted as string at -e line 1
      +RESULT
      +
      +SKIP: {
      +    skip 'Perl 5.22 stopped marking $hash{bare} as BARE word, CPAN RT#101115',
      +        1, if $] >= 5.022;
      +    runlint 'bare-subs', 'sub bare(){1}; $x=$y{bare}', <<'RESULT';
       Bare sub name 'bare' interpreted as string at -e line 1
       RESULT
      +}
       
       {
      -
           # Check for backwards-compatible plugin support. This was where
           # preloaded mdoules would register themselves with B::Lint.
           my $res = runperl(
      @@ -135,7 +143,6 @@
       }
       
       {
      -
           # Check for Module::Plugin support
           my $res = runperl(
               switches => [ '-It/pluglib', '-MO=Lint,none' ],
    name: fix-bare.diff
    opt: -p2
perl-B-Utils:
  '0.27':
  - content: |
      Index: B-Utils-0.21/lib/B/Utils.pm
      ===================================================================
      --- B-Utils-0.21.orig/lib/B/Utils.pm
      +++ B-Utils-0.21/lib/B/Utils.pm
      @@ -210,7 +210,7 @@ sub B::OP::_parent_impl {
           return (
               $op->sibling->_parent_impl( $target, "$cx$$op S " )
                   || (
      -              $cx =~ /^(?:\d+ S )*(?:\d+ N )*$/
      +              $cx =~ /^(?:-?\d+ S )*(?:-?\d+ N )*$/
                   ? $op->next->_parent_impl( $target, "$cx$$op N " )
                   : ()
                   )
    name: parent-impl.patch
    opt: -p1
perl-Bit-Vector:
  '7.4':
  - content: |
      --- examples/SetObject.pl
      +++ examples/SetObject.pl
      @@ -1,4 +1,4 @@
      -#!perl
      +#!/usr/bin/perl
       
       ###############################################################################
       ##                                                                           ##
      --- examples/benchmk1.pl
      +++ examples/benchmk1.pl
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       
       use Benchmark;
       
      --- examples/benchmk2.pl
      +++ examples/benchmk2.pl
      @@ -1,4 +1,4 @@
      -#!perl
      +#!/usr/bin/perl
       
       use Benchmark;
       use Bit::Vector::String;
      --- examples/benchmk3.pl
      +++ examples/benchmk3.pl
      @@ -1,4 +1,4 @@
      -#!perl -w
      +#!/usr/bin/perl -w
       
       package Bit::Vector;
       
      --- examples/primes.pl
      +++ examples/primes.pl
      @@ -1,4 +1,4 @@
      -#!perl -w
      +#!/usr/bin/perl -w
       
       ###############################################################################
       ##                                                                           ##
    name: Bit-Vector-7.1.diff
    opt: null
perl-CDDB_get:
  '2.28':
  - content: |
      Index: CDDB_get-2.27/cddb.pl
      ===================================================================
      --- CDDB_get-2.27.orig/cddb.pl
      +++ CDDB_get-2.27/cddb.pl
      @@ -23,6 +23,7 @@
       
       use Data::Dumper;
       use Getopt::Std;
      +use File::Temp qw/ tempfile tempdir /;
       
       use strict;
       
      @@ -58,8 +59,8 @@ my %config;
       my $diskid;
       my $total;
       my $toc;
      -my $savedir="/tmp/cddb";
      -my $xmcddir="/tmp/xmcd";
      +my $savedir = tempdir( CLEANUP => 1 );
      +my $xmcddir = tempdir( CLEANUP => 1 )."xmcd";
       
       if($option{C}) {
         # use CDDB_cache qw( get_cddb get_discids );
    name: perl-CDDB_get-2.23-tmpfile.diff
    opt: null
perl-Cache-LRU:
  '0.04':
  - content: |
      Index: Cache-LRU-0.04/Makefile.PL
      ===================================================================
      --- Cache-LRU-0.04.orig/Makefile.PL
      +++ Cache-LRU-0.04/Makefile.PL
      @@ -1,3 +1,4 @@
      +use lib '.';
       use inc::Module::Install;
       
       all_from 'lib/Cache/LRU.pm';
    name: perl526.patch
    opt: -p1
perl-Class-Tangram:
  '1.57':
  - content: |+
      From 32789b1aa513671205f1fc51c56d25f8614330f5 Mon Sep 17 00:00:00 2001
      From: Slaven Rezic <slaven@rezic.de>
      Date: Sun, 4 Mar 2018 20:57:32 +0100
      Subject: [PATCH] fix for "Can't used defined ..." errors (RT #108841)

      ---
       lib/Class/Tangram/Generator.pm | 4 ++--
       1 file changed, 2 insertions(+), 2 deletions(-)

      diff --git a/lib/Class/Tangram/Generator.pm b/lib/Class/Tangram/Generator.pm
      index b624dab..a1225c9 100644
      --- a/lib/Class/Tangram/Generator.pm
      +++ b/lib/Class/Tangram/Generator.pm
      @@ -147,8 +147,8 @@ sub load_class {
       		     .join (" ", map {
       			 (defined &{ $class."::$_" } ? "&" : "")
       			.(defined ${ $class."::$_" } ? "\$" : "")
      -			.(defined @{ $class."::$_" } ? "\@" : "")
      -			.(defined %{ $class."::$_" } ? "\%" : "")
      +			.(        @{ $class."::$_" } ? "\@" : "")
      +			.(        %{ $class."::$_" } ? "\%" : "")
       			    ."$_"
       			} keys %{ $class."::" }));
       	        (DEBUG) && debug_out
      -- 
      2.1.4

    name: Class-Tangram-1.57-RT108841.patch
    opt: -p1
perl-Command-Runner:
  '0.200':
  - content: |
      diff -ur Command-Runner-0.103/lib/Command/Runner/Quote.pm Command-Runner-0.103_fix/lib/Command/Runner/Quote.pm
      --- Command-Runner-0.103/lib/Command/Runner/Quote.pm	2020-07-24 12:51:54.000000000 +0200
      +++ Command-Runner-0.103_fix/lib/Command/Runner/Quote.pm	2020-10-18 12:43:17.439743163 +0200
      @@ -2,15 +2,16 @@
       use strict;
       use warnings;
       
      -use Win32::ShellQuote ();
      +#use Win32::ShellQuote ();
       use String::ShellQuote ();
       
       use Exporter 'import';
       our @EXPORT_OK = qw(quote quote_win32 quote_unix);
       
       sub quote_win32 {
      -    my $str = shift;
      -    Win32::ShellQuote::quote_literal($str, 1);
      +#    my $str = shift;
      +#    Win32::ShellQuote::quote_literal($str, 1);
      +   die "Win32::ShellQUote not available";
       }
       
       sub quote_unix {
    name: nowin32.diff
    opt: -p1
perl-Convert-ASN1:
  0.340.0:
  - content: |
      Index: t/00prim.t
      ===================================================================
      --- t/00prim.t.orig
      +++ t/00prim.t
      @@ -178,9 +178,10 @@ my %BSTR = (
           [pack("B*",'011011111101110111'), 7, pack("B*", '01101110')]
       );
       
      -while(($result,$val) = each %BSTR) {
      -    print "# BIT STRING ", unpack("B*", ref($val) ? $val->[0] : $val),
      -	" ",(ref($val) ? $val->[1] : $val),"\n";
      +foreach $result (sort(keys %BSTR)) {
      +  $val = $BSTR{$result};
      +  print "# BIT STRING ", unpack("B*", ref($val) ? $val->[0] : $val),
      +      " ",(ref($val) ? $val->[1] : $val),"\n";
       
         btest $test++, $asn->prepare('bit BIT STRING') or warn $asn->error;
         stest $test++, $result, $asn->encode( bit => $val) or warn $asn->error;
    name: perl-Convert-ASN1-0.31-test.patch
    opt: -p0
perl-Convert-Bencode_XS:
  '0.06':
  - content: |
      --- t/001_tests.t.orig	Sat Nov 15 14:41:13 2014
      +++ t/001_tests.t	Sat Nov 15 14:41:27 2014
      @@ -109,6 +109,7 @@ SKIP: {
           #we use Storable so we do not rely on bencode
           eval q{use Storable qw(freeze)}; 
           skip "Storable not available", 12 if $@;
      +    local $Storable::canonical = 1;
           local $Convert::Bencode_XS::COERCE = 0;
           is( freeze(bdecode('le')), freeze([]) );
           is( freeze(bdecode('l0:0:0:e')), freeze(['', '', '']) );
    name: storable-canonical.patch
    opt: null
perl-Crypt-HSXKPasswd:
  '3.6':
  - content: |
      --- Crypt-HSXKPasswd-v3.6.orig/lib/Crypt/HSXKPasswd/Dictionary/Basic.pm	2015-08-11 22:37:07.000000000 +0200
      +++ Crypt-HSXKPasswd-v3.6/lib/Crypt/HSXKPasswd/Dictionary/Basic.pm	2023-01-02 22:30:34.161808640 +0100
      @@ -216,7 +216,7 @@
           # validate args
           state $args_check = multisig(
               [NonEmptyString, Optional[Maybe[NonEmptyString]]],
      -        [ArrayRef[Str]], Optional[Item],
      +        [ArrayRef[Str], Optional[Item]],
           );
           my ($dict_source, $encoding) = $args_check->(@args);
           
      @@ -272,4 +272,4 @@
           return $self;
       }
       
      -1; # because Perl is just a little bit odd :)
      \ No newline at end of file
      +1; # because Perl is just a little bit odd :)
    name: multisig.patch
    opt: -p1 PATCH-FIX-https://rt.cpan.org/Ticket/Display.html?id=144672
perl-Crypt-OpenSSL-RSA:
  '0.33':
  - content: |
      Index: Crypt-OpenSSL-RSA-0.32/RSA.xs
      ===================================================================
      --- Crypt-OpenSSL-RSA-0.32.orig/RSA.xs
      +++ Crypt-OpenSSL-RSA-0.32/RSA.xs
      @@ -40,7 +40,7 @@ void croakSsl(char* p_file, int p_line)
       
       #define CHECK_OPEN_SSL(p_result) if (!(p_result)) croakSsl(__FILE__, __LINE__);
       
      -#define PACKAGE_CROAK(p_message) croak("%s", (p_message))
      +#define PACKAGE_CROAK(p_message) croak("%s:%d: %s", __FILE__, __LINE__, (p_message))
       #define CHECK_NEW(p_var, p_size, p_type) \
         if (New(0, p_var, p_size, p_type) == NULL) \
           { PACKAGE_CROAK("unable to alloc buffer"); }
    name: Crypt-OpenSSL-RSA.patch
    opt: -p1
perl-Crypt-Primes:
  '0.50':
  - content: |+
      --- t/genprime_elgamal.t
      +++ t/genprime_elgamal.t
      @@ -10,8 +10,8 @@
       
       use lib '../lib';
       use lib 'lib';
      +use Math::PariInit qw( floor stack=16000000 );
       use Crypt::Primes; 
      -use Math::Pari qw(floor);
       
       print "1..10\n";
       
      --- t/genprime.t
      +++ t/genprime.t
      @@ -10,8 +10,8 @@
       
       use lib '../lib';
       use lib 'lib';
      +use Math::PariInit qw( floor stack=16000000 );
       use Crypt::Primes qw(maurer); 
      -use Math::Pari qw(floor);
       
       print "1..10\n";

    name: math-pariinit.patch
    opt: -p0
perl-Crypt-SSLeay:
  '0.72':
  - content: |
      Index: Crypt-SSLeay-0.72/Makefile.PL
      ===================================================================
      --- Crypt-SSLeay-0.72.orig/Makefile.PL
      +++ Crypt-SSLeay-0.72/Makefile.PL
      @@ -8,7 +8,8 @@ use Getopt::Long qw( GetOptionsFromArray
       use Path::Class;
       use Try::Tiny;
       
      -use inc::IO::Interactive::Tiny;
      +use lib 'inc';
      +use IO::Interactive::Tiny;
       
       caller
           or run(\@ARGV, [qw{ssl crypto ssl32 ssleay32 eay32 libeay32 z}]);
    name: no-dot-inc.patch
    opt: -p1
perl-DBD-MariaDB:
  1.230.0:
  - content: |
      diff --git a/t/40server_prepare.t b/t/40server_prepare.t
      index 6eb2cf1..4938ad9 100644
      --- a/t/40server_prepare.t
      +++ b/t/40server_prepare.t
      @@ -14,7 +14,7 @@ $test_dsn.= ";mariadb_server_prepare=1;mariadb_server_prepare_disable_fallback=1
       my $dbh = DbiTestConnect($test_dsn, $test_user, $test_password,
                             { RaiseError => 1, PrintError => 0, AutoCommit => 0 });
       
      -plan tests => 29;
      +plan tests => 28;
       
       ok(defined $dbh, "connecting");
       
      @@ -77,7 +77,8 @@ my $error_handler_called = 0;
       $dbh->{HandleError} = sub { $error_handler_called = 1; die $_[0]; };
       eval { $dbh->prepare($non_preparable_statement); };
       $dbh->{HandleError} = undef;
      -ok($error_handler_called, "Non-preparable statement '$non_preparable_statement' is not supported with mariadb_server_prepare_disable_fallback=1");
      +
      +# ok($error_handler_called, "Non-preparable statement '$non_preparable_statement' is not supported with mariadb_server_prepare_disable_fallback=1");
       
       $dbh->{mariadb_server_prepare_disable_fallback} = 0;
       my $sth4;
    name: perl-DBD-MariaDB-fix_c_32x_test.patch
    opt: -p1
perl-DBD-ODBC:
  '1.61':
  - content: |
      Index: Makefile.PL
      ===================================================================
      --- Makefile.PL.orig
      +++ Makefile.PL
      @@ -213,6 +213,7 @@ EOT
       }
       print "Overriding ODBC Directory with command line option: $opt_o\n"
           if $opt_o ;
      +my $lib=$ENV{LIB};
       if ($opt_g) {
          print "Setting debug options!\n";
          if ($OSNAME eq 'MSWin32') {
      @@ -355,7 +356,7 @@ EOT
                   #$tmp_odbchome =~ s/\\/\//g;
                   #$odbchome = $tmp_odbchome if (-e "$tmp_odbchome/odbc.ini")
                   chomp($odbchome = `cygpath \$WINDIR`);
      -        } elsif (-f '/opt/sapdb/interfaces/odbc/lib/libsqlod.a') {
      +        } elsif (-f '/opt/sapdb/interfaces/odbc/lib/libsqlod.a' || -f '/opt/sapdb/interfaces/odbc/lib/lib64/libsqlod.a') {
                   $odbchome = '/opt/sapdb/interfaces/odbc/';
               }
           }
      @@ -453,7 +454,7 @@ EOT
           $opts{INC}  .= " -I/usr/include/w32api" if $OSNAME eq 'cygwin';
       
           # TO_DO all this needs to move until later
      -#    my $lib_d1 = "$odbchome/lib";
      +#    my $lib_d1 = "$odbchome/$lib";
       #    my $lib_d2 = "$odbchome/dlls";
       #    my $libs   = "odbc";
       #    $opts{LIBS} = " -L$lib_d1 -R$lib_d1 -L$lib_d2 -R$lib_d2 -l$libs";
      @@ -496,32 +497,32 @@ EOT
                                -e "$odbchome/odbc32.dll"));
       
           $myodbc = 'empress'
      -        if !$myodbc && glob "$odbchome/lib/libempodbc.*";
      +        if !$myodbc && glob "$odbchome/$lib/libempodbc.*";
       
           $myodbc = 'intersolve'
               if !$myodbc && -f "$odbchome/include/qeodbc.h";
       
           $myodbc = 'sapdb'
      -        if !$myodbc && -f "$odbchome/lib/libsqlod.$arext";
      +        if !$myodbc && -f "$odbchome/$lib/libsqlod.$arext";
       
           $myodbc = 'adabas'
               if (!$myodbc &&
                       $ENV{DBROOT} &&
                           ($odbchome eq $ENV{DBROOT}) &&
      -                        -f "$odbchome/lib/odbclib.$arext");
      +                        -f "$odbchome/$lib/odbclib.$arext");
       
           $myodbc = 'udbc'
      -        if !$myodbc && -f "$odbchome/lib/libudbc.$arext";
      +        if !$myodbc && -f "$odbchome/$lib/libudbc.$arext";
       
           $myodbc = 'solid'
      -        if !$myodbc && -f "$odbchome/lib/libsolcli.$dlext";
      +        if !$myodbc && -f "$odbchome/$lib/libsolcli.$dlext";
       
           # JL 2002-12-16: This test is accurate on Unix (Solaris 7) with IBM
           # Informix ClientSDK 2.80.UC1, which includes IBM Informix CLI
           # v3.81.000, an ODBC 3.x driver.
       	# NB: The correct value for $ODBCHOME is $INFORMIXDIR.
           $myodbc = 'informix'
      -        if !$myodbc && -f "$odbchome/lib/cli/libifcli.$dlext";
      +        if !$myodbc && -f "$odbchome/$lib/cli/libifcli.$dlext";
       
           if (!$myodbc) {
       	local($LIST_SEPARATOR) = ", ";
      @@ -549,7 +550,7 @@ EOT
       
           if ($myodbc eq 'Microsoft ODBC') {
               print "\nBuilding for Microsoft under Cygwin\n";
      -        $opts{LIBS} = "-L/usr/lib/w32api -lodbc32";
      +	$opts{LIBS} = "-L/usr/$lib/w32api -lodbc32";
               print {$sqlhfh} "#include <windows.h>\n";
               print {$sqlhfh} "#include <sql.h>\n";
               print {$sqlhfh} "#include <sqltypes.h>\n";
      @@ -588,7 +589,7 @@ EOT
                       $opts{LIBS} = q{};
                       $opts{dynamic_lib} = { OTHERLDFLAGS => "$ilibpath" };
                   }
      -            warn "Warning: LD_LIBRARY_PATH doesn't include $odbchome/lib\n"
      +	    warn "Warning: LD_LIBRARY_PATH doesn't include $odbchome/$lib\n"
                       if (!defined($ENV{LD_LIBRARY_PATH})) ||
                           ($ENV{LD_LIBRARY_PATH} =~ /\Q$odbclibdir/);
               }
      @@ -729,7 +730,11 @@ EOT
       	print {$sqlhfh} qq{#define DBD_ODBC_NO_DATASOURCES\n};
       
       	$opts{INC} .= " -I$odbchome/incl";
      -	$opts{LDFROM} = "\$(OBJECT) $odbchome/lib/libsqlod.a";
      +        if (-f "$odbchome/$lib/libsqlod.a" ) {
      +          $opts{LDFROM} = "\$(OBJECT) $odbchome/$lib/libsqlod.a";
      +        } else {
      +          $opts{LDFROM} = "\$(OBJECT) $odbchome/$lib/lib64/libsqlod.a";
      +        }
           }
           elsif ($myodbc eq 'adabas') {
       	print {$sqlhfh} "#define FAR \n#define EXPORT \n#define CALLBACK \n";
      @@ -788,7 +793,7 @@ if ($OSNAME eq 'darwin') {
           # SQLGetPrivateProfileString is in libiodbcinst.a
           my $osver = `uname -r`;
           if ($osver && ($osver =~ /^8/)) {
      -        $opts{LIBS} .= ' -L/usr/lib -liodbcinst';
      +        $opts{LIBS} .= ' -L/usr/$lib -liodbcinst';
           }
       }
       
    name: perl-DBD-ODBC-1.29-Makefile.diff
    opt: -p0
perl-DBD-SQLite:
  1.740.0:
  - content: |
      Index: DBD-SQLite-1.70/Makefile.PL
      ===================================================================
      --- DBD-SQLite-1.70.orig/Makefile.PL
      +++ DBD-SQLite-1.70/Makefile.PL
      @@ -129,7 +129,7 @@ SCOPE: {
       # a system sqlite is also sophisticated enough to have a patching system
       # that can change the if ( 0 ) to if ( 1 )
       my ($sqlite_local, $sqlite_base, $sqlite_lib, $sqlite_inc);
      -if ( 0 ) {
      +if ( 1 ) {
       	require File::Spec;
       	if ( $sqlite_base = (grep(/SQLITE_LOCATION=.*/, @ARGV))[0] ) {
       		$sqlite_base =~ /=(.*)/;
    name: perl-DBD-SQLite-use-external-sqlite3.patch
    opt: -p1 PATCH-FIX-OPENSUSE use system sqlite
perl-DBD-mysql:
  '4.050':
  - content: |
      From 93bc876808af048091bf76d6908a9748d0476ab9 Mon Sep 17 00:00:00 2001
      From: Eric Herman <eric@freesa.org>
      Date: Thu, 10 Jan 2019 10:22:38 +0100
      Subject: [PATCH] Fix "assignment from incompatible pointer type"
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      I encountered this warning from gcc 7.3.0 building on Ubuntu:

      dbdimp.c: In function âmysql_st_prepareâ:
      dbdimp.c:3207:24: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]
                 bind->is_null=      (_Bool*) &(fbind->is_null);

      The "MYSQL_BIND" field "is_null" is of type "my_bool", not "_Bool".

      The type "my_bool" is (usually) type-defined to be of a "char" type.

      Regardless, the "imp_sth_phb_t" field "is_null" is of type "char".

      This commit removes the cast, which means that if we later discover
      that "my_bool" is defined to be of a type incompatible with the
      "imp_sth_phb_t" field "is_null", it will break at compile-time.
      ---
       dbdimp.c | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/dbdimp.c b/dbdimp.c
      index b0399d94..e7e6c007 100644
      --- a/dbdimp.c
      +++ b/dbdimp.c
      @@ -3204,7 +3204,7 @@ dbd_st_prepare(
                 bind->buffer_type=  MYSQL_TYPE_STRING;
                 bind->buffer=       NULL;
                 bind->length=       &(fbind->length);
      -          bind->is_null=      (_Bool*) &(fbind->is_null);
      +          bind->is_null=      &(fbind->is_null);
                 fbind->is_null=     1;
                 fbind->length=      0;
               }
    name: perl-DBD-mysql-gcc14.patch
    opt: -p1
perl-DBI:
  '1.643':
  - content: |
      From 32398bff24f054f4e9b48b97ecb70ce72267296c Mon Sep 17 00:00:00 2001
      From: Jens Rehsack <sno@netbsd.org>
      Date: Tue, 6 Oct 2020 06:50:37 +0200
      Subject: [PATCH 1/3] DBD/File,DBI/DBD/SqlEngine: bump copyright year

      Bump copyright years for both since there has been done work in meantime ...
      including intended f_dir= fix for CVE-2014-10401

      Signed-off-by: Jens Rehsack <sno@netbsd.org>
      ---
       lib/DBD/File.pm          | 4 ++--
       lib/DBI/DBD/SqlEngine.pm | 4 ++--
       2 files changed, 4 insertions(+), 4 deletions(-)

      diff --git a/lib/DBD/File.pm b/lib/DBD/File.pm
      index dd4312b..fb14e9a 100644
      --- a/lib/DBD/File.pm
      +++ b/lib/DBD/File.pm
      @@ -9,7 +9,7 @@
       #
       #  The original author is Jochen Wiedmann.
       #
      -#  Copyright (C) 2009-2013 by H.Merijn Brand & Jens Rehsack
      +#  Copyright (C) 2009-2020 by H.Merijn Brand & Jens Rehsack
       #  Copyright (C) 2004 by Jeff Zucker
       #  Copyright (C) 1998 by Jochen Wiedmann
       #
      @@ -1430,7 +1430,7 @@ The original author is Jochen Wiedmann.
       
       =head1 COPYRIGHT AND LICENSE
       
      - Copyright (C) 2009-2013 by H.Merijn Brand & Jens Rehsack
      + Copyright (C) 2009-2020 by H.Merijn Brand & Jens Rehsack
        Copyright (C) 2004-2009 by Jeff Zucker
        Copyright (C) 1998-2004 by Jochen Wiedmann
       
      diff --git a/lib/DBI/DBD/SqlEngine.pm b/lib/DBI/DBD/SqlEngine.pm
      index fb755ab..8e933f7 100644
      --- a/lib/DBI/DBD/SqlEngine.pm
      +++ b/lib/DBI/DBD/SqlEngine.pm
      @@ -9,7 +9,7 @@
       #
       #  The original author is Jochen Wiedmann.
       #
      -#  Copyright (C) 2009-2013 by H.Merijn Brand & Jens Rehsack
      +#  Copyright (C) 2009-2020 by H.Merijn Brand & Jens Rehsack
       #  Copyright (C) 2004 by Jeff Zucker
       #  Copyright (C) 1998 by Jochen Wiedmann
       #
      @@ -2216,7 +2216,7 @@ The original authors are Jochen Wiedmann and Jeff Zucker.
       
       =head1 COPYRIGHT AND LICENSE
       
      - Copyright (C) 2009-2013 by H.Merijn Brand & Jens Rehsack
      + Copyright (C) 2009-2020 by H.Merijn Brand & Jens Rehsack
        Copyright (C) 2004-2009 by Jeff Zucker
        Copyright (C) 1998-2004 by Jochen Wiedmann
       

      From 27b10b5c3aacabc091046beaba478e671bb6111c Mon Sep 17 00:00:00 2001
      From: Jens Rehsack <sno@netbsd.org>
      Date: Tue, 6 Oct 2020 08:23:55 +0200
      Subject: [PATCH 2/3] t/51dbm_file.t: add test from RT#99508

      Add test with f_dir="something-not-existing" as reported in RT#99508
      to verify when it's fixed for real.

      Signed-off-by: Jens Rehsack <sno@netbsd.org>
      ---
       t/51dbm_file.t | 23 +++++++++++++++++++++++
       1 file changed, 23 insertions(+)

      diff --git a/t/51dbm_file.t b/t/51dbm_file.t
      index d9824cf..686a3d2 100644
      --- a/t/51dbm_file.t
      +++ b/t/51dbm_file.t
      @@ -15,6 +15,27 @@ use DBI;
       
       do "./t/lib.pl";
       
      +{
      +    # test issue reported in RT#99508
      +    my @msg;
      +    eval {
      +	local $SIG{__DIE__} = sub { push @msg, @_ };
      +	my $dbh = DBI->connect ("dbi:DBM:f_dir=./hopefully-doesnt-existst;sql_identifier_case=1;RaiseError=1");
      +    };
      +    like ("@msg", qr{.*hopefully-doesnt-existst.*}, "Cannot open from non-existing directory with attributes in DSN");
      +
      +    @msg = ();
      +    eval {
      +	local $SIG{__DIE__} = sub { push @msg, @_ };
      +	my $dbh = DBI->connect ("dbi:DBM:", , undef, undef, {
      +	    f_dir               => "./hopefully-doesnt-existst",
      +	    sql_identifier_case => 1,
      +	    RaiseError          => 1,
      +	});
      +    };
      +    like ("@msg", qr{.*hopefully-doesnt-existst}, "Cannot open from non-existing directory with attributes in HASH");
      +}
      +
       my $dir = test_dir();
       
       my $dbh = DBI->connect( 'dbi:DBM:', undef, undef, {
      @@ -23,6 +44,8 @@ my $dbh = DBI->connect( 'dbi:DBM:', undef, undef, {
           }
       );
       
      +ok( $dbh, "Connect with driver attributes in hash" );
      +
       ok( $dbh->do(q/drop table if exists FRED/), 'drop table' );
       
       my $dirfext = $^O eq 'VMS' ? '.sdbm_dir' : '.dir';

      From 19d0fb169eed475e1c053e99036b8668625cfa94 Mon Sep 17 00:00:00 2001
      From: Jens Rehsack <sno@netbsd.org>
      Date: Tue, 6 Oct 2020 10:22:17 +0200
      Subject: [PATCH 3/3] lib/DBD/File.pm: fix CVE-2014-10401

      Dig into the root cause of RT#99508 - which resulted in CVE-2014-10401 - and
      figure out that DBI->parse_dsn is the wrong helper to parse our attributes in
      DSN, since in DBD::dr::connect only the "dbname" remains from DSN which causes
      parse_dsn to bailout.

      Parsing on our own similar to parse_dsn shows the way out.

      Signed-off-by: Jens Rehsack <sno@netbsd.org>
      ---
       lib/DBD/File.pm | 7 +++++--
       1 file changed, 5 insertions(+), 2 deletions(-)

      diff --git a/lib/DBD/File.pm b/lib/DBD/File.pm
      index fb14e9a..f55076f 100644
      --- a/lib/DBD/File.pm
      +++ b/lib/DBD/File.pm
      @@ -109,7 +109,11 @@ sub connect
           # We do not (yet) care about conflicting attributes here
           # my $dbh = DBI->connect ("dbi:CSV:f_dir=test", undef, undef, { f_dir => "text" });
           # will test here that both test and text should exist
      -    if (my $attr_hash = (DBI->parse_dsn ($dbname))[3]) {
      +    #
      +    # Parsing on our own similar to parse_dsn to find attributes in 'dbname' parameter.
      +    if ($dbname) {
      +	my @attrs = split /;/ => $dbname;
      +	my $attr_hash = { map { split /\s*=>?\s*|\s*,\s*/, $_} @attrs };
       	if (defined $attr_hash->{f_dir} && ! -d $attr_hash->{f_dir}) {
       	    my $msg = "No such directory '$attr_hash->{f_dir}";
       	    $drh->set_err (2, $msg);
      @@ -120,7 +124,6 @@ sub connect
           if ($attr and defined $attr->{f_dir} && ! -d $attr->{f_dir}) {
       	my $msg = "No such directory '$attr->{f_dir}";
       	$drh->set_err (2, $msg);
      -	$attr->{RaiseError} and croak $msg;
       	return;
       	}
       
      From c71b64a678bcd708c7b75ee2bef5a360c836444c Mon Sep 17 00:00:00 2001
      From: "H.Merijn Brand - Tux" <linux@tux.freedom.nl>
      Date: Wed, 28 Oct 2020 15:57:17 +0100
      Subject: [PATCH] Document the new behavior for f_dir

      These changes also warrant a version increase
      ---
       lib/DBD/File.pm | 5 +++++
       3 files changed, 7 insertions(+), 2 deletions(-)

      diff --git a/lib/DBD/File.pm b/lib/DBD/File.pm
      index baffefa..afbff26 100644
      --- a/lib/DBD/File.pm
      +++ b/lib/DBD/File.pm
      @@ -1062,6 +1062,11 @@ directory) when the dbh attribute is set.
       
         f_dir => "/data/foo/csv",
       
      +If C<f_dir> is set to a non-existing location, the connection will fail.
      +See CVE-2014-10401 for reasoning. Because of this, folders to use cannot
      +be created after the connection, but must exist before the connection is
      +initiated.
      +
       See L<KNOWN BUGS AND LIMITATIONS>.
       
       =head4 f_dir_search
      From 89f0d4cd38b83f0ee426a5fdf7d1ad5ea371c883 Mon Sep 17 00:00:00 2001
      From: "H.Merijn Brand - Tux" <linux@tux.freedom.nl>
      Date: Wed, 28 Oct 2020 15:03:48 +0100
      Subject: [PATCH] Fix for empty attributes in DSN

      dbm_type=SDBM_File;dbm_mldbm=;f_lockfile=.lck'
                                   ^
      would result in

      Odd number of elements in anonymous hash
      ---
       lib/DBD/File.pm | 5 +++--
       1 file changed, 3 insertions(+), 2 deletions(-)

      diff --git a/lib/DBD/File.pm b/lib/DBD/File.pm
      index f55076f..baffefa 100644
      --- a/lib/DBD/File.pm
      +++ b/lib/DBD/File.pm
      @@ -112,8 +112,9 @@ sub connect
           #
           # Parsing on our own similar to parse_dsn to find attributes in 'dbname' parameter.
           if ($dbname) {
      -	my @attrs = split /;/ => $dbname;
      -	my $attr_hash = { map { split /\s*=>?\s*|\s*,\s*/, $_} @attrs };
      +	my $attr_hash = {
      +	    map { (m/^\s* (\S+) \s*(?: =>? | , )\s* (\S*) \s*$/x) }
      +	    split m/;/ => $dbname };
       	if (defined $attr_hash->{f_dir} && ! -d $attr_hash->{f_dir}) {
       	    my $msg = "No such directory '$attr_hash->{f_dir}";
       	    $drh->set_err (2, $msg);
      From 2eda0ec996d0a9357885acd442c72ac206adb7b3 Mon Sep 17 00:00:00 2001
      From: "H.Merijn Brand - Tux" <linux@tux.freedom.nl>
      Date: Wed, 28 Oct 2020 15:09:01 +0100
      Subject: [PATCH] Catch warning

      ---
       t/51dbm_file.t | 16 ++++++++++------
       1 file changed, 10 insertions(+), 6 deletions(-)

      diff --git a/t/51dbm_file.t b/t/51dbm_file.t
      index 686a3d2..0ae910c 100644
      --- a/t/51dbm_file.t
      +++ b/t/51dbm_file.t
      @@ -18,21 +18,25 @@ do "./t/lib.pl";
       {
           # test issue reported in RT#99508
           my @msg;
      -    eval {
      -	local $SIG{__DIE__} = sub { push @msg, @_ };
      -	my $dbh = DBI->connect ("dbi:DBM:f_dir=./hopefully-doesnt-existst;sql_identifier_case=1;RaiseError=1");
      +    my $dbh = eval {
      +	local $SIG{__WARN__} = sub { push @msg, @_ };
      +	local $SIG{__DIE__}  = sub { push @msg, @_ };
      +	DBI->connect ("dbi:DBM:f_dir=./hopefully-doesnt-existst;sql_identifier_case=1;RaiseError=1");
           };
      +    is ($dbh, undef, "Connect failed");
           like ("@msg", qr{.*hopefully-doesnt-existst.*}, "Cannot open from non-existing directory with attributes in DSN");
       
           @msg = ();
      -    eval {
      -	local $SIG{__DIE__} = sub { push @msg, @_ };
      -	my $dbh = DBI->connect ("dbi:DBM:", , undef, undef, {
      +    $dbh = eval {
      +	local $SIG{__WARN__} = sub { push @msg, @_ };
      +	local $SIG{__DIE__}  = sub { push @msg, @_ };
      +	DBI->connect ("dbi:DBM:", , undef, undef, {
       	    f_dir               => "./hopefully-doesnt-existst",
       	    sql_identifier_case => 1,
       	    RaiseError          => 1,
       	});
           };
      +    is ($dbh, undef, "Connect failed");
           like ("@msg", qr{.*hopefully-doesnt-existst}, "Cannot open from non-existing directory with attributes in HASH");
       }
       
    name: perl-DBI-CVE-2014-10402.patch
    opt: -p1
perl-Dancer2-Plugin-Auth-Extensible:
  '0.710':
  - content: |
      diff --git a/bin/dancer2-generate-crypted-password b/bin/dancer2-generate-crypted-password
      index 7747742..109881c 100755
      --- a/bin/dancer2-generate-crypted-password
      +++ b/bin/dancer2-generate-crypted-password
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use Crypt::SaltedHash;
    name: remove-env-perl.patch
    opt: -p1
perl-Data-Locations:
  '5.5':
  - content: |
      --- Data-Locations-5.5.orig/t/01________new.t	2009-10-07 23:45:04.000000000 +0200
      +++ Data-Locations-5.5/t/01________new.t	2020-02-21 15:52:06.615623067 +0100
      @@ -84,7 +84,7 @@
           if (ref($loc) eq 'Data::Locations')
           {print "ok $n\n";} else {print "not ok $n\n";}
           $n++;
      -    if (defined %{*{$loc}})
      +    if (%{*{$loc}})
           {print "ok $n\n";} else {print "not ok $n\n";}
           $n++;
           if (exists ${*{$loc}}{'name'})
    name: defined-hash.patch
    opt: -p1
perl-Data-Package:
  '1.05':
  - content: |
      --- Data-Package-1.05.orig/lib/Data/Package.pm	2007-11-20 03:14:06.000000000 +0100
      +++ Data-Package-1.05/lib/Data/Package.pm	2020-02-21 16:02:25.128213304 +0100
      @@ -243,7 +243,7 @@
       
       	# If the class has a @PROVIDES array, we'll use that directly.
       	no strict 'refs';
      -	if ( defined @{"${class}::PROVIDES"} ) {
      +	if ( defined *{"${class}::PROVIDES"}{ARRAY}) {
       		return @{"${class}::PROVIDES"};
       	}
       
    name: defined-array.patch
    opt: -p1
perl-Data-Undump:
  '0.15':
  - content: |
      --- Undump.xs	2013-08-22 09:51:50.000000000 -0700
      +++ Undump.xs.bay-max	2018-01-03 14:35:27.000000000 -0800
      @@ -897,53 +897,10 @@
                       if (WANT_KEY(fs)) {
                           DONE_KEY_SIMPLE_break;
                       } 
      -                ch= ps_parse_ptr - fs_token_start;
      -                if (fs_token_start[0] == '-') {
      -                    IV iv= 0;
      -                    if ( ch < 12) {
      -                        fs_token_start++;
      -                        switch (ch) {
      -                            case 11: iv -= (*fs_token_start++ - '0') * 1000000000L;
      -                            case 10: iv -= (*fs_token_start++ - '0') * 100000000L;
      -                            case  9: iv -= (*fs_token_start++ - '0') * 10000000L;
      -                            case  8: iv -= (*fs_token_start++ - '0') * 1000000L;
      -                            case  7: iv -= (*fs_token_start++ - '0') * 100000L;
      -                            case  6: iv -= (*fs_token_start++ - '0') * 10000L;
      -                            case  5: iv -= (*fs_token_start++ - '0') * 1000L;
      -                            case  4: iv -= (*fs_token_start++ - '0') * 100L;
      -                            case  3: iv -= (*fs_token_start++ - '0') * 10L;
      -                            case  2: iv -= (*fs_token_start++ - '0') * 1L;
      -                                break;
      -                            default: 
      -                                PANICf1(ps,fs,"Strange length for negative integer in switch: %d", ch);
      -                        }
      -                        fs_got= newSViv(iv);
      -                    } else {
      -                        goto MAKE_SV;
      -                    }
      -                } else {
      -                    if (ch < 11 ) {
      -                        UV uv= 0;
      -                        switch (ch) {
      -                            case 10: uv += (*fs_token_start++ - '0') * 1000000000L;
      -                            case  9: uv += (*fs_token_start++ - '0') * 100000000L;
      -                            case  8: uv += (*fs_token_start++ - '0') * 10000000L;
      -                            case  7: uv += (*fs_token_start++ - '0') * 1000000L;
      -                            case  6: uv += (*fs_token_start++ - '0') * 100000L;
      -                            case  5: uv += (*fs_token_start++ - '0') * 10000L;
      -                            case  4: uv += (*fs_token_start++ - '0') * 1000L;
      -                            case  3: uv += (*fs_token_start++ - '0') * 100L;
      -                            case  2: uv += (*fs_token_start++ - '0') * 10L;
      -                            case  1: uv += (*fs_token_start++ - '0') * 1L;
      -                                break;
      -                            default: 
      -                                PANICf1(ps,fs,"Strange length for integer in switch: %d", ch);
      -                        }
      -                        fs_got= newSVuv(uv);
      -                    } else {
      -                        goto MAKE_SV;
      -                    }
      -                }
      +                
      +                fs_got= newSVpvn(fs_token_start, ps_parse_ptr - fs_token_start);
      +                fs_got= newSViv(SvIV(fs_got));
      +                
                       goto GOT_SV;
                   }
                   case TOKEN_NV:
    name: Undump.xs-TOKEN_IV-fix.patch
    opt: PATCH-FIX-UPSTREAM https://rt.cpan.org/Public/Bug/Display.html?id=88462
perl-Date-Calc:
  '6.4':
  - content: |
      Date: 2023-03-17
      Author: Bernhard M. Wiedemann

      Fix year2038 issue

      https://rt.cpan.org/Public/Bug/Display.html?id=102495

      Index: Date-Calc-6.4/lib/Date/Calc/PP.pm
      ===================================================================
      --- Date-Calc-6.4.orig/lib/Date/Calc/PP.pm
      +++ Date-Calc-6.4/lib/Date/Calc/PP.pm
      @@ -2057,21 +2057,13 @@ sub DateCalc_mktime
           {
               return 0 if
               (
      -            ($year  < 1970) or ($year  > 2038) or
      +            ($year  < 1970) or
                   ($month <    1) or ($month >   12) or
                   ($day   <    1) or ($day   >   31) or
                   ($hour  <    0) or ($hour  >   23) or
                   ($min   <    0) or ($min   >   59) or
                   ($sec   <    0) or ($sec   >   59)
               );
      -        return 0 if
      -        (
      -            ($year == 2038) and ( ($month >  1) or
      -                                ( ($month == 1) and ( ($day >  19) or
      -                                                    ( ($day == 19) and ( ($hour >  3) or
      -                                                                       ( ($hour == 3) and ( ($min >  14) or
      -                                                                                          ( ($min == 14) and ($sec > 7) ) )))))))
      -        );
           }
           $year -= 1900;
           $month--;
    name: fix2038.patch
    opt: -p1
perl-Date-Calc-XS:
  '6.4':
  - content: |
      Date: 2023-03-17
      Author: Bernhard M. Wiedemann

      Fix dates beyond year 2038

      https://rt.cpan.org/Ticket/Display.html?id=147194

      Index: Date-Calc-XS-6.4/DateCalc.c
      ===================================================================
      --- Date-Calc-XS-6.4.orig/DateCalc.c
      +++ Date-Calc-XS-6.4/DateCalc.c
      @@ -1488,7 +1488,7 @@ boolean DateCalc_mktime(time_t *seconds,
       #ifdef MACOS_TRADITIONAL
           if ( (year  < 1904) or (year  > 2040) or
       #else
      -    if ( (year  < 1970) or (year  > 2038) or
      +    if ( (year  < 1970) or ((sizeof(time_t) == 4) and (year  > 2038)) or
       #endif
                (month <    1) or (month >   12) or
                (day   <    1) or (day   >   31) or
      @@ -1505,7 +1505,7 @@ boolean DateCalc_mktime(time_t *seconds,
                                                                                         ( (min == 28) and (sec > 15) ) ))))))) )
           return(false);
       #else
      -    if ( (year == 2038) and ( (month >  1) or
      +    if ( (sizeof(time_t) == 4) and (year == 2038) and ( (month >  1) or
                                   ( (month == 1) and ( (day >  19) or
                                                      ( (day == 19) and ( (hour >  3) or
                                                                        ( (hour == 3) and ( (min >  14) or
    name: fix2038.patch
    opt: -p1 PATCH-FIX-UPSTREAM bmwiedemann https://rt.cpan.org/Public/Bug/Display.html?id=147194
perl-Devel-Cycle:
  '1.12':
  - content: |
      --- lib/Devel/Cycle.old	2009-08-24 08:54:45.000000000 -0400
      +++ lib/Devel/Cycle.pm	2010-04-16 20:53:30.000000000 -0400
      @@ -215,7 +215,7 @@
       sub _get_type {
         my $thingy = shift;
         return unless ref $thingy;
      -  return 'SCALAR' if UNIVERSAL::isa($thingy,'SCALAR') || UNIVERSAL::isa($thingy,'REF');
      +  return 'SCALAR' if UNIVERSAL::isa($thingy,'SCALAR') || UNIVERSAL::isa($thingy,'REF') || UNIVERSAL::isa($thingy,'Regexp');
         return 'ARRAY'  if UNIVERSAL::isa($thingy,'ARRAY');
         return 'HASH'   if UNIVERSAL::isa($thingy,'HASH');
         return 'CODE'   if UNIVERSAL::isa($thingy,'CODE');
    name: Devel-Cycle-pm.patch
    opt: null
  - content: |
      --- t/Devel-Cycle.old	2008-07-08 21:26:35.000000000 -0400
      +++ t/Devel-Cycle.t	2010-04-16 20:39:04.000000000 -0400
      @@ -5,7 +5,7 @@
       
       # change 'tests => 1' to 'tests => last_test_to_print';
       
      -use Test::More tests => 12;
      +use Test::More tests => 13;
       use Scalar::Util qw(weaken isweak);
       BEGIN { use_ok('Devel::Cycle') };
       
      @@ -87,6 +87,7 @@
       }
       
       {
      +    no warnings qw{ once };
           *FOOBAR = *FOOBAR if 0; # cease -w
           my $test2 = { glob => \*FOOBAR };
       
      @@ -101,6 +102,15 @@
           is("@warnings", "", "Warn only once");
       }
       
      +{
      +    my $test_re = qr{foo}xms;
      +
      +    my @warnings;
      +    local $SIG{__WARN__} = sub { push @warnings, @_ };
      +    find_cycle($test_re);
      +    ok( !@warnings, 'No warnings on Regex' );
      +}
      +
       package foo;
       use overload q("") => sub{ return 1 };  # show false alarm
       
    name: Devel-Cycle-t.patch
    opt: null
perl-EV:
  '4.33':
  - content: |
      --- libev/ev_iouring.c.orig	2020-03-08 16:55:17.000000000 +0100
      +++ libev/ev_iouring.c	2021-04-21 17:34:58.985032376 +0200
      @@ -297,6 +297,7 @@
         ++EV_SQ_VAR (tail);
         /*ECB_MEMORY_FENCE_RELEASE; /* for the time being we assume this is not needed */
         ++iouring_to_submit;
      +  return NULL;
       }
       
       /*****************************************************************************/
      @@ -328,6 +329,7 @@
             ev_ref (EV_A);
             ev_io_stop (EV_A_ &iouring_tfd_w);
           }
      +  return 0;
       }
       
       ecb_cold
    name: ev_iouring.diff
    opt: -p0
perl-Exception-Base:
  '0.2501':
  - content: |
      --- t/tlib/Exception/BaseTest.pm
      +++ t/tlib/Exception/BaseTest.pm
      @@ -569,7 +569,8 @@
           $self->assert_matches(qr/String at /, $obj);
       
           # smart matching for Perl 5.10
      -    if ($] >= 5.010) {
      +    # Deprecation warning added in 5.37.10
      +    if ($] >= 5.010 && $] < 5.037010) {
               no if $] >= 5.018, warnings => 'experimental::smartmatch';
               eval q{
                   $self->assert_num_equals(1, 'String' ~~ $obj);
       
    name: fix_perl538.patch
    opt: -p0 PATCH-FIX-UPSTREAM deprecated smartmatch operator https://github.com/dex4er/perl-Exception-Base/issues/5
perl-Expect:
  1.380.0:
  - content: |
      diff -uNr Expect-1.15/examples/kibitz/kibitz Expect-new/examples/kibitz/kibitz
      --- Expect-1.15/examples/kibitz/kibitz	Sat Nov 17 14:18:49 2001
      +++ Expect-new/examples/kibitz/kibitz	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       # Original author: Author: Don Libes, NIST (tcl/expect)
       # Date written: December 5, 1991
       # Date last editted: October 19, 1994
      diff -uNr Expect-1.15/tutorial/2.A.ftp Expect-new/tutorial/2.A.ftp
      --- Expect-1.15/tutorial/2.A.ftp	Sat Nov 17 14:18:48 2001
      +++ Expect-new/tutorial/2.A.ftp	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	This example demonstrates how to spawn an ftp process, have it
       #log in to a host, and grab a file off the host. This should give you a
       #general idea of how to spawn processes and talk to them.
      diff -uNr Expect-1.15/tutorial/2.B.rlogin Expect-new/tutorial/2.B.rlogin
      --- Expect-1.15/tutorial/2.B.rlogin	Sat Nov 17 14:18:47 2001
      +++ Expect-new/tutorial/2.B.rlogin	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	There are three new things in this example. First is the concept
       #of closing the process, second is the concept of using regular
       #expressions in match patterns, and third is the concept of grabbing
      diff -uNr Expect-1.15/tutorial/3.A.debugging Expect-new/tutorial/3.A.debugging
      --- Expect-1.15/tutorial/3.A.debugging	Sat Nov 17 14:18:48 2001
      +++ Expect-new/tutorial/3.A.debugging	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	This example demonstrates how to use the debugging features in 
       #expect. They're reasonably straghtforward.
       #
      diff -uNr Expect-1.15/tutorial/4.A.top Expect-new/tutorial/4.A.top
      --- Expect-1.15/tutorial/4.A.top	Sat Nov 17 14:18:47 2001
      +++ Expect-new/tutorial/4.A.top	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	This example is a replay of sorts of the rlogin example
       #before except in this example we turn control of the process back
       #to the user through use of interact().
      diff -uNr Expect-1.15/tutorial/5.A.top Expect-new/tutorial/5.A.top
      --- Expect-1.15/tutorial/5.A.top	Sat Nov 17 14:18:47 2001
      +++ Expect-new/tutorial/5.A.top	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	Here we are doing this again only this time we'll do it
       #without Echoing the password.
       	
      diff -uNr Expect-1.15/tutorial/5.B.top Expect-new/tutorial/5.B.top
      --- Expect-1.15/tutorial/5.B.top	Sat Nov 17 14:18:48 2001
      +++ Expect-new/tutorial/5.B.top	Fri Apr  5 09:24:52 2002
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl
      +#!/usr/bin/perl
       #	Here we set manual_stty on the process so we can do things like
       #hit ^Z to stop it instead of the ^Z going to the process on the other machine.
       #	This is to say, normally when you interact with a process STDIN is
    name: Expect.diff
    opt: -p1
perl-ExtUtils-MakeMaker:
  '7.70':
  - content: |
      From 4361bd6fb0717f99f6b21ed053542e01c5093af2 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Thu, 12 Jan 2012 17:05:19 +0100
      Subject: [PATCH] Do not set RPATH by default
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Former behavior can be forced by setting USE_MM_LD_RUN_PATH
      environment variable to 1.

      This is copy from `perl' package.
      See <https://bugzilla.redhat.com/show_bug.cgi?id=773622>.

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      [ddiss@suse.de: also handle LD_RUN_PATH set in MM_Any.pm]
      ---
       lib/ExtUtils/Liblist.pm   |    5 ++++
       lib/ExtUtils/MM_Any.pm    |    1 
       lib/ExtUtils/MM_Unix.pm   |    2 -
       lib/ExtUtils/MakeMaker.pm |   56 +++++++++++++++++++++++++++++++++++++++++++++-
       4 files changed, 62 insertions(+), 2 deletions(-)

      Index: ExtUtils-MakeMaker-7.36/lib/ExtUtils/Liblist.pm
      ===================================================================
      --- ExtUtils-MakeMaker-7.36.orig/lib/ExtUtils/Liblist.pm
      +++ ExtUtils-MakeMaker-7.36/lib/ExtUtils/Liblist.pm
      @@ -89,6 +89,11 @@ libraries.  LD_RUN_PATH is a colon separ
       in LDLOADLIBS. It is passed as an environment variable to the process
       that links the shared library.
       
      +Fedora extension: This generation of LD_RUN_PATH is disabled by default.
      +To use the generated LD_RUN_PATH for all links, set the USE_MM_LD_RUN_PATH
      +MakeMaker object attribute / argument, (or set the $USE_MM_LD_RUN_PATH
      +environment variable).
      +
       =head2 BSLOADLIBS
       
       List of those libraries that are needed but can be linked in
      Index: ExtUtils-MakeMaker-7.36/lib/ExtUtils/MM_Unix.pm
      ===================================================================
      --- ExtUtils-MakeMaker-7.36.orig/lib/ExtUtils/MM_Unix.pm
      +++ ExtUtils-MakeMaker-7.36/lib/ExtUtils/MM_Unix.pm
      @@ -1074,7 +1074,7 @@ sub xs_make_dynamic_lib {
           }
       
           my $ld_run_path_shell = "";
      -    if ($self->{LD_RUN_PATH} ne "") {
      +    if (($self->{LD_RUN_PATH} ne "") && ($self->{USE_MM_LD_RUN_PATH})) {
               $ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
           }
       
      Index: ExtUtils-MakeMaker-7.36/lib/ExtUtils/MakeMaker.pm
      ===================================================================
      --- ExtUtils-MakeMaker-7.36.orig/lib/ExtUtils/MakeMaker.pm
      +++ ExtUtils-MakeMaker-7.36/lib/ExtUtils/MakeMaker.pm
      @@ -317,7 +317,7 @@ sub full_setup {
           PERM_DIR PERM_RW PERM_RWX MAGICXS
           PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE
           PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ PUREPERL_ONLY
      -    SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS
      +    SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST USE_MM_LD_RUN_PATH VERSION VERSION_FROM XS
           XSBUILD XSMULTI XSOPT XSPROTOARG XS_VERSION
           clean depend dist dynamic_lib linkext macro realclean tool_autosplit
       
      @@ -503,6 +503,26 @@ sub new {
               $self->_PRINT_PREREQ;
          }
       
      +    # USE_MM_LD_RUN_PATH - another RedHatism to disable automatic RPATH generation
      +    if ( ( ! $self->{USE_MM_LD_RUN_PATH} )
      +       &&( ("@ARGV" =~ /\bUSE_MM_LD_RUN_PATH(=([01]))?\b/)
      +        ||( exists( $ENV{USE_MM_LD_RUN_PATH} )
      +           &&( $ENV{USE_MM_LD_RUN_PATH} =~ /([01])?$/ )
      +           )
      +        )
      +       )
      +    {
      +       my $v = $1;
      +       if( $v )
      +       {
      +           $v = ($v=~/=([01])$/)[0];
      +       }else
      +       {
      +           $v = 1;
      +       };
      +       $self->{USE_MM_LD_RUN_PATH}=$v;
      +    };
      +
           print "MakeMaker (v$VERSION)\n" if $Verbose;
           if (-f "MANIFEST" && ! -f "Makefile" && ! $UNDER_CORE){
               check_manifest();
      @@ -2837,6 +2857,40 @@ precedence.  A typemap in the current di
       precedence, even if it isn't listed in TYPEMAPS.  The default system
       typemap has lowest precedence.
       
      +=item USE_MM_LD_RUN_PATH
      +
      +boolean
      +The Fedora perl MakeMaker distribution differs from the standard
      +upstream release in that it disables use of the MakeMaker generated
      +LD_RUN_PATH by default, UNLESS this attribute is specified , or the
      +USE_MM_LD_RUN_PATH environment variable is set during the MakeMaker run.
      +
      +The upstream MakeMaker will set the ld(1) environment variable LD_RUN_PATH
      +to the concatenation of every -L ld(1) option directory in which a -l ld(1)
      +option library is found, which is used as the ld(1) -rpath option if none
      +is specified. This means that, if your application builds shared libraries
      +and your MakeMaker application links to them, that the absolute paths of the
      +libraries in the build tree will be inserted into the RPATH header of all
      +MakeMaker generated binaries, and that such binaries will be unable to link
      +to these libraries if they do not still reside in the build tree directories
      +(unlikely) or in the system library directories (/lib or /usr/lib), regardless
      +of any LD_LIBRARY_PATH setting. So if you specified -L../mylib -lmylib , and
      + your 'libmylib.so' gets installed into /some_directory_other_than_usr_lib,
      + your MakeMaker application will be unable to link to it, even if LD_LIBRARY_PATH
      +is set to include /some_directory_other_than_usr_lib, because RPATH overrides
      +LD_LIBRARY_PATH.
      +
      +So for Fedora MakeMaker builds LD_RUN_PATH is NOT generated by default for
      +every link. You can still use explicit -rpath ld options or the LD_RUN_PATH
      +environment variable during the build to generate an RPATH for the binaries.
      +
      +You can set the USE_MM_LD_RUN_PATH attribute to 1 on the MakeMaker command
      +line or in the WriteMakefile arguments to enable generation of LD_RUN_PATH
      +for every link command.
      +
      +USE_MM_LD_RUN_PATH will default to 1 (LD_RUN_PATH will be used) IF the
      +$USE_MM_LD_RUN_PATH environment variable is set during a MakeMaker run.
      +
       =item VENDORPREFIX
       
       Like PERLPREFIX, but only for the vendor install locations.
      Index: ExtUtils-MakeMaker-7.36/lib/ExtUtils/MM_Any.pm
      ===================================================================
      --- ExtUtils-MakeMaker-7.36.orig/lib/ExtUtils/MM_Any.pm
      +++ ExtUtils-MakeMaker-7.36/lib/ExtUtils/MM_Any.pm
      @@ -2437,6 +2437,7 @@ sub init_others {
                   # LD_RUN_PATH now computed by ExtUtils::Liblist
                   ($self->{EXTRALIBS},  $self->{BSLOADLIBS},
                    $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @libs;
      +            $self->{LD_RUN_PATH} = "" unless $self->{USE_MM_LD_RUN_PATH};
                   last;
               }
           }
    name: Do_not_set_RPATH_by_default.patch
    opt: -p1
perl-File-Rename:
  2.20.0:
  - content: |
      Name the command `file-rename` so as not to conflict with the command provided by `util-linux`.

      This is not only the upstream's choice of an alternative name, but also makes us compatible with Debian
      (see https://salsa.debian.org/perl-team/modules/packages/rename/-/blob/master/debian/rules )


      diff --git a/Makefile.PL b/Makefile.PL
      index ea8fb98..d91de90 100644
      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -15,7 +15,7 @@ warn "No Perl::OSType\n" unless ($has_os or $] < 5.014);
       my $is_win = ( $has_os ? Perl::OSType::is_os_type('Windows') 
                               : $INC{'ExtUtils/MM_Win32.pm'} );
       my $script = File::Spec->catfile( 'script',
      -                $is_win ? 'file-rename' : 'rename' );
      +                'file-rename' );
       my $unsafe = File::Spec->catfile( 'script',
                                           'unsafe-rename');
       my $source = File::Spec->catfile( 'source', 'rename');
      diff --git a/t/testlib.pl b/t/testlib.pl
      index 9e1abeb..6c8f35c 100644
      --- a/t/testlib.pl
      +++ b/t/testlib.pl
      @@ -138,7 +138,7 @@ sub is_windows {
       }
       
       sub script_name {
      -    return +( is_windows() ? 'file-rename' : 'rename' );
      +    return +('file-rename');
       }
       
       sub unsafe_script_name { return 'unsafe-rename'; }
    name: change-command-name.patch
    opt: -p1 PATCH-FIX-OPENSUSE
perl-Finance-Quote:
  '1.54':
  - content: |
      From 504fcc1ae35fd9c1e59949281e2939bda6a971a5 Mon Sep 17 00:00:00 2001
      From: Paul Howarth <paul@city-fan.org>
      Date: Sat, 8 Apr 2023 11:48:20 +0100
      Subject: [PATCH] Tweak regex to fix FTfunds.pm

      ---
       lib/Finance/Quote/FTfunds.pm | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/lib/Finance/Quote/FTfunds.pm b/lib/Finance/Quote/FTfunds.pm
      index b1133134..45b04ed2 100644
      --- a/lib/Finance/Quote/FTfunds.pm
      +++ b/lib/Finance/Quote/FTfunds.pm
      @@ -182,7 +182,7 @@ DEBUG > 1 and print "\nCookie Jar = : \n",Dumper($cj),"\n\n";
       		my $currency;
       		my $price;
       		if ($webdoc->content =~
      -		m[<span class="mod-ui-data-list__label">Price [(]([A-Z]{3})[)]</span><span class="mod-ui-data-list__value">([\.\,0-9]*)</span>]  )
      +		m[<span class="mod-ui-data-list__label"[^>]*>Price [(]([A-Z]{3})[)]</span><span class="mod-ui-data-list__value">([\.\,0-9]*)</span>]  )
               {
       			$currency = $1;
       			$price    = $2;
    name: Fix-FTFunds-regex.patch
    opt: null
  - content: |
      diff -ur Finance-Quote-1.50/lib/Finance/Quote/Cdnfundlibrary.pm Finance-Quote-1.50_fix/lib/Finance/Quote/Cdnfundlibrary.pm
      --- Finance-Quote-1.50/lib/Finance/Quote/Cdnfundlibrary.pm	2021-06-27 05:52:21.000000000 +0200
      +++ Finance-Quote-1.50_fix/lib/Finance/Quote/Cdnfundlibrary.pm	2021-08-25 18:33:24.262128339 +0200
      @@ -102,7 +102,7 @@
       
             @rows = $te->rows;
             if(@rows) {
      -        $row = $rows[1];
      +        $row = $rows[0];
       
               $fundquote {$mutual, "name"} = trim($$row[0]);
               $fundquote {$mutual, "symbol"} = $mutual;
    name: perl-Finance-Quote-66235-Cdnfundlibrary-row.patch
    opt: -p1 PATCH-FIX-UPSTREAM https://rt.cpan.org/Public/Bug/Display.html?id=66235
perl-Furl:
  '3.14':
  - content: |+
      From 089e7229a96b7a0b165407fc2575c31c99fdb43b Mon Sep 17 00:00:00 2001
      From: Martchus <martchus@gmx.net>
      Date: Wed, 24 Jul 2019 12:28:32 +0200
      Subject: [PATCH] Remove use of Mozilla::CA

      The fallback to system-wide certificates seems to happen automatically
      if no CA path or CA file has been specified.
      ---
       META.json        | 1 -
       cpanfile         | 1 -
       lib/Furl/HTTP.pm | 6 ------
       3 files changed, 8 deletions(-)

      diff --git a/META.json b/META.json
      index d4ff609..350df3a 100644
      --- a/META.json
      +++ b/META.json
      @@ -71,7 +71,6 @@
                   "Encode" : "0",
                   "HTTP::Parser::XS" : "0.11",
                   "MIME::Base64" : "0",
      -            "Mozilla::CA" : "0",
                   "Scalar::Util" : "0",
                   "Socket" : "0",
                   "Time::HiRes" : "0",
      diff --git a/cpanfile b/cpanfile
      index d62b2ba..d0024d8 100644
      --- a/cpanfile
      +++ b/cpanfile
      @@ -1,7 +1,6 @@
       requires 'perl', 5.008_001;
       
       requires 'HTTP::Parser::XS' => 0.11;
      -requires 'Mozilla::CA';
       requires 'MIME::Base64';
       requires 'Class::Accessor::Lite';
       requires 'Encode';
      diff --git a/lib/Furl/HTTP.pm b/lib/Furl/HTTP.pm
      index 1f29d40..2b2477d 100644
      --- a/lib/Furl/HTTP.pm
      +++ b/lib/Furl/HTTP.pm
      @@ -686,12 +686,6 @@ sub _ssl_opts {
                   $ssl_opts->{SSL_verifycn_scheme} = 'www'
               }
           }
      -    if ($ssl_opts->{SSL_verify_mode}) {
      -        unless (exists $ssl_opts->{SSL_ca_file} || exists $ssl_opts->{SSL_ca_path}) {
      -            require Mozilla::CA;
      -            $ssl_opts->{SSL_ca_file} = Mozilla::CA::SSL_ca_file();
      -        }
      -    }
           $ssl_opts;
       }
       
      -- 
      2.22.0

    name: 0001-Remove-use-of-Mozilla-CA.patch
    opt: -p1
perl-GD:
  '2.78':
  - content: |
      Index: GD-2.71/Makefile.PL
      ===================================================================
      --- GD-2.71.orig/Makefile.PL
      +++ GD-2.71/Makefile.PL
      @@ -259,7 +259,7 @@ print F $DEFINES,"\n";
       close F;
       
       my $CCFLAGS = $Config{ccflags};
      -$CCFLAGS .= " -Wall -Wextra -Wformat=1" if $Config{gccversion} and $] > 5.020;
      +$CCFLAGS .= " -Wall -Wextra" if $Config{gccversion} and $] > 5.020;
       # hardened CFLAGS for testing
       #$CCFLAGS .= ' -D_GNU_SOURCE -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong -grecord-gcc-switches';
       my $LDDLFLAGS = $Config{lddlflags};
    name: GD-cflags.patch
    opt: -p1
perl-GDGraph:
  1.560.0:
  - content: |
      From 96862391296b235c60e0e36140f8ea498f70a74d Mon Sep 17 00:00:00 2001
      From: Reini Urban <rurban@cpan.org>
      Date: Tue, 1 Feb 2022 15:10:53 +0100
      Subject: [PATCH] fix logo_xbm_noext test

      causing t/bugfixes.t to fail with latest GD
      provide xbm magic, which has no newFromXbmData method.
      ---
       Graph.pm        | 6 +++++-
       t/images/main.c | 8 ++++++++
       2 files changed, 13 insertions(+), 1 deletion(-)
       create mode 100644 t/images/main.c

      diff --git a/Graph.pm b/Graph.pm
      index 816c99a..f12d588 100644
      --- a/Graph.pm
      +++ b/Graph.pm
      @@ -362,6 +363,9 @@ sub _read_logo_file
                           $glogo = GD::Image->$gdimport(\*LOGO);
                       }
                   }
      +        } elsif ($logo_path =~ /_xbm_/) { # no magic possible for xbm
      +            push @tried, 'xbm';
      +            $glogo = GD::Image->newFromXbm($logo_path);
               # should this actually be "if (!$glogo), rather than an else?            
               } else { # Hail Mary, full of Grace!  Blessed art thou among women...
                   push @tried, 'libgd best-guess';
      diff --git a/t/images/main.c b/t/images/main.c
      new file mode 100644
      index 0000000..6d64b11
      --- /dev/null
      +++ b/t/images/main.c
      @@ -0,0 +1,8 @@
      +#include <stdio.h>
      +#include "logo_xbm_noext.c"
      +
      +void main() {
      +  FILE *f = fopen ("logo_xbm_noext", "w");
      +  fwrite (logo_bits, sizeof(logo_bits), 1, f);
      +  fclose (f);
      +}
    name: perl-GDGraph-XBM-Magic.patch
    opt: -p1
perl-Getopt-Helpful:
  '0.04':
  - content: |
      --- Getopt-Helpful-0.04.orig/t/noconf_standard.t	2006-06-05 08:07:17.000000000 +0200
      +++ Getopt-Helpful-0.04/t/noconf_standard.t	2020-02-21 18:55:18.376385346 +0100
      @@ -90,6 +90,7 @@
       =cut
       sub res_check {
       	my ($expect, @run) = @_;
      +	local $Data::Dumper::Sortkeys = 1;
       	my $string = Dumper($expect);
       	my $out = catch(@run);
       	SKIP: {
    name: hash-randomization1.patch
    opt: -p1
  - content: |
      --- Getopt-Helpful-0.04.orig/t/noconf_standard-run.pl	2006-06-05 08:07:17.000000000 +0200
      +++ Getopt-Helpful-0.04/t/noconf_standard-run.pl	2020-02-21 18:53:51.275748980 +0100
      @@ -5,6 +5,7 @@
       
       use Getopt::Helpful;
       use Data::Dumper;
      +local $Data::Dumper::Sortkeys = 1;
       
       my $option = "no";
       my $var = "default";
    name: hash-randomization2.patch
    opt: -p1
  - content: |
      --- Getopt-Helpful-0.04.orig/t/verbose-debug.t	2006-06-05 08:07:17.000000000 +0200
      +++ Getopt-Helpful-0.04/t/verbose-debug.t	2020-02-21 19:16:53.601872190 +0100
      @@ -57,6 +57,7 @@
       	'+help'
       	);
       $hopt->Get();
      +local $Data::Dumper::Sortkeys = 1;
       print Dumper({v => $verbose, d => $debug});
       TEST_CODE
       
      @@ -79,6 +80,7 @@
       =cut
       sub res_check {
       	my ($expect, @run) = @_;
      +	local $Data::Dumper::Sortkeys = 1;
       	my $string = Dumper($expect);
       	my $out = catch(@run);
       	SKIP: {
    name: hash-randomization3.patch
    opt: -p1
perl-Git-Repository:
  '1.325':
  - content: |+
      --- a/t/20-simple.t
      +++ b/t/20-simple.t
      @@ -85,6 +85,9 @@
           skip "this test does not work with msysgit on Win32", 2
               if $^O eq 'MSWin32';
       
      +    skip "'git var GIT_EDITOR' behaviour was changed in git 2.40.0, and we have $version", 2
      +        if Git::Repository->version_ge('2.40.0');
      +
           ok( !eval { $r->run( var => 'GIT_EDITOR' ); 1; }, 'git var GIT_EDITOR' );
           like(
               $@,

    name: git-2.40.0.patch
    opt: -p1 PATCH-FIX-UPSTREAM https://github.com/book/Git-Repository/pull/23
  - content: |
      From 4dc8dedb97891f37b9da2220e5740c65685b0906 Mon Sep 17 00:00:00 2001
      From: Jan Pazdziora <jpazdziora@redhat.com>
      Date: Mon, 31 Oct 2022 17:26:00 +0100
      Subject: [PATCH] Workaround change of behaviour in git 2.38.1 for
       CVE-2022-39253.

      By default, protocol.file.allow now defaults to user, preventing
      clones with symlinks.

      https://github.blog/2022-10-18-git-security-vulnerabilities-announced/#cve-2022-39253
      ---
       t/21-submodule.t | 1 +
       1 file changed, 1 insertion(+)

      diff --git a/t/21-submodule.t b/t/21-submodule.t
      index 444029c..97374f8 100644
      --- a/t/21-submodule.t
      +++ b/t/21-submodule.t
      @@ -44,6 +44,7 @@ $s->run( checkout => 'master', { quiet => 1 } );
       # now test adding a submodule
       my $r = test_repository(@init);
       $r->run(
      +    ( Git::Repository->version_ge('2.38.1') ? ('-c', 'protocol.file.allow=always') : ()),
           submodule => add => $s->work_tree => 'sub',
           { env => { GIT_WORK_TREE => undef } }
       );
    name: 22.patch
    opt: null
  - content: |
      Description: Add workaround for Git v2.30.0
       which emits hints about a future change of the default branch name,
       which cause the tests for no warnings to fail.
      Origin: vendor
      Bug: https://rt.cpan.org/Public/Bug/Display.html?id=133951
      Bug-Debian: https://bugs.debian.org/978325
      Forwarded: https://rt.cpan.org/Public/Bug/Display.html?id=133951
      Author: gregor herrmann <gregoa@debian.org>
      Last-Update: 2021-01-01

      --- a/t/24-errors.t
      +++ b/t/24-errors.t
      @@ -57,7 +57,7 @@
       my @tests = (
       
           # empty repository
      -    {   test_repo => [],
      +    {   test_repo => [ init => [ qw/--initial-branch master/ ] ],
               cmd       => [qw( log -1 )],
               exit      => 128,
               dollar_at => qr/^fatal: (?:bad default revision 'HEAD' |your current branch 'master' does not have any commits yet)/,
      @@ -142,7 +142,7 @@
       
           # setup a repo with some 'fatal' options
           # and override them in the call to run()
      -    {   test_repo => [ git    => { fatal      => [ 1 .. 255 ] } ],
      +    {   test_repo => [ git    => { fatal      => [ 1 .. 255 ] }, init => [ qw/--initial-branch master/ ] ],
               cmd       => [ exit => 125, { git => $exit } ],
               exit      => 125,
               dollar_at => qr/^fatal: unknown git error/,
      @@ -157,7 +157,7 @@
       push @tests, (
       
           # FATALITY
      -    {   test_repo => [ git => { fatal => [ 0 .. 255 ] } ],
      +    {   test_repo => [ git => { fatal => [ 0 .. 255 ] }, init => [ qw/--initial-branch master/ ] ],
               cmd       => ['version'],
               exit      => 0,
               dollar_at => qr/^fatal: unknown git error/,
      @@ -172,12 +172,12 @@
       push @tests, (
       
           # "!0" is a shortcut for 1..255
      -    {   test_repo => [],
      +    {   test_repo => [ init => [ qw/--initial-branch master/ ] ],
               cmd       => [ exit => 140, { git => $exit, fatal => '!0' } ],
               exit      => 140,
               dollar_at => qr/^fatal: unknown git error/,
           },
      -    {   test_repo => [ git => { fatal => '!0' } ],
      +    {   test_repo => [ git => { fatal => '!0' }, init => [ qw/--initial-branch master/ ] ],
               cmd       => [ exit => 141, { git => $exit } ],
               exit      => 141,
               dollar_at => qr/^fatal: unknown git error/,
    name: git-2.30.0.patch
    opt: null
perl-Gtk2-Notify:
  '0.05':
  - content: |
      Index: xs/Notify.xs
      ===================================================================
      --- xs/Notify.xs.orig	2007-10-04 14:11:13.000000000 +0200
      +++ xs/Notify.xs	2011-10-25 11:49:22.078896599 +0200
      @@ -22,7 +22,6 @@
                   $summary,
                   $message,
                   $icon,
      -            $attach_widget
           );
           $notification->show;
       
      @@ -86,26 +85,12 @@
       MODULE = Gtk2::Notify	PACKAGE = Gtk2::Notify	PREFIX = notify_notification_
       
       NotifyNotification *
      -notify_notification_new (class, summary, body=NULL, icon=NULL, attach=NULL)
      +notify_notification_new (class, summary, body=NULL, icon=NULL)
       		const gchar *summary
       		const gchar *body
       		const gchar *icon
      -		GtkWidget_ornull *attach
       	C_ARGS:
      -		summary, body, icon, attach
      -
      -#if GTK_CHECK_VERSION (2, 9, 2)
      -
      -NotifyNotification *
      -notify_notification_new_with_status_icon (class, summary, body=NULL, icon=NULL, status_icon=NULL)
      -		const gchar *summary
      -		const gchar *body
      -		const gchar *icon
      -		GtkStatusIcon *status_icon
      -	C_ARGS:
      -		summary, body, icon, status_icon
      -
      -#endif
      +		summary, body, icon
       
       gboolean
       notify_notification_update (notification, summary, message=NULL, icon=NULL)
      @@ -114,27 +99,6 @@
       		const gchar *message
       		const gchar *icon
       
      -void
      -notify_notification_attach_to_widget (notification, attach)
      -		NotifyNotification *notification
      -		GtkWidget *attach
      -
      -#if GTK_CHECK_VERSION (2, 9, 2)
      -
      -void
      -notify_notification_attach_to_status_icon (notification, status_icon)
      -		NotifyNotification *notification
      -		GtkStatusIcon *status_icon
      -
      -#endif
      -
      -void
      -notify_notification_set_geometry_hints (notification, screen, x, y)
      -		NotifyNotification *notification
      -		GdkScreen *screen
      -		gint x
      -		gint y
      -
       NO_OUTPUT gboolean
       notify_notification_show (notification)
       		NotifyNotification *notification
      @@ -168,6 +132,11 @@
       		GdkPixbuf *icon
       
       void
      +notify_notification_set_image_from_pixbuf (notification, image)
      +		NotifyNotification *notification
      +		GdkPixbuf *image
      +
      +void
       set_hint (notification, key, value)
       		NotifyNotification *notification
       		const gchar *key
      Index: t/notification.t
      ===================================================================
      --- t/notification.t.orig	2006-08-27 21:11:57.000000000 +0200
      +++ t/notification.t	2011-10-25 11:45:21.000000000 +0200
      @@ -2,20 +2,18 @@
       
       use strict;
       use warnings;
      -use Gtk2::TestHelper tests => 35;
      +use Gtk2::TestHelper tests => 32;
       use Test::Exception;
       use Gtk2::Notify -init, $0;
       
       ginterfaces_ok('Gtk2::Notify');
       
      -my $w = Gtk2::Window->new;
      -my $n = Gtk2::Notify->new('foo', 'bar', '', $w);
      +my $n = Gtk2::Notify->new('foo', 'bar', '');
       
       isa_ok($n, 'Gtk2::Notify');
       
       my @methods = qw(
               add_action
      -        attach_to_widget
               clear_actions
               clear_hints
               close
      @@ -46,16 +44,6 @@
               }, 42);
       }, 'add_action');
       
      -{
      -    my $nw = Gtk2::Window->new;
      -    lives_ok(sub {
      -            $n->attach_to_widget($nw);
      -    }, 'attach_to_widget');
      -    lives_ok(sub {
      -            $n->attach_to_widget($w);
      -    }, 'attach_to_widget');
      -}
      -
       lives_ok(sub {
               $n->clear_actions;
       }, 'clear_actions with existing actions');
      @@ -99,8 +87,6 @@
               $n->close;
       }, 'close before show');
       
      -$w->show_all;
      -
       lives_ok(sub {
               $n->show;
       }, 'show');
    name: Gtk2-Notify-libnotify-0.7.patch
    opt: -p0
perl-HTML-TableExtract:
  '2.15':
  - content: |
      Index: HTML-TableExtract-2.15/lib/HTML/TableExtract.pm
      ===================================================================
      --- HTML-TableExtract-2.15.orig/lib/HTML/TableExtract.pm
      +++ HTML-TableExtract-2.15/lib/HTML/TableExtract.pm
      @@ -438,7 +438,7 @@ sub _reset_state {
         $self->{_counts}        = [];
         $self->{_in_a_table}    = 0;
         $self->{_parsing}       = 0;
      -  $self->tree->delete_content() if TREE();
      +  #$self->tree->delete_content() if TREE();
       }
       
       sub _emsg {
    name: perl-HTML-TableExtract-test-30_tree.patch
    opt: -p1
perl-HTML-TreeBuilder-LibXML:
  '0.26':
  - content: |
      From d74d1f186b2e2c6334a78b895b0ea811a16617a4 Mon Sep 17 00:00:00 2001
      From: Emmanuel Seyman <emmanuel@seyman.fr>
      Date: Mon, 14 Jun 2021 21:12:07 +0200
      Subject: [PATCH] fallback to toString() when toStringC14N(1) gives an empty
       string

      ---
       lib/HTML/TreeBuilder/LibXML/Node.pm | 3 ++-
       1 file changed, 2 insertions(+), 1 deletion(-)

      diff --git a/lib/HTML/TreeBuilder/LibXML/Node.pm b/lib/HTML/TreeBuilder/LibXML/Node.pm
      index f3b4e81..b710dda 100644
      --- a/lib/HTML/TreeBuilder/LibXML/Node.pm
      +++ b/lib/HTML/TreeBuilder/LibXML/Node.pm
      @@ -74,7 +74,8 @@ sub as_HTML {
           {
               local $@; # protect existing $@
               my $output = eval { $_[0]->{node}->toStringC14N(1) };
      -        return $@ ? $_[0]->{node}->toString : $output;
      +        return $_[0]->{node}->toString if ($@ or $output eq '');
      +        return $output;
           }
       }
       
    name: fix-05_empty.patch
    opt: -p1 PATCH-FIX-UPSTREAM fix 05_empty.t https://github.com/tokuhirom/HTML-TreeBuilder-LibXML/pull/17
perl-HTML-TreeBuilder-XPath:
  '0.14':
  - content: |
      All this does is to avoid a match in perl.prov

      Index: HTML-TreeBuilder-XPath-0.14/lib/HTML/TreeBuilder/XPath.pm
      ===================================================================
      --- HTML-TreeBuilder-XPath-0.14.orig/lib/HTML/TreeBuilder/XPath.pm
      +++ HTML-TreeBuilder-XPath-0.14/lib/HTML/TreeBuilder/XPath.pm
      @@ -94,7 +94,8 @@ sub cmp
       
       # need to modify directly the HTML::Element package, because HTML::TreeBuilder won't let me
       # change the class of the nodes it generates
      -package HTML::Element;
      +package
      + HTML::Element;
       use Scalar::Util qw(weaken);
       use vars qw(@ISA);
       
    name: HTML-TreeBuilder-XPath-break.diff
    opt: -p1
perl-IO-Socket-SSL:
  2.85.0:
  - content: |+
      Index: IO-Socket-SSL-2.074/lib/IO/Socket/SSL.pm
      ===================================================================
      --- IO-Socket-SSL-2.074.orig/lib/IO/Socket/SSL.pm
      +++ IO-Socket-SSL-2.074/lib/IO/Socket/SSL.pm
      @@ -205,8 +205,10 @@ my %DEFAULT_SSL_ARGS = (
           SSL_npn_protocols => undef,    # meaning depends whether on server or client side
           SSL_alpn_protocols => undef,   # list of protocols we'll accept/send, for example ['http/1.1','spdy/3.1']
       
      -    # rely on system default but be sure to disable some definitely bad ones
      -    SSL_cipher_list => 'DEFAULT !EXP !MEDIUM !LOW !eNULL !aNULL !RC4 !DES !MD5 !PSK !SRP',
      +    # Use system-wide default cipher list to support use of system-wide
      +    # crypto policy (#1076390, #1127577, CPAN RT#97816)
      +    # https://fedoraproject.org/wiki/Changes/CryptoPolicy
      +    SSL_cipher_list => 'PROFILE=SYSTEM',
       );
       
       my %DEFAULT_SSL_CLIENT_ARGS = (
      Index: IO-Socket-SSL-2.074/lib/IO/Socket/SSL.pod
      ===================================================================
      --- IO-Socket-SSL-2.074.orig/lib/IO/Socket/SSL.pod
      +++ IO-Socket-SSL-2.074/lib/IO/Socket/SSL.pod
      @@ -1070,9 +1070,8 @@ ciphers for TLS 1.2 and lower. See the O
       for more details.
       
       Unless you fail to contact your peer because of no shared ciphers it is
      -recommended to leave this option at the default setting, which uses the system
      -default but disables some insecure ciphers which might still be enabled on older
      -systems.
      +recommended to leave this option at the default setting, which honors the
      +system-wide PROFILE=SYSTEM cipher list.
       
       In case different cipher lists are needed for different SNI hosts a hash can be
       given with the host as key and the cipher suite as value, similar to

    name: perl-IO-Socket-SSL-use-system-default-cipher-list.patch
    opt: -p1 PATCH-FIX-UPSTREAM (bsc1200295) perl-IO-Socket-SSL doesn't follow system "PROFILE=SYSTEM" openSSL ciphers - https://git.centos.org/rpms/perl-IO-Socket-SSL/blob/e0b0ae04f5cdb41b1f29cb7d76c23abba7ac35e9/f/SOURCES/IO-Socket-SSL-2.066-use-system-default-cipher-list.patch
perl-IOC:
  '0.29':
  - content: |
      --- IOC-0.29.orig/lib/IOC/Service/ConstructorInjection.pm	2007-04-23 01:51:12.000000000 +0200
      +++ IOC-0.29/lib/IOC/Service/ConstructorInjection.pm	2020-02-21 18:44:10.935524139 +0100
      @@ -46,7 +46,7 @@
                           # and then to be sure, lets look for  
                           # either the VERSION or the ISA variables
                           (defined ${"${component_class}::VERSION"} 
      -                        || defined @{"${component_class}::ISA"})) ? 1 : 0;
      +                        || @{"${component_class}::ISA"})) ? 1 : 0;
                   } || eval "use $component_class";
                   # throw our exception if the class fails to load
                   throw IOC::ClassLoadingError "The class '$component_class' could not be loaded" => $@ if $@;
    name: defined-array-ConstructorInjection.patch
    opt: -p1
  - content: |
      --- IOC-0.29.orig/lib/IOC/Service/SetterInjection.pm	2007-04-23 01:51:12.000000000 +0200
      +++ IOC-0.29/lib/IOC/Service/SetterInjection.pm	2020-02-21 18:44:25.703631360 +0100
      @@ -43,7 +43,7 @@
                           # and then to be sure, lets look for  
                           # either the VERSION or the ISA variables
                           (defined ${"${component_class}::VERSION"} 
      -                        || defined @{"${component_class}::ISA"})) ? 1 : 0;
      +                        || @{"${component_class}::ISA"})) ? 1 : 0;
                   } || eval "use $component_class";
                   # throw our exception if the class fails to load
                   throw IOC::ClassLoadingError "The class '$component_class' could not be loaded" => $@ if $@;
    name: defined-array-SetterInjection.patch
    opt: -p1
perl-Image-Imlib2:
  '2.03':
  - content: |+
      From 319db4d47493f7ef3909efc1b3904c134c90af5e Mon Sep 17 00:00:00 2001
      From: Sergei Zhmylev <zhmylove@cpan.org>
      Date: Mon, 11 Sep 2023 21:29:17 +0300
      Subject: [PATCH] Make Build.PL compatible with Imlib2 v1.7.5+

      ---
       Build.PL | 8 ++++++--
       1 file changed, 6 insertions(+), 2 deletions(-)

      diff --git a/Build.PL b/Build.PL
      index ab7cd99..de642e1 100644
      --- a/Build.PL
      +++ b/Build.PL
      @@ -1,10 +1,14 @@
       use Module::Build;
       use strict;
       
      -# We need to find imlib2-config
      -my $CONFIG = "imlib2-config";
      +my $CONFIG = "pkg-config imlib2";
       
       my $version = `$CONFIG --version`;
      +if (!$version) {
      +  # Try deprecated imlib2-config
      +  $CONFIG = "imlib2-config";
      +  $version = `$CONFIG --version`;
      +}
       if (!$version) {
         warn 'You must install the imlib2 library before you can install
       Image::Imlib2. You can obtain imlib2 from
      -- 
      2.40.0

    name: 0001-Make-Build.PL-compatible-with-Imlib2-v1.7.5.patch
    opt: -p1 PATCH-FIX-USPTREAM https://rt.cpan.org/Public/Bug/Display.html?id=149742
  - content: |
      Adds additional error checking with useful errors when image loads fail in IMLIB

      Index: libimage-imlib2-perl/lib/Image/Imlib2.xs
      ===================================================================
      --- libimage-imlib2-perl.orig/lib/Image/Imlib2.xs	2011-10-15 17:19:35.000000000 -0700
      +++ libimage-imlib2-perl/lib/Image/Imlib2.xs	2011-10-15 17:19:52.000000000 -0700
      @@ -181,6 +181,46 @@
                       if (err == IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT) {
                         Perl_croak(aTHX_ "Image::Imlib2 load error: No loader for file format");
                       }
      +
      +                if (err == IMLIB_LOAD_ERROR_PATH_TOO_LONG) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Path too long");
      +                }
      +		
      +                if (err == IMLIB_LOAD_ERROR_PATH_COMPONENT_NON_EXISTANT) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Path component non existant");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_PATH_COMPONENT_NOT_DIRECTORY) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Path component not directory");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_PATH_POINTS_OUTSIDE_ADDRESS_SPACE) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Path points outside address space");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_TOO_MANY_SYMBOLIC_LINKS) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Too many symbolic links");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_OUT_OF_MEMORY) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Out of memory");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_OUT_OF_FILE_DESCRIPTORS) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Out of file descriptors");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_WRITE) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Permission denied to write");
      +                }
      +
      +                if (err == IMLIB_LOAD_ERROR_OUT_OF_DISK_SPACE) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Out of disk space");
      +                }
      +
      +		if (err == IMLIB_LOAD_ERROR_UNKNOWN) {
      +                  Perl_croak(aTHX_ "Image::Imlib2 load error: Unknown");
      +		}
       		RETVAL = image;
       	}
               OUTPUT:
    name: Image-Imlib2-2.03.diff
    opt: -p1 PATCH-FIX-USPTREAM add error checks
perl-Image-Sane:
  '5':
  - content: |+
      From bfa253f8e185509cd4b63509a58a415b6abc929d Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Wed, 21 Jun 2023 15:54:40 +0200
      Subject: [PATCH] Replace deprecated given and when operators
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Perl 5.37.11 depracated "given" and "when" keywords and scheduled
      them, together with a smart match operator, for removal in Perl 5.42.

      This lead to t/81_scanimage-perl.t failures:

          #   Failed test '--device=test --test 2>&1'
          #   at t/81_scanimage-perl.t line 42.
          #          got: 'scanimage: scanning image of size 157x196 pixels at 8 bits/pixel
          # scanimage: acquiring gray frame, 8 bits/sample
          # scanimage: reading one scanline, 157 bytes... PASS
          # scanimage: reading one byte...                PASS
          <...>
          # '
          #     expected: 'given is deprecated at examples/scanimage line 125.
          # when is deprecated at examples/scanimage line 126.
          # when is deprecated at examples/scanimage line 129.
          <...>

      This patch rewrites the code not to use "given" and "when".

      CPAN RT#148487

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      ---
       examples/scanadf-perl   | 238 +++++++++++------------
       examples/scanimage-perl | 406 +++++++++++++++++++---------------------
       2 files changed, 308 insertions(+), 336 deletions(-)

      diff --git a/examples/scanadf-perl b/examples/scanadf-perl
      index 150aba2..555faac 100644
      --- a/examples/scanadf-perl
      +++ b/examples/scanadf-perl
      @@ -2,8 +2,6 @@
       
       use warnings;
       use strict;
      -use feature 'switch';
      -no if $] >= 5.018, warnings => 'experimental::smartmatch';
       use Sane;
       use Data::Dumper;
       use Getopt::Long qw(:config no_ignore_case pass_through);
      @@ -126,25 +124,23 @@ sub sighandler {
       sub print_unit {
           my ($unit) = @_;
       
      -    given ($unit) {
      -        when (SANE_UNIT_PIXEL) {
      -            printstdout('pel');
      -        }
      -        when (SANE_UNIT_BIT) {
      -            printstdout('bit');
      -        }
      -        when (SANE_UNIT_MM) {
      -            printstdout('mm');
      -        }
      -        when (SANE_UNIT_DPI) {
      -            printstdout('dpi');
      -        }
      -        when (SANE_UNIT_PERCENT) {
      -            printstdout(q{%});
      -        }
      -        when (SANE_UNIT_MICROSECOND) {
      -            printstdout('us');
      -        }
      +    if ( $unit == SANE_UNIT_PIXEL) {
      +        printstdout('pel');
      +    }
      +    elsif ( $unit == SANE_UNIT_BIT ) {
      +        printstdout('bit');
      +    }
      +    elsif ( $unit == SANE_UNIT_MM ) {
      +        printstdout('mm');
      +    }
      +    elsif ( $unit == SANE_UNIT_DPI ) {
      +        printstdout('dpi');
      +    }
      +    elsif ( $unit == SANE_UNIT_PERCENT ) {
      +        printstdout(q{%});
      +    }
      +    elsif ( $unit == SANE_UNIT_MICROSECOND) {
      +        printstdout('us');
           }
           return;
       }
      @@ -283,28 +279,26 @@ sub print_current_option_value {
                   {
                       my $string_format = '%g';
                       if ( $opt->{type} == SANE_TYPE_INT ) { $string_format = '%d' }
      -                given ( $opt->{name} ) {
      -                    when (SANE_NAME_SCAN_TL_X) {
      -                        $tl_x = $val;
      -                        printf $string_format, $tl_x;
      -                    }
      -                    when (SANE_NAME_SCAN_TL_Y) {
      -                        $tl_y = $val;
      -                        printf $string_format, $tl_y;
      -                    }
      -                    when (SANE_NAME_SCAN_BR_X) {
      -                        $br_x = $val;
      -                        $w_x  = $br_x - $tl_x;
      -                        printf $string_format, $w_x;
      -                    }
      -                    when (SANE_NAME_SCAN_BR_Y) {
      -                        $br_y = $val;
      -                        $h_y  = $br_y - $tl_y;
      -                        printf $string_format, $h_y;
      -                    }
      -                    default {
      -                        printf $string_format, $val;
      -                    }
      +                if ( $opt->{name} eq SANE_NAME_SCAN_TL_X ) {
      +                    $tl_x = $val;
      +                    printf $string_format, $tl_x;
      +                }
      +                elsif ( $opt->{name} eq SANE_NAME_SCAN_TL_Y ) {
      +                    $tl_y = $val;
      +                    printf $string_format, $tl_y;
      +                }
      +                elsif ( $opt->{name} eq SANE_NAME_SCAN_BR_X ) {
      +                    $br_x = $val;
      +                    $w_x  = $br_x - $tl_x;
      +                    printf $string_format, $w_x;
      +                }
      +                elsif ( $opt->{name} eq SANE_NAME_SCAN_BR_Y) {
      +                    $br_y = $val;
      +                    $h_y  = $br_y - $tl_y;
      +                    printf $string_format, $h_y;
      +                }
      +                else {
      +                    printf $string_format, $val;
                       }
                   }
                   elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      @@ -508,34 +502,32 @@ sub update_geometry {
               and ( $opt->{unit} == SANE_UNIT_MM || $opt->{unit} == SANE_UNIT_PIXEL )
             )
           {
      -        given ( $opt->{name} ) {
      -            when (SANE_NAME_SCAN_TL_X) {
      -                $window[2] = $i;
      -                $opt->{name} = 'l';
      -            }
      -            when (SANE_NAME_SCAN_TL_Y) {
      -                $window[3] = $i;      ## no critic (ProhibitMagicNumbers)
      -                $opt->{name} = 't';
      -            }
      -            when (SANE_NAME_SCAN_BR_X) {
      -                $window[0]                 = $i;
      -                $opt->{name}               = 'x';
      -                $window_option[0]          = $opt;
      -                $window_option[0]->{title} = 'Scan width';
      -                $window_option[0]->{desc}  = 'Width of scanning area.';
      -                if ( !$window_val_user[0] ) {
      -                    $window_val[0] = $device->get_option($i);
      -                }
      +        if ( $opt->{name} eq SANE_NAME_SCAN_TL_X ) {
      +            $window[2] = $i;
      +            $opt->{name} = 'l';
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_TL_Y ) {
      +            $window[3] = $i;      ## no critic (ProhibitMagicNumbers)
      +            $opt->{name} = 't';
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_BR_X ) {
      +            $window[0]                 = $i;
      +            $opt->{name}               = 'x';
      +            $window_option[0]          = $opt;
      +            $window_option[0]->{title} = 'Scan width';
      +            $window_option[0]->{desc}  = 'Width of scanning area.';
      +            if ( !$window_val_user[0] ) {
      +                $window_val[0] = $device->get_option($i);
                   }
      -            when (SANE_NAME_SCAN_BR_Y) {
      -                $window[1]                 = $i;
      -                $opt->{name}               = 'y';
      -                $window_option[1]          = $opt;
      -                $window_option[1]->{title} = 'Scan height';
      -                $window_option[1]->{desc}  = 'Height of scanning area.';
      -                if ( !$window_val_user[1] ) {
      -                    $window_val[1] = $device->get_option($i);
      -                }
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_BR_Y ) {
      +            $window[1]                 = $i;
      +            $opt->{name}               = 'y';
      +            $window_option[1]          = $opt;
      +            $window_option[1]->{title} = 'Scan height';
      +            $window_option[1]->{desc}  = 'Height of scanning area.';
      +            if ( !$window_val_user[1] ) {
      +                $window_val[1] = $device->get_option($i);
                   }
               }
           }
      @@ -604,40 +596,38 @@ sub process_backend_option {
           }
       
           my $value;
      -    given ( $opt->{type} ) {
      -        when (SANE_TYPE_BOOL) {
      -            $value = 1;    # no argument means option is set
      -            if ($optarg) {
      -                if ( $optarg =~ /^yes$/ixsm ) {
      -                    $value = 1;
      -                }
      -                elsif ( $optarg =~ /^no$/ixsm ) {
      -                    $value = 0;
      -                }
      -                else {
      -                    die
      +    if ( $opt->{type} == SANE_TYPE_BOOL ) {
      +        $value = 1;    # no argument means option is set
      +        if ($optarg) {
      +            if ( $optarg =~ /^yes$/ixsm ) {
      +                $value = 1;
      +            }
      +            elsif ( $optarg =~ /^no$/ixsm ) {
      +                $value = 0;
      +            }
      +            else {
      +                die
       "$prog_name: option --$opt->{name}: bad option value `$optarg'\n";
      -                }
                   }
               }
      -        when (
      -                 $opt->{type} == SANE_TYPE_INT
      -              or $opt->{type} == SANE_TYPE_FIXED
      -          )
      -        {
      -            my @vector = parse_vector( $opt, $optarg );
      -            $value = \@vector;
      -        }
      -        when (SANE_TYPE_STRING) {
      -            $value = $optarg;
      -        }
      -        when (SANE_TYPE_BUTTON) {
      -            $value = 0;    # value doesn't matter
      -        }
      -        default {
      -            warn "$prog_name: duh, got unknown option type $opt->{type}\n";
      -            return;
      -        }
      +    }
      +    elsif (
      +             $opt->{type} == SANE_TYPE_INT
      +          or $opt->{type} == SANE_TYPE_FIXED
      +      )
      +    {
      +        my @vector = parse_vector( $opt, $optarg );
      +        $value = \@vector;
      +    }
      +    elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      +        $value = $optarg;
      +    }
      +    elsif ( $opt->{type} == SANE_TYPE_BUTTON ) {
      +        $value = 0;    # value doesn't matter
      +    }
      +    else {
      +        warn "$prog_name: duh, got unknown option type $opt->{type}\n";
      +        return;
           }
           set_option( $device, $optnum, $value );
           return;
      @@ -1050,30 +1040,28 @@ sub process_arguments {
                   next;
               }
               if ( defined $options{$ch} ) {
      -            given ($ch) {
      -                when ('x') {
      -                    $window_val_user[0] = 1;
      -                    ( $window_val[0] ) =
      -                      parse_vector( $window_option[0], $options{x} );
      -                }
      -                when ('y') {
      -                    $window_val_user[1] = 1;
      -                    ( $window_val[1] ) =
      -                      parse_vector( $window_option[1], $options{y} );
      -                }
      -                when ('l') {    # tl-x
      -                    process_backend_option( $device, $window[2], $options{l} );
      -                }
      -                when ('t') {    # tl-y
      -                    process_backend_option(
      -                        $device, $window[3], ## no critic (ProhibitMagicNumbers)
      -                        $options{t}
      -                    );
      -                }
      -                default {
      -                    process_backend_option( $device, $option_number{$ch},
      -                        $options{$ch} );
      -                }
      +            if ( $ch eq 'x' ) {
      +                $window_val_user[0] = 1;
      +                ( $window_val[0] ) =
      +                  parse_vector( $window_option[0], $options{x} );
      +            }
      +            elsif ( $ch eq 'y' ) {
      +                $window_val_user[1] = 1;
      +                ( $window_val[1] ) =
      +                  parse_vector( $window_option[1], $options{y} );
      +            }
      +            elsif ( $ch eq 'l' ) {    # tl-x
      +                process_backend_option( $device, $window[2], $options{l} );
      +            }
      +            elsif ( $ch eq 't' ) {    # tl-y
      +                process_backend_option(
      +                    $device, $window[3], ## no critic (ProhibitMagicNumbers)
      +                    $options{t}
      +                );
      +            }
      +            else {
      +                process_backend_option( $device, $option_number{$ch},
      +                    $options{$ch} );
                   }
               }
           }
      diff --git a/examples/scanimage-perl b/examples/scanimage-perl
      index 0579a4a..ff6999f 100644
      --- a/examples/scanimage-perl
      +++ b/examples/scanimage-perl
      @@ -2,14 +2,12 @@
       
       use warnings;
       use strict;
      -use feature 'switch';
       use Image::Sane ':all';
       use Try::Tiny;
       use Getopt::Long qw(:config no_ignore_case pass_through);
       use File::Basename;
       use IO::Handle;
       use English qw( -no_match_vars );    # for $PROGRAM_NAME
      -no if $] >= 5.018, warnings => 'experimental::smartmatch';
       use sigtrap qw/handler sighandler normal-signals/;
       use Readonly;
       Readonly my $BUFFER_SIZE   => ( 32 * 1024 );     # default size
      @@ -122,25 +120,23 @@ sub sighandler {
       sub print_unit {
           my ($unit) = @_;
       
      -    given ($unit) {
      -        when (SANE_UNIT_PIXEL) {
      -            printstdout('pel');
      -        }
      -        when (SANE_UNIT_BIT) {
      -            printstdout('bit');
      -        }
      -        when (SANE_UNIT_MM) {
      -            printstdout('mm');
      -        }
      -        when (SANE_UNIT_DPI) {
      -            printstdout('dpi');
      -        }
      -        when (SANE_UNIT_PERCENT) {
      -            printstdout(q{%});
      -        }
      -        when (SANE_UNIT_MICROSECOND) {
      -            printstdout('us');
      -        }
      +    if ($unit == SANE_UNIT_PIXEL) {
      +        printstdout('pel');
      +    }
      +    elsif ($unit == SANE_UNIT_BIT) {
      +        printstdout('bit');
      +    }
      +    elsif ($unit == SANE_UNIT_MM) {
      +        printstdout('mm');
      +    }
      +    elsif ($unit == SANE_UNIT_DPI) {
      +        printstdout('dpi');
      +    }
      +    elsif ($unit == SANE_UNIT_PERCENT) {
      +        printstdout(q{%});
      +    }
      +    elsif ($unit == SANE_UNIT_MICROSECOND) {
      +        printstdout('us');
           }
           return;
       }
      @@ -243,69 +239,67 @@ sub print_option {
       
       sub print_option_choices {
           my ($opt) = @_;
      -    given ( $opt->{type} ) {
      -        when (SANE_TYPE_BOOL) {
      -            printstdout('[=(');
      -            if ( $opt->{cap} & SANE_CAP_AUTOMATIC ) { printstdout('auto|') }
      -            printstdout('yes|no)]');
      -        }
      -        when (SANE_TYPE_BUTTON) { }
      -        default {
      -            printstdout($SPACE);
      -            if ( $opt->{cap} & SANE_CAP_AUTOMATIC ) {
      -                printstdout('auto|');
      +    if ( $opt->{type} == SANE_TYPE_BOOL ) {
      +        printstdout('[=(');
      +        if ( $opt->{cap} & SANE_CAP_AUTOMATIC ) { printstdout('auto|') }
      +        printstdout('yes|no)]');
      +    }
      +    elsif ( $opt->{type} == SANE_TYPE_BUTTON ) {
      +    }
      +    else {
      +        printstdout($SPACE);
      +        if ( $opt->{cap} & SANE_CAP_AUTOMATIC ) {
      +            printstdout('auto|');
      +        }
      +        if ( $opt->{constraint_type} == SANE_CONSTRAINT_NONE ) {
      +            if ( $opt->{type} == SANE_TYPE_INT ) {
      +                printstdout('<int>');
                   }
      -            given ( $opt->{constraint_type} ) {
      -                when (SANE_CONSTRAINT_NONE) {
      -                    if ( $opt->{type} == SANE_TYPE_INT ) {
      -                        printstdout('<int>');
      -                    }
      -                    elsif ( $opt->{type} == SANE_TYPE_FIXED ) {
      -                        printstdout('<float>');
      -                    }
      -                    elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      -                        printstdout('<string>');
      -                    }
      -                    if ( $opt->{max_values} > 1 ) { printstdout(',...') }
      -                }
      -                when (SANE_CONSTRAINT_RANGE) {
      -                    my $string_format = '%g..%g';
      -                    if ( $opt->{type} == SANE_TYPE_INT ) {
      -                        $string_format = '%d..%d';
      -                    }
      -                    if ( $opt->{name} eq 'x' ) {
      -                        printf $string_format, $opt->{constraint}{min},
      -                          $opt->{constraint}{max} - $tl_x;
      -                    }
      -                    elsif ( $opt->{name} eq 'y' ) {
      -                        printf $string_format, $opt->{constraint}{min},
      -                          $opt->{constraint}{max} - $tl_y;
      -                    }
      -                    else {
      -                        printf $string_format, $opt->{constraint}{min},
      -                          $opt->{constraint}{max};
      -                    }
      -                    print_unit( $opt->{unit} );
      -                    if ( $opt->{max_values} > 1 ) { printstdout(',...') }
      -                    if ( $opt->{constraint}{quant} ) {
      -                        printstdout(" (in steps of $opt->{constraint}{quant})");
      -                    }
      -                }
      -                when ( SANE_CONSTRAINT_STRING_LIST | SANE_CONSTRAINT_WORD_LIST )
      -                {
      -                    for my $i ( 0 .. $#{ $opt->{constraint} } ) {
      -                        if ( $i > 0 ) { printstdout(q{|}) }
      -                        my $string_format =
      -                          $opt->{type} == SANE_TYPE_FIXED ? '%g' : '%s';
      +            elsif ( $opt->{type} == SANE_TYPE_FIXED ) {
      +                printstdout('<float>');
      +            }
      +            elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      +                printstdout('<string>');
      +            }
      +            if ( $opt->{max_values} > 1 ) { printstdout(',...') }
      +        }
      +        elsif ( $opt->{constraint_type} == SANE_CONSTRAINT_RANGE ) {
      +            my $string_format = '%g..%g';
      +            if ( $opt->{type} == SANE_TYPE_INT ) {
      +                $string_format = '%d..%d';
      +            }
      +            if ( $opt->{name} eq 'x' ) {
      +                printf $string_format, $opt->{constraint}{min},
      +                  $opt->{constraint}{max} - $tl_x;
      +            }
      +            elsif ( $opt->{name} eq 'y' ) {
      +                printf $string_format, $opt->{constraint}{min},
      +                  $opt->{constraint}{max} - $tl_y;
      +            }
      +            else {
      +                printf $string_format, $opt->{constraint}{min},
      +                  $opt->{constraint}{max};
      +            }
      +            print_unit( $opt->{unit} );
      +            if ( $opt->{max_values} > 1 ) { printstdout(',...') }
      +            if ( $opt->{constraint}{quant} ) {
      +                printstdout(" (in steps of $opt->{constraint}{quant})");
      +            }
      +        }
      +        elsif ( $opt->{constraint_type} == SANE_CONSTRAINT_STRING_LIST ||
      +                $opt->{constraint_type} == SANE_CONSTRAINT_WORD_LIST )
      +        {
      +            for my $i ( 0 .. $#{ $opt->{constraint} } ) {
      +                if ( $i > 0 ) { printstdout(q{|}) }
      +                my $string_format =
      +                  $opt->{type} == SANE_TYPE_FIXED ? '%g' : '%s';
       
      -                        printf $string_format, $opt->{constraint}[$i];
      -                    }
      -                    if ( $opt->{constraint_type} == SANE_CONSTRAINT_WORD_LIST )
      -                    {
      -                        print_unit( $opt->{unit} );
      -                        if ( $opt->{max_values} > 1 ) { printstdout(',...') }
      -                    }
      -                }
      +                printf $string_format, $opt->{constraint}[$i];
      +            }
      +            if ( $opt->{constraint_type} == SANE_CONSTRAINT_WORD_LIST )
      +            {
      +                print_unit( $opt->{unit} );
      +                if ( $opt->{max_values} > 1 ) { printstdout(',...') }
                   }
               }
           }
      @@ -326,26 +320,24 @@ sub print_current_option_value {
                   {
                       my $string_format = '%g';
                       if ( $opt->{type} == SANE_TYPE_INT ) { $string_format = '%d' }
      -                given ( $opt->{name} ) {
      -                    when ('l') {
      -                        $tl_x = $val;
      -                        printf $string_format, $tl_x;
      -                    }
      -                    when ('t') {
      -                        $tl_y = $val;
      -                        printf $string_format, $tl_y;
      -                    }
      -                    when ('x') {
      -                        $br_x = $val;
      -                        printf $string_format, $br_x - $tl_x;
      -                    }
      -                    when ('y') {
      -                        $br_y = $val;
      -                        printf $string_format, $br_y - $tl_y;
      -                    }
      -                    default {
      -                        printf $string_format, $val;
      -                    }
      +                if ( $opt->{name} eq 'l' ) {
      +                    $tl_x = $val;
      +                    printf $string_format, $tl_x;
      +                }
      +                elsif ( $opt->{name} eq 't' ) {
      +                    $tl_y = $val;
      +                    printf $string_format, $tl_y;
      +                }
      +                elsif ( $opt->{name} eq 'x' ) {
      +                    $br_x = $val;
      +                    printf $string_format, $br_x - $tl_x;
      +                }
      +                elsif ( $opt->{name} eq 'y' ) {
      +                    $br_y = $val;
      +                    printf $string_format, $br_y - $tl_y;
      +                }
      +                else {
      +                    printf $string_format, $val;
                       }
                   }
                   elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      @@ -562,33 +554,31 @@ sub update_geometry {
               and ( $opt->{unit} == SANE_UNIT_MM or $opt->{unit} == SANE_UNIT_PIXEL )
             )
           {
      -        given ( $opt->{name} ) {
      -            when (SANE_NAME_SCAN_BR_X) {
      -                $window[0]                 = $i;
      -                $opt->{name}               = 'x';
      -                $window_option[0]          = $opt;
      -                $window_option[0]->{title} = 'Scan width';
      -                $window_option[0]->{desc}  = 'Width of scan-area.';
      -                $window_option[0]->{name}  = 'x';
      -            }
      -            when (SANE_NAME_SCAN_BR_Y) {
      -                $window[1]                 = $i;
      -                $opt->{name}               = 'y';
      -                $window_option[1]          = $opt;
      -                $window_option[1]->{title} = 'Scan height';
      -                $window_option[1]->{desc}  = 'Height of scan-area.';
      -                $window_option[1]->{name}  = 'y';
      -            }
      -            when (SANE_NAME_SCAN_TL_X) {
      -                $window[2]                = $i;
      -                $window_option[2]         = $opt;
      -                $window_option[2]->{name} = 'l';
      -            }
      -            when (SANE_NAME_SCAN_TL_Y) {
      -                $window[$I_TL_Y]                = $i;
      -                $window_option[$I_TL_Y]         = $opt;
      -                $window_option[$I_TL_Y]->{name} = 't';
      -            }
      +        if ( $opt->{name} eq SANE_NAME_SCAN_BR_X ) {
      +            $window[0]                 = $i;
      +            $opt->{name}               = 'x';
      +            $window_option[0]          = $opt;
      +            $window_option[0]->{title} = 'Scan width';
      +            $window_option[0]->{desc}  = 'Width of scan-area.';
      +            $window_option[0]->{name}  = 'x';
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_BR_Y ) {
      +            $window[1]                 = $i;
      +            $opt->{name}               = 'y';
      +            $window_option[1]          = $opt;
      +            $window_option[1]->{title} = 'Scan height';
      +            $window_option[1]->{desc}  = 'Height of scan-area.';
      +            $window_option[1]->{name}  = 'y';
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_TL_X ) {
      +            $window[2]                = $i;
      +            $window_option[2]         = $opt;
      +            $window_option[2]->{name} = 'l';
      +        }
      +        elsif ( $opt->{name} eq SANE_NAME_SCAN_TL_Y ) {
      +            $window[$I_TL_Y]                = $i;
      +            $window_option[$I_TL_Y]         = $opt;
      +            $window_option[$I_TL_Y]->{name} = 't';
               }
           }
           return;
      @@ -663,40 +653,38 @@ sub process_backend_option {
           }
       
           my $value;
      -    given ( $opt->{type} ) {
      -        when (SANE_TYPE_BOOL) {
      -            $value = 1;    # no argument means option is set
      -            if ($optarg) {
      -                if ( $optarg =~ /^yes$/xsmi ) {
      -                    $value = 1;
      -                }
      -                elsif ( $optarg =~ /^no$/xsmi ) {
      -                    $value = 0;
      -                }
      -                else {
      -                    die
      +    if ( $opt->{type} == SANE_TYPE_BOOL ) {
      +        $value = 1;    # no argument means option is set
      +        if ($optarg) {
      +            if ( $optarg =~ /^yes$/xsmi ) {
      +                $value = 1;
      +            }
      +            elsif ( $optarg =~ /^no$/xsmi ) {
      +                $value = 0;
      +            }
      +            else {
      +                die
       "$prog_name: option --$opt->{name}: bad option value `$optarg'\n";
      -                }
                   }
               }
      -        when (
      -                 $opt->{type} == SANE_TYPE_INT
      -              or $opt->{type} == SANE_TYPE_FIXED
      -          )
      -        {
      -            my @vector = parse_vector( $opt, $optarg );
      -            $value = \@vector;
      -        }
      -        when (SANE_TYPE_STRING) {
      -            $value = $optarg;
      -        }
      -        when (SANE_TYPE_BUTTON) {
      -            $value = 0;    # value doesn't matter
      -        }
      -        default {
      -            warn "$prog_name: duh, got unknown option type $opt->{type}\n";
      -            return;
      -        }
      +    }
      +    elsif (
      +             $opt->{type} == SANE_TYPE_INT
      +          or $opt->{type} == SANE_TYPE_FIXED
      +      )
      +    {
      +        my @vector = parse_vector( $opt, $optarg );
      +        $value = \@vector;
      +    }
      +    elsif ( $opt->{type} == SANE_TYPE_STRING ) {
      +        $value = $optarg;
      +    }
      +    elsif ( $opt->{type} == SANE_TYPE_BUTTON) {
      +        $value = 0;    # value doesn't matter
      +    }
      +    else {
      +        warn "$prog_name: duh, got unknown option type $opt->{type}\n";
      +        return;
           }
           set_option( $device, $optnum, $value );
           return;
      @@ -1149,29 +1137,19 @@ sub scan_pages {
                   printstderr( sprintf " (scanner status = %d)\n", $status );
               }
       
      -        given ($status) {
      -            when (SANE_STATUS_EOF) {
      -                if ($batch) {
      -
      -                   # close output file by redirecting, do not close stdout here!
      -                    if (
      -                        open $fh, '>',    ## no critic (RequireBriefOpen)
      -                        '/dev/null' and STDOUT->fdopen( $fh, '>' )
      -                      )
      -                    {
      -
      -                        # let the fully scanned file show up
      -                        if ( not rename $part_path, $path ) {
      -                            printstderr("cannot rename $part_path to $path\n");
      -                            try {
      -                                $device->cancel;
      -                            }
      -                            catch {};
      -                            return SANE_STATUS_ACCESS_DENIED;
      -                        }
      -                    }
      -                    else {
      -                        printstderr("cannot open /dev/null\n");
      +        if ( $status == SANE_STATUS_EOF ) {
      +            if ($batch) {
      +
      +               # close output file by redirecting, do not close stdout here!
      +                if (
      +                    open $fh, '>',    ## no critic (RequireBriefOpen)
      +                    '/dev/null' and STDOUT->fdopen( $fh, '>' )
      +                  )
      +                {
      +
      +                    # let the fully scanned file show up
      +                    if ( not rename $part_path, $path ) {
      +                        printstderr("cannot rename $part_path to $path\n");
                               try {
                                   $device->cancel;
                               }
      @@ -1179,15 +1157,23 @@ sub scan_pages {
                               return SANE_STATUS_ACCESS_DENIED;
                           }
                       }
      -            }
      -            when (SANE_STATUS_GOOD) {
      -                if ($batch) {
      -                    close $fh or warn "cannot close file\n";
      -                    unlink $part_path;
      +                else {
      +                    printstderr("cannot open /dev/null\n");
      +                    try {
      +                        $device->cancel;
      +                    }
      +                    catch {};
      +                    return SANE_STATUS_ACCESS_DENIED;
                       }
      -                last;
                   }
               }
      +        elsif ( $status == SANE_STATUS_GOOD ) {
      +            if ($batch) {
      +                close $fh or warn "cannot close file\n";
      +                unlink $part_path;
      +            }
      +            last;
      +        }
               $n += $batch_increment;
       
               if ( not ok_for_next_page() ) { last }
      @@ -1422,28 +1408,26 @@ sub process_arguments {
                   next;
               }
               if ( defined $options{$ch} ) {
      -            given ($ch) {
      -                when ('x') {
      -                    $window_val_user[0] = 1;
      -                    ( $window_val[0] ) =
      -                      parse_vector( $window_option[0], $options{x} );
      -                }
      -                when ('y') {
      -                    $window_val_user[1] = 1;
      -                    ( $window_val[1] ) =
      -                      parse_vector( $window_option[1], $options{y} );
      -                }
      -                when ('l') {    # tl-x
      -                    process_backend_option( $device, $window[2], $options{l} );
      -                }
      -                when ('t') {    # tl-y
      -                    process_backend_option( $device, $window[$I_TL_Y],
      -                        $options{t} );
      -                }
      -                default {
      -                    process_backend_option( $device, $option_number{$ch},
      -                        $options{$ch} );
      -                }
      +            if ( $ch eq 'x' ) {
      +                $window_val_user[0] = 1;
      +                ( $window_val[0] ) =
      +                  parse_vector( $window_option[0], $options{x} );
      +            }
      +            elsif ( $ch eq 'y' ) {
      +                $window_val_user[1] = 1;
      +                ( $window_val[1] ) =
      +                  parse_vector( $window_option[1], $options{y} );
      +            }
      +            elsif ( $ch eq 'l') {    # tl-x
      +                process_backend_option( $device, $window[2], $options{l} );
      +            }
      +            elsif ( $ch eq 't') {    # tl-y
      +                process_backend_option( $device, $window[$I_TL_Y],
      +                    $options{t} );
      +            }
      +            else {
      +                process_backend_option( $device, $option_number{$ch},
      +                    $options{$ch} );
                   }
               }
           }
      -- 
      2.41.0

    name: Image-Sane-5-Replace-deprecated-given-and-when-operators.patch
    opt: -p1
perl-Image-Size:
  '3.300':
  - content: |
      diff -ur Image-Size-3.300/lib/Image/Size.pm Image-Size-3.300_fix/lib/Image/Size.pm
      --- Image-Size-3.300/lib/Image/Size.pm	2015-02-28 18:00:55.000000000 +0100
      +++ Image-Size-3.300_fix/lib/Image/Size.pm	2021-03-01 11:17:29.058012588 +0100
      @@ -604,6 +604,7 @@
           my $stream = shift;
       
           my $MARKER     = chr 0xff; # Section marker
      +    my $MARKER2    = chr 0x00; # some sections also use 0x00
       
           my $SIZE_FIRST = 0xC0;   # Range of segment identifier codes
           my $SIZE_LAST  = 0xC3;   #  that hold size info.
      @@ -630,7 +631,7 @@
               $length = unpack 'n', $segheader;
       
               # Verify that it's a valid segment.
      -        if ($marker ne $MARKER)
      +        if ($marker ne $MARKER && $marker ne $MARKER2)
               {
                   # Was it there?
                   $id = 'JPEG marker not found';
    name: Image-Size-3.300_Fix_JPEG_00_Markers.patch
    opt: -p1 PATCH-FIX-UPSTREAM do not fail on JPEG files with 0x00XX markers
  - content: |
      Index: Image-Size-3.300/lib/Image/Size.pm
      ===================================================================
      --- Image-Size-3.300.orig/lib/Image/Size.pm
      +++ Image-Size-3.300/lib/Image/Size.pm
      @@ -933,7 +933,7 @@ sub webpsize {
           #    - frame meta, 8 bytes
           #    - marker, 3 bytes
           my $buf = $READ_IN->($img, 4, 26);
      -    my ($raw_w, $raw_h) = unpack 'SS', $buf;
      +    my ($raw_w, $raw_h) = unpack '(SS)<', $buf;
           my $b14 = 2**14 - 1;
       
           # The width and height values contain a 2-bit scaling factor,
    name: endian.patch
    opt: -p1
perl-LWP-ConsoleLogger:
  '1.000001':
  - content: |+
      From b32bbf3b01ecaac64c114b772d3b25f6cecb84d4 Mon Sep 17 00:00:00 2001
      From: Frank Schreiner <schreiner@suse.de>
      Date: Tue, 19 Jan 2021 08:15:42 +0100
      Subject: [PATCH] replace env

      ---
       examples/dump-only-headers.pl       | 2 +-
       examples/html-in-text.pl            | 2 +-
       examples/http-tiny-mech.pl          | 2 +-
       examples/log-to-file.pl             | 2 +-
       examples/new-york-times.pl          | 2 +-
       examples/pithub.pl                  | 2 +-
       examples/test-lwp-useragent.pl      | 2 +-
       examples/test-www-mechanize-psgi.pl | 2 +-
       examples/test-www-mechanize.pl      | 2 +-
       9 files changed, 9 insertions(+), 9 deletions(-)

      diff --git a/examples/dump-only-headers.pl b/examples/dump-only-headers.pl
      index 8fc3cff..a85f88e 100755
      --- a/examples/dump-only-headers.pl
      +++ b/examples/dump-only-headers.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/html-in-text.pl b/examples/html-in-text.pl
      index f1a0760..2aa37e4 100755
      --- a/examples/html-in-text.pl
      +++ b/examples/html-in-text.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/http-tiny-mech.pl b/examples/http-tiny-mech.pl
      index 65c9899..d29abd7 100755
      --- a/examples/http-tiny-mech.pl
      +++ b/examples/http-tiny-mech.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/log-to-file.pl b/examples/log-to-file.pl
      index fb2fe69..2b54e93 100755
      --- a/examples/log-to-file.pl
      +++ b/examples/log-to-file.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/new-york-times.pl b/examples/new-york-times.pl
      index 9fb24dc..eb96b48 100755
      --- a/examples/new-york-times.pl
      +++ b/examples/new-york-times.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/pithub.pl b/examples/pithub.pl
      index f9cdbef..8216683 100755
      --- a/examples/pithub.pl
      +++ b/examples/pithub.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       use strict;
       use warnings;
      diff --git a/examples/test-lwp-useragent.pl b/examples/test-lwp-useragent.pl
      index 8e17758..f9af1fc 100644
      --- a/examples/test-lwp-useragent.pl
      +++ b/examples/test-lwp-useragent.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl;
      +#!/usr/bin/perl;
       
       use strict;
       use warnings;
      diff --git a/examples/test-www-mechanize-psgi.pl b/examples/test-www-mechanize-psgi.pl
      index 93871b7..d8a0e13 100755
      --- a/examples/test-www-mechanize-psgi.pl
      +++ b/examples/test-www-mechanize-psgi.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl;
      +#!/usr/bin/perl;
       
       use strict;
       use warnings;
      diff --git a/examples/test-www-mechanize.pl b/examples/test-www-mechanize.pl
      index 9ca0d90..abcb973 100755
      --- a/examples/test-www-mechanize.pl
      +++ b/examples/test-www-mechanize.pl
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl;
      +#!/usr/bin/perl;
       
       use strict;
       use warnings;
      -- 
      2.30.0

    name: 0001-replace-env.patch
    opt: -p1
perl-Mail-SPF:
  3.202.402.60:
  - content: |
      --- Mail-SPF-v2.8.0/t/10.00-rfc4408.t.orig	2012-01-30 09:59:22.000000000 +0100
      +++ Mail-SPF-v2.8.0/t/10.00-rfc4408.t	2012-09-20 18:15:55.702419094 +0200
      @@ -6,6 +6,7 @@ use Test::More;
       
       eval("use Mail::SPF::Test");
       plan(skip_all => "Mail::SPF::Test required for testing Mail::SPF's RFC compliance") if $@;
      +plan(skip_all => "skipped (fails since Net::DNS 0.68, see https://rt.cpan.org/Public/Bug/Display.html?id=78214)");
       
       require('t/Mail-SPF-Test-lib.pm');
       
    name: skip_test.patch
    opt: -p1
perl-Math-Base-Convert:
  '0.11':
  - content: |
      Index: Math-Base-Convert-0.11/bitmaps
      ===================================================================
      --- Math-Base-Convert-0.11/bitmaps
      +++ Math-Base-Convert-0.11/bitmaps
      @@ -116,7 +116,7 @@ use vars qw($VERSION);
       
       $VERSION = '|. $VERSION .q|';
       
      -# created by Makefile.PL |. scalar localtime(). q|
      +# created by Makefile.PL |. scalar gmtime($ENV{SOURCE_DATE_EPOCH} || time). q|
       #
       # Do not edit this package, 
       #
    name: reproducible.patch
    opt: -p1
perl-Math-Prime-Util-GMP:
  '0.52':
  - content: |
      diff -u -r Math-Prime-Util-GMP-0.51_orig/examples/bench-mp-psrp.pl Math-Prime-Util-GMP-0.51/examples/bench-mp-psrp.pl
      --- Math-Prime-Util-GMP-0.51_orig/examples/bench-mp-psrp.pl	2014-06-19 08:11:35.000000000 +0200
      +++ Math-Prime-Util-GMP-0.51/examples/bench-mp-psrp.pl	2019-08-30 20:22:54.742539783 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use strict;
       use warnings;
       use Math::Prime::Util;
      diff -u -r Math-Prime-Util-GMP-0.51_orig/examples/convert-gmpecpp-cert.pl Math-Prime-Util-GMP-0.51/examples/convert-gmpecpp-cert.pl
      --- Math-Prime-Util-GMP-0.51_orig/examples/convert-gmpecpp-cert.pl	2013-11-08 21:28:43.000000000 +0100
      +++ Math-Prime-Util-GMP-0.51/examples/convert-gmpecpp-cert.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use warnings;
       use strict;
       use Math::BigInt try=>"GMP,Pari";
      diff -u -r Math-Prime-Util-GMP-0.51_orig/examples/convert-primo-cert.pl Math-Prime-Util-GMP-0.51/examples/convert-primo-cert.pl
      --- Math-Prime-Util-GMP-0.51_orig/examples/convert-primo-cert.pl	2013-11-08 21:28:43.000000000 +0100
      +++ Math-Prime-Util-GMP-0.51/examples/convert-primo-cert.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use warnings;
       use strict;
       use Math::BigInt try=>"GMP,Pari";
      diff -u -r Math-Prime-Util-GMP-0.51_orig/examples/verify-cert.pl Math-Prime-Util-GMP-0.51/examples/verify-cert.pl
      --- Math-Prime-Util-GMP-0.51_orig/examples/verify-cert.pl	2013-11-08 21:28:43.000000000 +0100
      +++ Math-Prime-Util-GMP-0.51/examples/verify-cert.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use warnings;
       use strict;
       use Math::BigInt lib=>"GMP,Pari";
      diff -u -r Math-Prime-Util-GMP-0.51_orig/xt/bench-random-bytes.pl Math-Prime-Util-GMP-0.51/xt/bench-random-bytes.pl
      --- Math-Prime-Util-GMP-0.51_orig/xt/bench-random-bytes.pl	2017-03-29 23:56:55.000000000 +0200
      +++ Math-Prime-Util-GMP-0.51/xt/bench-random-bytes.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use strict;
       use warnings;
       
      diff -u -r Math-Prime-Util-GMP-0.51_orig/xt/calculate-mr-probs.pl Math-Prime-Util-GMP-0.51/xt/calculate-mr-probs.pl
      --- Math-Prime-Util-GMP-0.51_orig/xt/calculate-mr-probs.pl	2013-11-08 21:28:43.000000000 +0100
      +++ Math-Prime-Util-GMP-0.51/xt/calculate-mr-probs.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use warnings;
       use strict;
       use List::Util qw/min max/;
      diff -u -r Math-Prime-Util-GMP-0.51_orig/xt/llr.pl Math-Prime-Util-GMP-0.51/xt/llr.pl
      --- Math-Prime-Util-GMP-0.51_orig/xt/llr.pl	2016-10-10 05:19:59.000000000 +0200
      +++ Math-Prime-Util-GMP-0.51/xt/llr.pl	2019-08-30 20:22:54.746539811 +0200
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       use warnings;
       use strict;
       use Math::Prime::Util::GMP ":all";
    name: fix-shebang.patch
    opt: -p1
perl-Menlo:
  '1.9019':
  - content: |
      diff -ur Menlo-1.9019/Makefile.PL Menlo-1.9019_fix/Makefile.PL
      --- Menlo-1.9019/Makefile.PL	2018-04-25 11:17:30.000000000 +0200
      +++ Menlo-1.9019_fix/Makefile.PL	2020-10-16 11:16:53.737896074 +0200
      @@ -43,7 +43,6 @@
           "Parse::PMFile" => "0.26",
           "String::ShellQuote" => 0,
           "URI" => 0,
      -    "Win32::ShellQuote" => 0,
           "local::lib" => 0,
           "parent" => 0,
           "version" => 0
      @@ -86,7 +85,6 @@
         "String::ShellQuote" => 0,
         "Test::More" => "0.96",
         "URI" => 0,
      -  "Win32::ShellQuote" => 0,
         "local::lib" => 0,
         "parent" => 0,
         "version" => 0
      Nur in Menlo-1.9019_fix: Makefile.PL~.
    name: dropwindows.diff
    opt: -p1
perl-Module-Depends:
  '0.16':
  - content: |
      Index: Module-Depends-0.16/t/depends.t
      ===================================================================
      --- Module-Depends-0.16.orig/t/depends.t
      +++ Module-Depends-0.16/t/depends.t
      @@ -44,7 +44,7 @@ like(
       $notthere->dist_dir('t/empty')->find_modules;
       like(
           $notthere->error,
      -    qr{^No {Build,Makefile}.PL found },
      +    qr/^No \{Build,Makefile\}.PL found /,
           "fails on empty dir"
       );
       
    name: left-brace.patch
    opt: -p1
perl-Module-Manifest-Skip:
  '0.23':
  - content: |
      From 18e36d68c1c7b6db2a4fe51482e2f46107e764c6 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Tue, 21 Apr 2020 08:01:21 +0200
      Subject: [PATCH] Adapt to changes in Moo 2.004000

      Moo-2.004000 refactored "creation and installation of helper subs" and
      as a result a direct Moo::import execution stopped working and
      Module-Manifest-Skip tests either:

      t/create.t .............. Can't locate object method "_install_subs" via package "Module::Manifest::Skip" at /usr/share/perl5/vendor_perl/Moo.pm line 47.
      BEGIN failed--compilation aborted at t/TestModuleManifestSkip.pm line 6.
      Compilation failed in require at t/create.t line 3.

      Because Moo::import() is already executed when Module::Manifest::Skip does "use
      Moo;", the simplest fix is to stop calling it again.

      https://github.com/ingydotnet/module-manifest-skip-pm/issues/7
      ---
       lib/Module/Manifest/Skip.pm | 3 ---
       1 file changed, 3 deletions(-)

      diff --git a/lib/Module/Manifest/Skip.pm b/lib/Module/Manifest/Skip.pm
      index 434f7ce..27c1ac7 100644
      --- a/lib/Module/Manifest/Skip.pm
      +++ b/lib/Module/Manifest/Skip.pm
      @@ -28,9 +28,6 @@ sub import {
               close MS;
               exit;
           }
      -    else {
      -        goto &Moo::import;
      -    }
       }
       
       sub add {
    name: 18e36d68c1c7b6db2a4fe51482e2f46107e764c6.patch
    opt: null
perl-Module-Reader:
  '0.003003':
  - content: |+
      From 4a20f97741b04d609ab4265fc8c6c1bdfc620daa Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Fri, 4 Aug 2023 16:58:23 +0200
      Subject: [PATCH] Adjust require exception to perl 5.37.8 wording
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      With perl 5.38.0 t/memmory test fails on Regexp objects:

          not ok 9 - regex fails the same as require
          #   Failed test 'regex fails the same as require'
          #   at t/memory.t line 99.
          #          got: 'Can't locate object method "INC" via package "Regexp"'
          #     expected: 'Can't locate object method "INC", nor "INCDIR" nor string overload via package "Regexp" in object hook in @INC'
          not ok 10 - class without INC fails the same as require
          #   Failed test 'class without INC fails the same as require'
          #   at t/memory.t line 99.
          #          got: 'Can't locate object method "INC" via package "NonHook"'
          #     expected: 'Can't locate object method "INC", nor "INCDIR" nor string overload via package "NonHook" in object hook in @INC'

      This is probably caused by this perl commit which also changed the exception
      text:

          commit 0d370d41c6e8fe1e36eb93a5561e6716ee3a7e3e
          Author: Yves Orton <demerphq@gmail.com>
          Date:   Sun Dec 18 18:48:51 2022 +0100

      	pp_ctl.c - Check if refs have overloads in @INC

      	If an object in @INC doesnt have a hook method, and it isnt a CODE ref
      	then check if it has string overloading, if it does not then die with a
      	helpful message, otherwise call the overload

      	This uses the nice new amagic_find() function.

      This patch adjustes Module::Reader::_open_ref() to emit a similar
      exception text. Though it does implement the missing features like
      handling INCDIR method or string overloading.

      With the new perl it's impossible to get the same exception text in
      a different way than by calling "require" function. Therefore
      in the long term, I recommend stop insisting on error-to-error parity
      and relaxing the tests instead.

      CPAN RT#148979

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      ---
       lib/Module/Reader.pm | 24 +++++++++++++++++++++---
       1 file changed, 21 insertions(+), 3 deletions(-)

      diff --git a/lib/Module/Reader.pm b/lib/Module/Reader.pm
      index cbab239..976d4ad 100644
      --- a/lib/Module/Reader.pm
      +++ b/lib/Module/Reader.pm
      @@ -218,9 +218,27 @@ sub _open_ref {
             main;
           no strict 'refs';
           no warnings 'uninitialized';
      -    @cb = defined Scalar::Util::blessed $inc ? $inc->INC($file)
      -        : ref $inc eq 'ARRAY'                ? $inc->[0]->($inc, $file)
      -                                             : $inc->($inc, $file);
      +    if (defined(Scalar::Util::blessed $inc)) {
      +        if ($^V < v5.37.8) {
      +            @cb = $inc->INC($file);
      +        } else {
      +            if ($inc->can('INC')) {
      +                @cb = $inc->INC($file);
      +            }
      +            # TODO: Handle INCDIR method
      +            # TODO: Handle string overloading
      +            else {
      +                die "Can't locate object method \"INC\", nor" .
      +                    " \"INCDIR\" nor string overload via" .
      +                    " package \"" . ref($inc) . "\" in object hook" .
      +                    " in \@INC";
      +            }
      +        }
      +    } elsif (ref $inc eq 'ARRAY') {
      +        @cb = $inc->[0]->($inc, $file);
      +    } else {
      +        @cb = $inc->($inc, $file);
      +    }
         }
       
         return
      -- 
      2.41.0

    name: 0001-Adjust-require-exception-to-perl-5.37.8-wording.patch
    opt: -p1
perl-Mojolicious-Plugin-AssetPack:
  '2.14':
  - content: |
      From 56b27ac3059f07fea0938cbd4bb59ba6e755a3c6 Mon Sep 17 00:00:00 2001
      From: Oliver Kurz <okurz@suse.de>
      Date: Tue, 19 Sep 2023 12:17:49 +0200
      Subject: [PATCH] Adapt to deprecation of spurt in upstream Mojolicious

      ---
       Makefile.PL                                       | 2 +-
       lib/Mojolicious/Plugin/AssetPack/Pipe/RollupJs.pm | 2 +-
       lib/Mojolicious/Plugin/AssetPack/Store.pm         | 4 ++--
       t/Helper.pm                                       | 6 +++---
       t/recreate.t                                      | 6 +++---
       7 files changed, 14 insertions(+), 11 deletions(-)

      diff --git a/Makefile.PL b/Makefile.PL
      index a7c078ec..b052d136 100644
      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -12,7 +12,7 @@ WriteMakefile(
         ABSTRACT_FROM => 'lib/Mojolicious/Plugin/AssetPack.pm',
         VERSION_FROM  => 'lib/Mojolicious/Plugin/AssetPack.pm',
         TEST_REQUIRES => {'Test::More'  => '0.88'},
      -  PREREQ_PM     => {'File::Which' => '1.21', 'IPC::Run3' => '0.048', 'Mojolicious' => '9.0'},
      +  PREREQ_PM     => {'File::Which' => '1.21', 'IPC::Run3' => '0.048', 'Mojolicious' => '9.34'},
         META_MERGE    => {
           'dynamic_config' => 0,
           'meta-spec'      => {version => 2},
      diff --git a/lib/Mojolicious/Plugin/AssetPack/Pipe/RollupJs.pm b/lib/Mojolicious/Plugin/AssetPack/Pipe/RollupJs.pm
      index d4f72630..a8a62045 100644
      --- a/lib/Mojolicious/Plugin/AssetPack/Pipe/RollupJs.pm
      +++ b/lib/Mojolicious/Plugin/AssetPack/Pipe/RollupJs.pm
      @@ -46,7 +46,7 @@ has _rollupjs => sub {
           $self->{_rollupjs_src} = tempfile(SUFFIX => '.js');
         }
       
      -  $self->{_rollupjs_src}->spurt($bin);
      +  $self->{_rollupjs_src}->spew($bin);
       
         return [$self->_find_app([qw(nodejs node)]), $self->{_rollupjs_src}->realpath];
       };
      diff --git a/lib/Mojolicious/Plugin/AssetPack/Store.pm b/lib/Mojolicious/Plugin/AssetPack/Store.pm
      index f591589b..8095f78b 100644
      --- a/lib/Mojolicious/Plugin/AssetPack/Store.pm
      +++ b/lib/Mojolicious/Plugin/AssetPack/Store.pm
      @@ -139,7 +139,7 @@ sub save {
       
         return $self->asset_class->new(%$attrs, content => $$ref) unless -w $dir;
       
      -  $path->spurt($$ref);
      +  $path->spew($$ref);
         $self->_db_set(%$attrs);
         return $self->asset_class->new(%$attrs, path => $path);
       }
      @@ -288,7 +288,7 @@ sub _download {
           $path = path($self->paths->[0], $self->_url2path($attrs{url}, $attrs{format}));
           $self->_log->info(qq(Caching "$url" to "$path".));
           $path->dirname->make_path unless -d $path->dirname;
      -    $path->spurt($tx->res->body);
      +    $path->spew($tx->res->body);
         }
       
         $attrs{url} = "$attrs{url}";
      diff --git a/t/Helper.pm b/t/Helper.pm
      index 55cdc151..ae3f0f84 100644
      --- a/t/Helper.pm
      +++ b/t/Helper.pm
      @@ -17,11 +17,11 @@ END { cleanup() }
       my %CREATED_FILES;
       
       unless ($ENV{TEST_KEEP_FILES}) {
      -  my $spurt = \&Mojo::File::spurt;
      +  my $spew = \&Mojo::File::spew;
         Mojo::Util::monkey_patch(
      -    'Mojo::File' => spurt => sub {
      +    'Mojo::File' => spew => sub {
             $CREATED_FILES{$_[0]} = 1 unless -e $_[0];
      -      goto $spurt;
      +      goto $spew;
           }
         );
       }
      diff --git a/t/recreate.t b/t/recreate.t
      index 20a4e335..3e2415ee 100644
      --- a/t/recreate.t
      +++ b/t/recreate.t
      @@ -14,7 +14,7 @@ my $t        = t::Helper->t(pipes => [qw(Css Combine)]);
       my @assets   = qw(one.css recreate.css);
       my $recreate = path(qw(t assets recreate.css));
       
      -$recreate->spurt(".recreate { color: #aaa }\n");
      +$recreate->spew(".recreate { color: #aaa }\n");
       
       $t->app->asset->process('app.css' => @assets);
       
      @@ -28,7 +28,7 @@ $t->get_ok('/')->status_is(200);
       is $t->tx->res->dom->at('link')->{href}, $link, 'same link href';
       
       # recreate
      -$recreate->spurt(".recreate { color: #bbb }\n");
      +$recreate->spew(".recreate { color: #bbb }\n");
       my $tr = t::Helper->t(pipes => [qw(Css Combine)]);
       $tr->app->asset->process('app.css' => @assets);
       $tr->get_ok('/')->status_is(200);
      @@ -36,7 +36,7 @@ isnt $tr->tx->res->dom->at('link')->{href}, $link, 'changed link href';
       $tr->get_ok($tr->tx->res->dom->at('link')->{href})->status_is(200)->content_like(qr{color:\#bbb});
       
       # reset asset
      -$recreate->spurt(".recreate { color: #aaa }\n");
      +$recreate->spew(".recreate { color: #aaa }\n");
       
       done_testing;
       __DATA__
    name: mojolicious-deprecate-spurt.patch
    opt: -p1 PATCH-FIX-UPSTREAM https://github.com/mojolicious/mojo-assetpack/pull/149
perl-MooseX-Types-Parameterizable:
  '0.09':
  - content: |
      Index: MooseX-Types-Parameterizable-0.08/t/05-pod-examples.t
      ===================================================================
      --- MooseX-Types-Parameterizable-0.08.orig/t/05-pod-examples.t
      +++ MooseX-Types-Parameterizable-0.08/t/05-pod-examples.t
      @@ -236,7 +236,8 @@ use Test::More;
       
           Test::More::is MySpecialVarchar([40])->coerce("abc"), 'abc';
           Test::More::is_deeply( MySpecialVarchar([40])->coerce([qw/d e f/]), [qw/d e f/]);
      -    Test::More::is MySpecialVarchar([40])->coerce({a=>1, b=>2}), 'ab';
      +    # hashes are random, so you can't know
      +    #Test::More::is MySpecialVarchar([40])->coerce({a=>1, b=>2}), 'ab';
       }
       
       {
    name: remove-buggy-test.patch
    opt: -p1
perl-MouseX-Getopt:
  '0.38':
  - content: |
      From c1d1eed00099af8d858536b659864b7ccea41974 Mon Sep 17 00:00:00 2001
      From: Paul Howarth <paul@city-fan.org>
      Date: Sat, 13 Mar 2021 17:46:57 +0000
      Subject: [PATCH 1/2] Update for Getopt-Long-Descriptive 0.106

      GLD is now outputting text with wrapping depending on the terminal
      width. This update is enough to get the tests to pass when running
      within "expect", which provides a PTY. It's almost certainly not
      enough for general use.
      ---
       t/104_override_usage.t           |  8 ++++++++
       t/107_no_auto_help.t             |  2 +-
       t/109_help_flag.t                |  2 +-
       t/110_sort_usage_by_attr_order.t | 12 ++++++++++++
       4 files changed, 22 insertions(+), 2 deletions(-)

      diff --git a/t/104_override_usage.t b/t/104_override_usage.t
      index bc45029..6641540 100644
      --- a/t/104_override_usage.t
      +++ b/t/104_override_usage.t
      @@ -61,9 +61,17 @@ use Test::Exception;
       \t--foo INT          A foo
       }
               :
      +         $Getopt::Long::Descriptive::VERSION < 0.106 ?
                qq{usage: 104_override_usage.t [-?] [long options...]
       \t-? --[no-]usage --[no-]help       Prints this usage information.
       \t--foo INT                         A foo
      +}
      +        :
      +         qq{usage: 104_override_usage.t [-?] [long options...]
      +\t--[no-]help (or -?)  Prints
      +\t             this usage information.
      +\t             aka --usage
      +\t--foo INT    A foo
       }
       
            ];
      diff --git a/t/107_no_auto_help.t b/t/107_no_auto_help.t
      index 27f87f5..103df43 100644
      --- a/t/107_no_auto_help.t
      +++ b/t/107_no_auto_help.t
      @@ -60,7 +60,7 @@ END {
       warning_like {
           throws_ok { Class->new_with_options }
                  #usage: 107_no_auto_help.t [-?] [long options...]
      -        qr/^usage: [\d\w]+\Q.t [-?] [long options...]\E.\s+\Q-? --\E(\[no-\])?usage --(\[no-\])?\Qhelp\E\s+\QPrints this usage information.\E.\s+--configfile/ms,
      +        qr/^usage: [\d\w]+\Q.t [-?] [long options...]\E.\s+(\Q-? --\E(\[no-\])?usage )?--(\[no-\])?\Qhelp\E(\Q (or -?)\E)?\s+\QPrints this usage information.\E.(\s+\Qaka --usage\E.)?\s+--configfile/ms,
               'usage information looks good';
           }
           qr/^Specified configfile \'this_value_unimportant\' does not exist, is empty, or is not readable$/,
      diff --git a/t/109_help_flag.t b/t/109_help_flag.t
      index 8c658e2..58dbca6 100644
      --- a/t/109_help_flag.t
      +++ b/t/109_help_flag.t
      @@ -40,7 +40,7 @@ foreach my $args ( ['--help'], ['--usage'], ['--?'], ['-?'] )
           local @ARGV = @$args;
       
           throws_ok { MyClass->new_with_options() }
      -        qr/^usage: (?:[\d\w]+)\Q.t [-?] [long options...]\E.^\t\Q-? --\E(\[no-\])?usage --(\[no-\])?help\s+\QPrints this usage information.\E$/ms,
      +        qr/^usage: (?:[\d\w]+)\Q.t [-?] [long options...]\E.^\s+(\Q-? --\E(\[no-\])?usage )?--(\[no-\])?help(\Q (or -?)\E)?\s+Prints ?(.\s+)?\Qthis usage information.\E.(\s+\Qaka --usage\E.)?$/ms,
               'Help request detected; usage information properly printed';
       }
       
      diff --git a/t/110_sort_usage_by_attr_order.t b/t/110_sort_usage_by_attr_order.t
      index e7dd177..7ec0c99 100644
      --- a/t/110_sort_usage_by_attr_order.t
      +++ b/t/110_sort_usage_by_attr_order.t
      @@ -64,6 +64,18 @@ usage: 110_sort_usage_by_attr_order.t [-?] [long options...]
           --baz STR                         Documentation for "baz"
       USAGE
       }
      +if ( $Getopt::Long::Descriptive::VERSION >= 0.106 )
      +{
      +$expected = <<'USAGE';
      +usage: 110_sort_usage_by_attr_order.t [-?] [long options...]
      +    --[no-]help (or -?)  Prints
      +                 this usage information.
      +                 aka --usage
      +    --foo STR    Documentation for "foo"
      +    --bar STR    Documentation for "bar"
      +    --baz STR    Documentation for "baz"
      +USAGE
      +}
       $expected =~ s/^[ ]{4}/\t/xmsg;
       is($obj->usage->text, $expected, 'Usage text has nicely sorted options');
       

      From 45ae6aaabc5413e985860fbfcc8da3bdc929a054 Mon Sep 17 00:00:00 2001
      From: Paul Howarth <paul@city-fan.org>
      Date: Mon, 15 Mar 2021 10:43:14 +0000
      Subject: [PATCH 2/2] Update for Getopt-Long-Descriptive 0.107

      GLD's use of Term::ReadKey has been reverted, so this update should now
      work reliably. Use with GLD 0.106 is not supported.
      ---
       t/104_override_usage.t           | 6 +++---
       t/110_sort_usage_by_attr_order.t | 6 +++---
       2 files changed, 6 insertions(+), 6 deletions(-)

      diff --git a/t/104_override_usage.t b/t/104_override_usage.t
      index 6641540..f7c6a31 100644
      --- a/t/104_override_usage.t
      +++ b/t/104_override_usage.t
      @@ -61,15 +61,15 @@ use Test::Exception;
       \t--foo INT          A foo
       }
               :
      -         $Getopt::Long::Descriptive::VERSION < 0.106 ?
      +         # Note: Getopt::Long::Descriptive 0.106 not supported
      +         $Getopt::Long::Descriptive::VERSION < 0.107 ?
                qq{usage: 104_override_usage.t [-?] [long options...]
       \t-? --[no-]usage --[no-]help       Prints this usage information.
       \t--foo INT                         A foo
       }
               :
                qq{usage: 104_override_usage.t [-?] [long options...]
      -\t--[no-]help (or -?)  Prints
      -\t             this usage information.
      +\t--[no-]help (or -?)  Prints this usage information.
       \t             aka --usage
       \t--foo INT    A foo
       }
      diff --git a/t/110_sort_usage_by_attr_order.t b/t/110_sort_usage_by_attr_order.t
      index 7ec0c99..16cdaa1 100644
      --- a/t/110_sort_usage_by_attr_order.t
      +++ b/t/110_sort_usage_by_attr_order.t
      @@ -64,12 +64,12 @@ usage: 110_sort_usage_by_attr_order.t [-?] [long options...]
           --baz STR                         Documentation for "baz"
       USAGE
       }
      -if ( $Getopt::Long::Descriptive::VERSION >= 0.106 )
      +# Note: Getopt::Long::Descriptive 0.106 not supported
      +if ( $Getopt::Long::Descriptive::VERSION >= 0.107 )
       {
       $expected = <<'USAGE';
       usage: 110_sort_usage_by_attr_order.t [-?] [long options...]
      -    --[no-]help (or -?)  Prints
      -                 this usage information.
      +    --[no-]help (or -?)  Prints this usage information.
                        aka --usage
           --foo STR    Documentation for "foo"
           --bar STR    Documentation for "bar"
    name: pr-15.patch
    opt: -p1
perl-Net-Curl:
  0.550.0:
  - content: |
      # see https://github.com/sparky/perl-Net-Curl/issues/18

      diff -ru Net-Curl-0.37.orig/Makefile.PL Net-Curl-0.37/Makefile.PL
      --- Net-Curl-0.37.orig/Makefile.PL	2015-02-01 10:20:35.000000000 +0100
      +++ Net-Curl-0.37/Makefile.PL	2017-05-30 16:26:38.554205323 +0200
      @@ -310,6 +310,7 @@
       		}
       		close H;
       	}
      +        delete $syms{CURL_STRICTER};
       
       	my @out;
       	foreach my $e (sort keys %syms) {
    name: fix-curl.diff
    opt: -p1
perl-Net-DNS-Paranoid:
  0.90.0:
  - content: |
      diff -ur Net-DNS-Paranoid-0.08/t/01_simple.t Net-DNS-Paranoid-0.08_fix/t/01_simple.t
      --- Net-DNS-Paranoid-0.08/t/01_simple.t	2015-09-30 09:01:39.000000000 +0200
      +++ Net-DNS-Paranoid-0.08_fix/t/01_simple.t	2023-06-29 17:22:05.408870757 +0200
      @@ -23,6 +23,12 @@
               $mock_resolver->set_fake_record("bradlj-fortest.danga.com", $packet);
           }
       
      +    {
      +        my $packet = Net::DNS::Packet->new;
      +        $packet->push(answer => Net::DNS::RR->new("50.112.116.235.nip.io 86400 IN A 50.112.116.235"));
      +        $mock_resolver->set_fake_record("50.112.116.235.nip.io", $packet);
      +    }
      +
           $mock_resolver;
       };
       
      Nur in Net-DNS-Paranoid-0.08_fix/t: 01_simple.t~.
    name: fake_dns_access.patch
    opt: -p1 PATCH-FIX-OPENSUSE fake the DNS access as we have no network on the build machines
  - content: |
      From 3b438f6f17f765f263801c61ec3111f789310eb0 Mon Sep 17 00:00:00 2001
      From: Brendan Byrd <brendan.byrd@grantstreet.com>
      Date: Wed, 21 Oct 2015 11:23:19 -0400
      Subject: [PATCH] Use Net::DNS::Resolver's retry functionality to check other
       NSs

      ---
       lib/Net/DNS/Paranoid.pm | 52 ++++++++++++++++++++++++++---------------
       t/MockResolver.pm       |  5 ++++
       2 files changed, 38 insertions(+), 19 deletions(-)

      diff --git a/lib/Net/DNS/Paranoid.pm b/lib/Net/DNS/Paranoid.pm
      index 9629ff4..a310784 100644
      --- a/lib/Net/DNS/Paranoid.pm
      +++ b/lib/Net/DNS/Paranoid.pm
      @@ -8,17 +8,32 @@ use Class::Accessor::Lite (
           rw => [qw(timeout blocked_hosts whitelisted_hosts resolver)]
       );
       use Net::DNS;
      +use Time::HiRes qw( alarm );
      +use POSIX qw( ceil );
       
       sub new {
           my $class = shift;
           my %args = @_ ==1 ? %{$_[0]} : @_;
      -    $args{resolver} ||= Net::DNS::Resolver->new;
      +
      +    $args{timeout} ||= 15;
      +
      +    unless ($args{resolver}) {
      +        my $res = $args{resolver} = Net::DNS::Resolver->new(
      +            # Calculate the nearest base 2 exponent that would cover the timeout period
      +            # So, 1+2+4+8 = 15 seconds, which would be 4 retries
      +            retrans => 1,
      +            retry   => ceil( log($args{timeout} + 1) / log(2) ),
      +            udp_timeout => $args{timeout},
      +        );
      +
      +        # no staggered retries, full time used is $timeout * $num_of_ns
      +        my $num_of_ns = scalar $res->nameservers;
      +        $res->tcp_timeout( ceil( $args{timeout} / $num_of_ns ) );
      +    }
      +
           $args{whitelisted_hosts} ||= [];
           $args{blocked_hosts} ||= [];
      -    bless {
      -        timeout => 15,
      -        %args
      -    }, $class;
      +    bless { %args }, $class;
       }
       
       sub resolve {
      @@ -41,22 +56,21 @@ sub _resolve {
           # return the IP address if it looks like one and wasn't marked bad
           return ([$host]) if $host =~ /^\d+\.\d+\.\d+\.\d+$/;
        
      -    my $sock = $res->bgsend($host)
      -        or return (undef, "No sock from bgsend");
      - 
      -    # wait for the socket to become readable, unless this is from our test
      -    # mock resolver.
      -    unless ($sock && $sock eq "MOCK") {
      -        my $rin = '';
      -        vec($rin, fileno($sock), 1) = 1;
      -        my $nf = select($rin, undef, undef, $self->_time_remain($start_time));
      -        return (undef, "DNS lookup timeout") unless $nf;
      +    # Find the host using Resolver's send method, which supports timeouts
      +    # and alternate NSs.  Most of the time, this will use UDP, but may
      +    # switch to TCP in certain situations.
      +    my $packet;
      +    local $SIG{ALRM} = sub { die "DNS lookup timeout\n" };
      +    alarm $self->_time_remain($start_time);
      +    eval { $packet = $res->send($host) };
      +    alarm 0;
      +
      +    unless ($packet) {
      +        my $errstr = $@ || "DNS send failure: ".$res->errorstring;
      +        chomp $errstr;
      +        return (undef, $errstr);
           }
        
      -    my $packet = $res->bgread($sock)
      -        or return (undef, "DNS bgread failure");
      -    $sock = undef;
      - 
           my @addr;
           my $cname;
           foreach my $rr ($packet->answer) {
      diff --git a/t/MockResolver.pm b/t/MockResolver.pm
      index 9a1c609..37ae191 100644
      --- a/t/MockResolver.pm
      +++ b/t/MockResolver.pm
      @@ -32,6 +32,11 @@ sub _make_proxy {
                       if $ENV{VERBOSE};
                   return $self->{next_fake_packet};
               }
      +        if ($method eq "send" && $fr->{$_[0]}) {
      +            Test::More::note("mock DNS resolver doing fake send() of $_[0]\n")
      +                if $ENV{VERBOSE};
      +            return $fr->{$_[0]};
      +        }
               # No verbose conditional on this one because it shouldn't happen:
               Test::More::note("Calling through to Net::DNS::Resolver proxy method '$method'");
               return $self->{proxy}->$method(@_);
    name: 3b438f6f17f765f263801c61ec3111f789310eb0.patch
    opt: null
perl-Net-IP:
  '1.26':
  - content: |
      Index: Net-IP-1.26/ipcount
      ===================================================================
      --- Net-IP-1.26.orig/ipcount	2005-10-18 11:59:52.000000000 +0200
      +++ Net-IP-1.26/ipcount	2015-09-16 13:50:21.639082216 +0200
      @@ -51,6 +51,7 @@ getopts ('rd:',\%opts);
       scalar (@ARGV) < 1 and usage();
       my $arg = join '',@ARGV;
       $arg =~ s/\s+//g;
      +$arg =~ s/\+/ \+ /g;
       
       my $ip = new Net::IP($arg) or die ("Cannot create IP object $arg: ".Error());
       
      @@ -77,7 +78,7 @@ if ($opts{d})
       	
       	while ($current->bincomp ('lt', $last))
       	{
      -		$new_ip->set($current->last_ip.'+'.$size) or die (Error());
      +		$new_ip->set($current->last_ip.' + '.$size) or die (Error());
       		print $new_ip->print,"\n";
       		
       		if ($opts{r})
      @@ -85,7 +86,7 @@ if ($opts{d})
       			print $new_ip->reverse_ip,"\n";
       		}
       		
      -		$current->set($new_ip->last_ip .'+ 1') or die (Error());
      +		$current->set($new_ip->last_ip .' + 1') or die (Error());
       		
       		$count++;
       	}
    name: ipcount-invalid_chars_in_IP.patch
    opt: -p1
  - content: |
      --- a/IP.pm
      +++ b/IP.pm
      @@ -410,7 +410,7 @@
       
           my $int = ip_bintoint($self->binip());
       
      -    if (!$int) {
      +    if (ref($int) ne "Math::BigInt") {
               $self->{error} = $ERROR;
               $self->{errno} = $ERRNO;
               return;
    name: perl-Net-IP-1.25-zero_address.diff
    opt: null
perl-Number-WithError:
  '1.01':
  - content: |+
      From 8c15ff58866e38cb8ce4f7b7ad3ecac941f5863d Mon Sep 17 00:00:00 2001
      From: Kent Fredric <kentnl@gentoo.org>
      Date: Fri, 7 Sep 2018 20:23:23 +1200
      Subject: Fix Makefile.PL to work on perl 5.26+/no-dot-inc perls

      Perl 5.26+ have @INC without '.' unless PERL_USE_UNSAFE_INC=1

      Perl 5.30+ will have no hack to avoid this problem \o/
      ---
       Makefile.PL | 1 +
       1 file changed, 1 insertion(+)

      diff --git a/Makefile.PL b/Makefile.PL
      index 76b23e1..a3c10b1 100644
      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -1,3 +1,4 @@
      +use lib '.';
       use inc::Module::Install;
       
       name           'Number-WithError';
      -- 
      2.17.1

    name: Number-WithError-1.01-no-dot-inc.patch
    opt: -p1
perl-OpenGL:
  '0.70':
  - content: |
      diff --git a/Makefile.PL b/Makefile.PL
      index d32205d..2a0ac3e 100755
      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -601,9 +601,9 @@ my $build_config =
         {
           FILES =>
             "Config.pm ".
      -      "utils/glversion.txt ".
      -      "utils/glversion$Config{exe_ext} ".
      -      "utils/glversion$Config{obj_ext}"
      +      "utils/glversion.txt "
      +      #"utils/glversion$Config{exe_ext} ".
      +      #"utils/glversion$Config{obj_ext}"
         }
       };
       
      @@ -824,6 +824,7 @@ sub get_extensions
           print "GLUT not found\n";
         }
       
      +=cut
         # Platform-specific makefiles for glversion
         my $make_ver;
         if ($IS_STRAWBERRY)
      @@ -882,6 +883,9 @@ sub get_extensions
         die "get_extensions: no extensions found in $glv_file\n" if !keys %$gldata;
       
         print "This looks like OpenGL Version: $gldata->{VERSION}\n";
      +=cut
      +  use Config;
      +  my $gldata = { };
       
         # Parse glext_procs.h file
         open GLEXT, "glext_procs.h" or die "get_extensions: could not open glext_procs.h: $!\n";
      @@ -900,11 +904,12 @@ sub get_extensions
       
         # Create gl_exclude.h
         die "Unable to write to $exc_file\n" if (!open(GLEXC,">$exc_file"));
      +=cut
         print GLEXC "// OpenGL Extension Exclusions - may be modified before building.\n";
         print GLEXC "//\n";
         print GLEXC "// Generated for ".$gldata->{VENDOR}.", ".$gldata->{RENDERER}."\n";
         print GLEXC "// OpenGL v".$gldata->{VERSION}.", using ";
      -
      +=cut
         # Fix GLUT flags based on results
         if ($gldata->{FREEGLUT})
         {
    name: 0001-Don-t-check-current-display-for-extensions.patch
    opt: -p1
perl-Perl-Critic-Pulp:
  '99':
  - content: |
      Index: Perl-Critic-Pulp-96/lib/Perl/Critic/Policy/Compatibility/PerlMinimumVersionAndWhy.pm
      ===================================================================
      --- Perl-Critic-Pulp-96.orig/lib/Perl/Critic/Policy/Compatibility/PerlMinimumVersionAndWhy.pm
      +++ Perl-Critic-Pulp-96/lib/Perl/Critic/Policy/Compatibility/PerlMinimumVersionAndWhy.pm
      @@ -189,7 +189,8 @@ sub _setup_extra_checks {
         # Perl::MinimumVersion prior to 1.28 had 'PPI::Token::Operator' and
         # 'PPI::Token::Magic' swapped between the respective operator/magic tests
       
      -  package Perl::MinimumVersion;
      +  package 
      +    Perl::MinimumVersion;
         use vars qw(%MATCHES);
         sub _Pulp__5010_operators__fix {
           shift->Document->find_first
    name: avoid-wrong-provides.diff
    opt: -p1
perl-PerlIO-utf8_strict:
  '0.010':
  - content: |
      Index: PerlIO-utf8_strict-0.006/utf8_strict.xs
      ===================================================================
      --- PerlIO-utf8_strict-0.006.orig/utf8_strict.xs
      +++ PerlIO-utf8_strict-0.006/utf8_strict.xs
      @@ -153,6 +153,7 @@ static STRLEN validate(pTHX_ const U8 *b
       		skip = skip_sequence(cur, end - cur);
       	PerlIOBase(handle)->flags |= PERLIO_F_ERROR;
       	report_illformed(aTHX_ cur, skip, eof);
      +	return 0;
       
         noncharacter:
       	if (v < 0xF0808080)
      @@ -161,6 +162,7 @@ static STRLEN validate(pTHX_ const U8 *b
       		v = (v & 0x3F) | (v & 0x3F00) >> 2 | (v & 0x3F0000) >> 4 | (v & 0x07000000) >> 6;
       	PerlIOBase(handle)->flags |= PERLIO_F_ERROR;
       	report_noncharacter(aTHX_ v);
      +	return 0;
       }
       
       typedef struct {
    name: no-return-in-nonvoid-function.patch
    opt: -p1
perl-Protocol-HTTP2:
  '1.10':
  - content: |
      From 552e3677372c77ec458548fd8c3fdc280e493d91 Mon Sep 17 00:00:00 2001
      From: Otto Hollmann <otto.hollmann@suse.com>
      Date: Thu, 4 May 2023 13:42:51 +0200
      Subject: [PATCH] Adapt tests for OpenSSL 3.1

      ---
       t/lib/PH2ClientServerTest.pm | 4 ++--
       1 file changed, 2 insertions(+), 2 deletions(-)

      diff --git a/t/lib/PH2ClientServerTest.pm b/t/lib/PH2ClientServerTest.pm
      index 3fe9203..fe90f32 100644
      --- a/t/lib/PH2ClientServerTest.pm
      +++ b/t/lib/PH2ClientServerTest.pm
      @@ -43,7 +43,7 @@ sub server {
               if ( !$h{upgrade} && ( $h{npn} || $h{alpn} ) ) {
                   eval {
                       $tls = AnyEvent::TLS->new(
      -                    method    => 'tlsv1',
      +                    method    => 'tlsv1_2',
                           cert_file => $tls_crt,
                           key_file  => $tls_key,
                       );
      @@ -122,7 +122,7 @@ sub client {
           }
           elsif ( $h{npn} || $h{alpn} ) {
               eval {
      -            $tls = AnyEvent::TLS->new( method => 'tlsv1', );
      +            $tls = AnyEvent::TLS->new( method => 'tlsv1_2', );
       
                   if ( delete $h{npn} ) {
       
    name: openssl3_1-adapt_tests.patch
    opt: -p1 PATCH-FIX-OPENSUSE https://github.com/vlet/p5-Protocol-HTTP2/pull/14
perl-RPC-XML:
  '0.82':
  - content: |
      Index: RPC-XML-0.78/lib/RPC/XML.pm
      ===================================================================
      --- RPC-XML-0.78.orig/lib/RPC/XML.pm
      +++ RPC-XML-0.78/lib/RPC/XML.pm
      @@ -848,7 +848,7 @@ sub as_string
                           ("<member><name>$_</name><value>",
                            $clean{$_},
                            '</value></member>')
      -                } (keys %clean)),
      +                } (sort keys %clean)),
                       '</struct>';
       }
       
      @@ -860,7 +860,7 @@ sub serialize
           my $key;
       
           print {$fh} '<struct>';
      -    for (keys %{$self})
      +    for (sort keys %{$self})
           {
               ($key = $_) =~ s/$RPC::XML::XMLRE/$RPC::XML::XMLMAP{$1}/ge;
               utf8::encode($key);
    name: RPC-XML-0.77-fixtest.dif
    opt: -p1
perl-SDL:
  '2.548':
  - content: |
      From d734d03862d7dcc776bd2fa3ba662cdd5879b32e Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Wed, 12 Jul 2023 17:55:27 +0200
      Subject: [PATCH] Adapt to perl 5.37.1

      Perl 5.37.1 removed a deprecated sv_nv() macro and SDL fails to build
      with Perl 5.38.0:

      lib/SDLx/Controller/Interface.xs:60:26: error: implicit declaration of function 'sv_nv'
         60 |         out->dv_x      = sv_nv(temp);
            |                          ^~~~~

      Users are advised to use SvNVx() macro instead. SvNVx() seems to have been
      available all the time (it predates a commit from 1993-10-07).

      This patch does that.

      https://github.com/PerlGameDev/SDL/issues/303
      ---
       src/SDLx/Controller/Interface.xs | 12 ++++++------
       1 file changed, 6 insertions(+), 6 deletions(-)

      diff --git a/src/SDLx/Controller/Interface.xs b/src/SDLx/Controller/Interface.xs
      index 3dc202b7..d326c885 100644
      --- a/src/SDLx/Controller/Interface.xs
      +++ b/src/SDLx/Controller/Interface.xs
      @@ -57,15 +57,15 @@ void evaluate(SDLx_Interface *obj, SDLx_Derivative *out, SDLx_State *initial, fl
       
       	SV *temp;
       	temp           = av_pop(accel);
      -	out->dv_x      = sv_nv(temp);
      +	out->dv_x      = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	temp           = av_pop(accel);
      -	out->dv_y      = sv_nv(temp);
      +	out->dv_y      = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	temp           = av_pop(accel);
      -	out->dang_v    = sv_nv(temp);
      +	out->dang_v    = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	SvREFCNT_dec((SV *)accel);
      @@ -90,15 +90,15 @@ void evaluate_dt(SDLx_Interface *obj, SDLx_Derivative *out, SDLx_State *initial,
       
       	SV *temp;
       	temp           = av_pop(accel);
      -	out->dv_x      = sv_nv(temp);
      +	out->dv_x      = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	temp           = av_pop(accel);
      -	out->dv_y      = sv_nv(temp);
      +	out->dv_y      = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	temp           = av_pop(accel);
      -	out->dang_v    = sv_nv(temp);
      +	out->dang_v    = SvNVx(temp);
       	SvREFCNT_dec(temp);
       
       	SvREFCNT_dec((SV *)accel);
    name: 304.patch
    opt: null
  - content: |
      From fbf151a7481a5fda88bfe766d826fe55476cf4af Mon Sep 17 00:00:00 2001
      From: Colin Watson <cjwatson@debian.org>
      Date: Thu, 28 Mar 2024 13:21:47 +0000
      Subject: [PATCH] Fix reference-counting in set_event_filter

      This previously resulted in the following test failure with Perl 5.38.2
      on Debian unstable (https://bugs.debian.org/1064761):

          t/core_events.t ................. 1/? Can't use an undefined value as a subroutine reference during global destruction.
          t/core_events.t ................. Dubious, test returned 22 (wstat 5632, 0x1600)
          All 691 subtests passed
                  (less 1 skipped subtest: 690 okay)
      ---
       src/Core/Events.xs | 3 ++-
       1 file changed, 2 insertions(+), 1 deletion(-)

      diff --git a/src/Core/Events.xs b/src/Core/Events.xs
      index faa7cfe6..0b99f8a9 100644
      --- a/src/Core/Events.xs
      +++ b/src/Core/Events.xs
      @@ -102,7 +102,8 @@ void
       events_set_event_filter(callback)
       	SV* callback
       	CODE:
      -		eventfiltersv = callback;
      +		SvREFCNT_dec(eventfiltersv);
      +		eventfiltersv = SvREFCNT_inc_simple(callback);
       		SDL_SetEventFilter((SDL_EventFilter) eventfilter_cb);
       
       AV *
    name: 308.patch
    opt: null
perl-SOAP-Lite:
  '1.27':
  - content: |
      Index: SOAP-Lite-1.27/bin/SOAPsh.pl
      ===================================================================
      --- SOAP-Lite-1.27.orig/bin/SOAPsh.pl
      +++ SOAP-Lite-1.27/bin/SOAPsh.pl
      @@ -1,5 +1,4 @@
      -#!/usr/bin/env perl
      -#!d:\perl\bin\perl.exe
      +#!perl
       
       # -- SOAP::Lite -- soaplite.com -- Copyright (C) 2001 Paul Kulchenko --
       
      Index: SOAP-Lite-1.27/bin/stubmaker.pl
      ===================================================================
      --- SOAP-Lite-1.27.orig/bin/stubmaker.pl
      +++ SOAP-Lite-1.27/bin/stubmaker.pl
      @@ -1,5 +1,4 @@
      -#!/usr/bin/env perl
      -#!d:\perl\bin\perl.exe
      +#!perl
       #
       # Filename: stubmaker.pl
       # Authors: Byrne Reese <byrne at majordojo dot com>
      Index: SOAP-Lite-1.27/examples/XMLRPC/xmlrpc.cgi
      ===================================================================
      --- SOAP-Lite-1.27.orig/examples/XMLRPC/xmlrpc.cgi
      +++ SOAP-Lite-1.27/examples/XMLRPC/xmlrpc.cgi
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       # -- XMLRPC::Lite -- services.soaplite.com -- Copyright (C) 2001 Paul Kulchenko --
       
      Index: SOAP-Lite-1.27/examples/XMLRPC/xmlrpc.daemon
      ===================================================================
      --- SOAP-Lite-1.27.orig/examples/XMLRPC/xmlrpc.daemon
      +++ SOAP-Lite-1.27/examples/XMLRPC/xmlrpc.daemon
      @@ -1,4 +1,4 @@
      -#!/usr/bin/env perl
      +#!/usr/bin/perl
       
       # -- XMLRPC::Lite -- services.soaplite.com -- Copyright (C) 2001 Paul Kulchenko --
       
    name: perl-SOAP-Lite-1.27-usr-bin-env.patch
    opt: -p1
perl-Spoon:
  '0.24':
  - content: |
      Index: Spoon-0.24/lib/Spoon/Base.pm
      ===================================================================
      --- Spoon-0.24.orig/lib/Spoon/Base.pm	2006-11-09 02:12:40.000000000 +0100
      +++ Spoon-0.24/lib/Spoon/Base.pm	2011-06-03 12:00:40.891296379 +0200
      @@ -224,7 +224,8 @@ sub base64_decode {
       }
       
       # XXX Move to IO::All. Make more robust. Use Damian's prompting module.
      -package IO::All;
      +package  
      +  IO::All;
       
       sub prompt {
           print shift;
    name: noprovides.diff
    opt: -p1
perl-Spreadsheet-ReadSXC:
  0.380.0:
  - content: |
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Cell.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Cell.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Cell.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Cell.pm	2020-10-15 16:18:27.748900421 +0200
      @@ -1,6 +1,5 @@
       package Spreadsheet::ParseODS::Cell;
       use Moo 2;
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Settings.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Settings.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Settings.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Settings.pm	2020-10-15 16:18:18.132747780 +0200
      @@ -1,7 +1,6 @@
       package Spreadsheet::ParseODS::Settings;
       use Moo 2;
       use Carp qw(croak);
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       use PerlX::Maybe;
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Styles.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Styles.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Styles.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Styles.pm	2020-10-15 16:18:25.564865752 +0200
      @@ -2,7 +2,6 @@
       use 5.010; # for //
       use Moo 2;
       use Carp qw(croak);
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       use PerlX::Maybe;
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Workbook.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Workbook.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Workbook.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Workbook.pm	2020-10-15 16:18:20.468784860 +0200
      @@ -1,6 +1,5 @@
       package Spreadsheet::ParseODS::Workbook;
       use Moo 2;
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Worksheet.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Worksheet.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS/Worksheet.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS/Worksheet.pm	2020-10-15 16:18:23.116826893 +0200
      @@ -1,7 +1,6 @@
       package Spreadsheet::ParseODS::Worksheet;
       use Moo 2;
       use Carp qw(croak);
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       use PerlX::Maybe;
      diff -ur Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS.pm Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS.pm
      --- Spreadsheet-ReadSXC-0.32/lib/Spreadsheet/ParseODS.pm	2020-10-15 16:17:17.475784988 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/lib/Spreadsheet/ParseODS.pm	2020-10-15 16:18:15.296702765 +0200
      @@ -12,7 +12,6 @@
       our $VERSION = '0.38';
       our @CARP_NOT = (qw(XML::Twig));
       
      -use Filter::signatures;
       use feature 'signatures';
       no warnings 'experimental::signatures';
       use PerlX::Maybe;
      diff -ur Spreadsheet-ReadSXC-0.32/Makefile.PL Spreadsheet-ReadSXC-0.32_fix/Makefile.PL
      --- Spreadsheet-ReadSXC-0.32/Makefile.PL	2020-10-15 16:17:17.471784925 +0200
      +++ Spreadsheet-ReadSXC-0.32_fix/Makefile.PL	2020-10-15 16:18:37.057048163 +0200
      @@ -49,7 +49,6 @@
           PREREQ_PM => {
               'Carp'               => 0,
               'PerlX::Maybe'       => 0,
      -        'Filter::signatures' => '0.16',
               'Archive::Zip'       => '1.34', # for seekable streams, verified thanks to Backpan
               'PerlIO::gzip'       => 0,
               'XML::Twig'          => 0,
    name: remove_filter_signatures.diff
    opt: -p1 PATCH-FIX-OPENSUSE Do not requires Filter::signatures, as we have perl > 5.20
perl-Sys-LoadAvg:
  '0.03':
  - content: |+
      From 2754541aba279ef6715f1f3adcd9b8e4881fc830 Mon Sep 17 00:00:00 2001
      From: Frank Schreiner <schreiner@suse.de>
      Date: Thu, 10 Dec 2020 07:49:09 +0100
      Subject: [PATCH] enhance loadavg array from 2 to 3 doubles

      Fixes: https://rt.cpan.org/Public/Bug/Display.html?id=120617

      Without this patch on aarch64 the module crashes with the following message:

      perl -e 'use Sys::LoadAvg qw( loadavg );loadavg();'
      *** stack smashing detected ***: terminated
      Aborted (core dumped)
      ---
       LoadAvg.xs | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/LoadAvg.xs b/LoadAvg.xs
      index 0cb1c40..2c4c48b 100644
      --- a/LoadAvg.xs
      +++ b/LoadAvg.xs
      @@ -13,7 +13,7 @@ void
       loadavg()
         PROTOTYPE:
         PREINIT:
      -    double loadavg[2];
      +    double loadavg[3];
           int retval; 
           int i;
         PPCODE:
      -- 
      2.29.2

    name: 0001-enhance-loadavg-array-from-2-to-3-doubles.patch
    opt: -p1
perl-Sys-Utmp:
  '1.8':
  - content: |
      Author: Joey Hess <joeyh@debian.org>
      Description: Fix the test suite to not die if the utmp file is empty.
      Bug: #394618

      --- a/t/06taint.t
      +++ b/t/06taint.t
      @@ -23,5 +23,8 @@ my $utmp = Sys::Utmp->new();
        
       my $utent =  $utmp->getutent();
       
      -ok(tainted($utent->ut_user()),"ut_user is tainted");
      -ok(tainted($utent->ut_host()),"ut_host is tainted");
      +SKIP: {
      +	skip "no utmp entries", 2 if ! $utent;
      +	ok(tainted($utent->ut_user()),"ut_user is tainted");
      +	ok(tainted($utent->ut_host()),"ut_host is tainted");
      +}
      --- a/t/07utent_methods.t
      +++ b/t/07utent_methods.t
      @@ -7,10 +7,13 @@ my $utmp = Sys::Utmp->new();
       
       my $utent = $utmp->getutent();
       
      -ok(defined $utent->ut_user(),"ut_user");
      -ok(defined $utent->ut_id(),"ut_id");
      -ok(defined $utent->ut_line(),"ut_line");
      -ok(defined $utent->ut_pid(),"ut_pid");
      -ok(defined $utent->ut_type(),"ut_type");
      -ok(defined $utent->ut_host(),"ut_host");
      -ok(defined $utent->ut_time(),"ut_time");
      +SKIP: {
      +	skip "no utmp entries", 7 if ! $utent;
      +	ok(defined $utent->ut_user(),"ut_user");
      +	ok(defined $utent->ut_id(),"ut_id");
      +	ok(defined $utent->ut_line(),"ut_line");
      +	ok(defined $utent->ut_pid(),"ut_pid");
      +	ok(defined $utent->ut_type(),"ut_type");
      +	ok(defined $utent->ut_host(),"ut_host");
      +	ok(defined $utent->ut_time(),"ut_time");
      +}
      --- a/t/08utent_types.t
      +++ b/t/08utent_types.t
      @@ -6,13 +6,16 @@ use Test::More tests => 10;
       my $utmp = Sys::Utmp->new();
       my $utent = $utmp->getutent();
       
      -ok(defined $utent->accounting(),"accounting");
      -ok(defined $utent->boot_time(),"boot_time");
      -ok(defined $utent->dead_process(),"dead_process");
      -ok(defined $utent->empty(),"empty");
      -ok(defined $utent->init_process(),"init_process");
      -ok(defined $utent->login_process(),"login_process");
      -ok(defined $utent->new_time(),"new_time");
      -ok(defined $utent->old_time(),"old_time");
      -ok(defined $utent->run_lvl(),"run_lvl");
      -ok(defined $utent->user_process(),"user_process");
      +SKIP: {
      +	skip "no utmp entries", 10 if ! $utent;
      +	ok(defined $utent->accounting(),"accounting");
      +	ok(defined $utent->boot_time(),"boot_time");
      +	ok(defined $utent->dead_process(),"dead_process");
      +	ok(defined $utent->empty(),"empty");
      +	ok(defined $utent->init_process(),"init_process");
      +	ok(defined $utent->login_process(),"login_process");
      +	ok(defined $utent->new_time(),"new_time");
      +	ok(defined $utent->old_time(),"old_time");
      +	ok(defined $utent->run_lvl(),"run_lvl");
      +	ok(defined $utent->user_process(),"user_process");
      +}
    name: empty_utmp.patch
    opt: -p1
perl-Test-Strict:
  '0.52':
  - content: |
      From 8cc3a355b90db21b76374d3b563df3628b31d58c Mon Sep 17 00:00:00 2001
      From: James E Keenan <jkeenan@cpan.org>
      Date: Sat, 14 Jan 2023 22:42:22 +0000
      Subject: [PATCH] Don't simultaneously test -c and -v switches

      Up through perl-5.37.3, there was a bug in perl (see
      https://github.com/Perl/perl5/issues/20252#issuecomment-1236880872)
      which permitted simultaneous use of the '-c' and '-v' switches to the
      perl interpreter.  Once this bug was corrected, t/01all.t began to fail.
      As Test::Strict has many CPAN distributions depending on it, this test
      failure has had wide impact.

      This pull request modifies tests appropriately and has been tested on
      bleadperl (v5.37.7-134-g25948dfb24) and on perl-5.32.1, in both cases on
      threaded builds on FreeBSD-12.  Devel::Cover was not installed on
      bleadperl, hence t/04cover.t was skipped on that build.  Otherwise, all
      tests are passing.  In the course of testing, certain additions were
      made to .gitignore and MANIFEST.SKIP to get metadata-oriented tests to
      pass.

      NOTE:  In my git checkout I find the following file:

              .git/hooksfsmonitor-watchman.sample

      This is deemed by 'file' to be a Perl executable.  As such, it is pushed
      onto the list of files tested by 'all_perl_files_ok()' at the start of
      t/01all.t.  This in turn means that in my 'git checkout' the count of
      tests is off by 2 and the test is reported to fail.

              "Looks like you planned 59 tests but ran 61."

      Because the files in .git/hooks/ should not be included in the tarball,
      the count of tests is correct when run from the tarball.  I leave to the
      maintainer to determine how to square this circle.  You should probably
      check for the presence of a .git/ directory and exclude that directory
      from the list of directories passed to all_perl_files_ok().

      For https://github.com/manwar/Test-Strict/issues/32
      ---
       .gitignore    | 2 ++
       MANIFEST.SKIP | 5 +++--
       t/01all.t     | 4 +---
       t/02fail.t    | 3 +--
       4 files changed, 7 insertions(+), 7 deletions(-)

      diff --git a/MANIFEST.SKIP b/MANIFEST.SKIP
      index 6dd7c05..03e0675 100644
      --- a/MANIFEST.SKIP
      +++ b/MANIFEST.SKIP
      @@ -1,4 +1,5 @@
      -^\.git
      +\.gitignore
      +\.git/
       maint
       ^tags$
       .last_cover_stats
      @@ -8,7 +9,7 @@ Makefile$
       ^.*.bak
       ^.*.old
       ^t.*sessions
      -^cover_db
      +cover_db/
       ^.*\.log
       ^.*\.swp$
       ^.*~$
      diff --git a/t/01all.t b/t/01all.t
      index 6ff9f23..569354d 100644
      --- a/t/01all.t
      +++ b/t/01all.t
      @@ -125,8 +125,6 @@ subtest perl_v5_12 => sub {
         strict_ok($filename);
       };
       
      -exit;
      -
       {
       	my %data;
       	sub make_file {
      @@ -172,7 +170,7 @@ sub make_warning_files {
       
         my ($fh2, $filename2) = tempfile( DIR => $tmpdir, SUFFIX => '.pl' );
         print $fh2 <<'DUMMY';
      -#!/usr/bin/perl -vw
      +#!/usr/bin/perl -w
       use strict;
       print "Hello world";
       
      diff --git a/t/02fail.t b/t/02fail.t
      index d4729cc..b0c8493 100644
      --- a/t/02fail.t
      +++ b/t/02fail.t
      @@ -40,7 +40,6 @@ TODO: {
         ok !Test::Strict::_strict_ok($fh1), 'use strict in print';
       }
       
      -exit;
       
       
       sub test1 {
      @@ -199,7 +198,7 @@ DUMMY
       
         my ($fh2, $filename2) = tempfile( DIR => $tmpdir, SUFFIX => '.pl' );
         print $fh2 <<'DUMMY';
      -#!/usr/bin/perl -vw
      +#!/usr/bin/perl -w
       use strict;
       print "Hello world";
       
    name: test-perl-5.38.patch
    opt: -p1 PATCH-FIX-UPSTREAM test-perl-5.38.patch gh#manwar/Test-Strict#33 -- Don't simultaneously test -c and -v switches
perl-Text-BibTeX:
  0.890.0:
  - content: |
      --- Text-BibTeX-0.80/inc/MyBuilder.pm	2017-03-25 20:41:12.000000000 +0000
      +++ Text-BibTeX-0.80/inc/MyBuilder.pm	2017-05-31 09:58:18.898289185 +0000
      @@ -172,8 +172,8 @@ sub ACTION_create_manpages {
           my $version = $self->notes('btparse_version');
           for my $pod (@$pods) {
               my $man = $pod;
      -        $man =~ s!.pod!.1!;
      -        $man =~ s!btparse/doc!blib/bindoc!;   ## FIXME - path
      +        $man =~ s!.pod!.3!;
      +        $man =~ s!btparse/doc!blib/libdoc!;
               next if $self->up_to_date($pod, $man);
               ## FIXME
               `pod2man --section=1 --center="btparse" --release="btparse, version $version" $pod $man`;
    name: manual-pages-for-libbtparse.patch
    opt: -p1
perl-Text-Markdown-Discount:
  '0.16':
  - content: |
      Description: Use the markdown library provided by the libmarkdown2 package.
      Author: Alessandro Ghedini <al3xbio@gmail.com>
      Origin: vendor
      Forwarded: not-needed
      Last-Update: 2020-02-04

      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -57,12 +57,6 @@
       
       
       
      -sub MY::postamble {
      -    return sprintf('
      -$(MYEXTLIB):
      -	%s
      -', qq{( cd $extdir; CC='cc -fPIC' sh configure.sh --with-fenced-code --with-dl=both; make )\n});
      -}
       
       WriteMakefile(
           NAME              => 'Text::Markdown::Discount',
      @@ -71,10 +65,9 @@
           ($] >= 5.005 ?
             (ABSTRACT_FROM  => 'lib/Text/Markdown/Discount.pm',
              AUTHOR         => 'Masayoshi Sekimura <sekimura@cpan.org>') : ()),
      -    LIBS               => '-L' . $extdir,
      -    INC               => '-I. -I' . $extdir,
      -    MYEXTLIB          => $myextlib,
      -    clean             => { FILES => $clean_files },
      +    LIBS               => '-lmarkdown',
      +    INC               => '-I.',
      +
           META_MERGE => {
               'meta-spec' => { version => 2 },
               resources => {
    name: use-system-markdown.patch
    opt: -p1
perl-Tk:
  '804.036':
  - content: |
      --- pTk/mTk/generic/tkBind.c
      +++ pTk/mTk/generic/tkBind.c
      @@ -550,89 +550,86 @@
       #define CIRCREQ			0x400000
       
       char *eventTypeName[TK_LASTEVENT] = {
      -   NULL,
      -   NULL,
      -   "KeyPress",
      -   "KeyRelease",
      -   "ButtonPress",
      -   "ButtonRelease",
      -   "MotionNotify",
      -   "EnterNotify",
      -   "LeaveNotify",
      -   "FocusIn",
      -   "FocusOut",
      -   "KeymapNotify",
      -   "Expose",
      -   "GraphicsExpose",
      -   "NoExpose",
      -   "VisibilityNotify",
      -   "CreateNotify",
      -   "DestroyNotify",
      -   "UnmapNotify",
      -   "MapNotify",
      -   "MapRequest",
      -   "ReparentNotify",
      -   "ConfigureNotify",
      -   "ConfigureRequest",
      -   "GravityNotify",
      -   "ResizeRequest",
      -   "CirculateNotify",
      -   "CirculateRequest",
      -   "PropertyNotify",
      -   "SelectionClear",
      -   "SelectionRequest",
      -   "SelectionNotify",
      -   "ColormapNotify",
      -   "ClientMessage",
      -   "MappingNotify",
      -   "VirtualEvent",
      -   "Activate",
      -   "Deactivate"
      +   [KeyPress] =	"KeyPress",
      +   [KeyRelease] =	"KeyRelease",
      +   [ButtonPress] =	"ButtonPress",
      +   [ButtonRelease] =	"ButtonRelease",
      +   [MotionNotify] =	"MotionNotify",
      +   [EnterNotify] =	"EnterNotify",
      +   [LeaveNotify] =	"LeaveNotify",
      +   [FocusIn] =		"FocusIn",
      +   [FocusOut] =	"FocusOut",
      +   [KeymapNotify] =	"KeymapNotify",
      +   [Expose] =		"Expose",
      +   [GraphicsExpose] =	"GraphicsExpose",
      +   [NoExpose] =	"NoExpose",
      +   [VisibilityNotify] ="VisibilityNotify",
      +   [CreateNotify] =	"CreateNotify",
      +   [DestroyNotify] =	"DestroyNotify",
      +   [UnmapNotify] =	"UnmapNotify",
      +   [MapNotify] =	"MapNotify",
      +   [MapRequest] =	"MapRequest",
      +   [ReparentNotify] =	"ReparentNotify",
      +   [ConfigureNotify] =	"ConfigureNotify",
      +   [ConfigureRequest] ="ConfigureRequest",
      +   [GravityNotify] =	"GravityNotify",
      +   [ResizeRequest] =	"ResizeRequest",
      +   [CirculateNotify] =	"CirculateNotify",
      +   [CirculateRequest] ="CirculateRequest",
      +   [PropertyNotify] =	"PropertyNotify",
      +   [SelectionClear] =	"SelectionClear",
      +   [SelectionRequest] ="SelectionRequest",
      +   [SelectionNotify] =	"SelectionNotify",
      +   [ColormapNotify] =	"ColormapNotify",
      +   [ClientMessage] =	"ClientMessage",
      +   [MappingNotify] =	"MappingNotify",
      +   [VirtualEvent] =	"VirtualEvent",
      +   [ActivateNotify] =	"Activate",
      +   [DeactivateNotify] ="Deactivate"
       };
       
       #define KEY_BUTTON_MOTION_VIRTUAL	(KEY|BUTTON|MOTION|VIRTUAL)
       #define KEY_BUTTON_MOTION_CROSSING	(KEY|BUTTON|MOTION|CROSSING|VIRTUAL)
       
       static int flagArray[TK_LASTEVENT] = {
      -   /* Not used */		0,
      -   /* Not used */		0,
      -   /* KeyPress */		KEY,
      -   /* KeyRelease */		KEY,
      -   /* ButtonPress */		BUTTON,
      -   /* ButtonRelease */		BUTTON,
      -   /* MotionNotify */		MOTION,
      -   /* EnterNotify */		CROSSING,
      -   /* LeaveNotify */		CROSSING,
      -   /* FocusIn */		FOCUS,
      -   /* FocusOut */		FOCUS,
      -   /* KeymapNotify */		0,
      -   /* Expose */			EXPOSE,
      -   /* GraphicsExpose */		EXPOSE,
      -   /* NoExpose */		0,
      -   /* VisibilityNotify */	VISIBILITY,
      -   /* CreateNotify */		CREATE,
      -   /* DestroyNotify */		DESTROY,
      -   /* UnmapNotify */		UNMAP,
      -   /* MapNotify */		MAP,
      -   /* MapRequest */		MAPREQ,
      -   /* ReparentNotify */		REPARENT,
      -   /* ConfigureNotify */	CONFIG,
      -   /* ConfigureRequest */	CONFIGREQ,
      -   /* GravityNotify */		GRAVITY,
      -   /* ResizeRequest */		RESIZEREQ,
      -   /* CirculateNotify */	CIRC,
      -   /* CirculateRequest */	0,
      -   /* PropertyNotify */		PROP,
      -   /* SelectionClear */		0,
      -   /* SelectionRequest */	0,
      -   /* SelectionNotify */	0,
      -   /* ColormapNotify */		COLORMAP,
      -   /* ClientMessage */		0,
      -   /* MappingNotify */		0,
      -   /* VirtualEvent */		VIRTUAL,
      -   /* Activate */		ACTIVATE,
      -   /* Deactivate */		ACTIVATE,
      -   /* MouseWheel */		KEY
      +
      +   [KeyPress] =		KEY,
      +   [KeyRelease] =		KEY,
      +   [ButtonPress] =		BUTTON,
      +   [ButtonRelease] =		BUTTON,
      +   [MotionNotify] =		MOTION,
      +   [EnterNotify] =		CROSSING,
      +   [LeaveNotify] =		CROSSING,
      +   [FocusIn] =			FOCUS,
      +   [FocusOut] =		FOCUS,
      +   [KeymapNotify] =		0,
      +   [Expose] =			EXPOSE,
      +   [GraphicsExpose] =		EXPOSE,
      +   [NoExpose] =		0,
      +   [VisibilityNotify] =	VISIBILITY,
      +   [CreateNotify] =		CREATE,
      +   [DestroyNotify] =		DESTROY,
      +   [UnmapNotify] =		UNMAP,
      +   [MapNotify] =		MAP,
      +   [MapRequest] =		MAPREQ,
      +   [ReparentNotify] =		REPARENT,
      +   [ConfigureNotify] =		CONFIG,
      +   [ConfigureRequest] =	CONFIGREQ,
      +   [GravityNotify] =		GRAVITY,
      +   [ResizeRequest] =		RESIZEREQ,
      +   [CirculateNotify] =		CIRC,
      +   [CirculateRequest] =	0,
      +   [PropertyNotify] =		PROP,
      +   [SelectionClear] =		0,
      +   [SelectionRequest] =	0,
      +   [SelectionNotify] =		0,
      +   [ColormapNotify] =		COLORMAP,
      +   [ClientMessage] =		0,
      +   [MappingNotify] =		0,
      +   [VirtualEvent] =		VIRTUAL,
      +   [ActivateNotify] =		ACTIVATE,
      +   [DeactivateNotify] =	ACTIVATE,
      +   [MouseWheelEvent] =		KEY
       };
       
       /*
    name: Tk-804.029-event.diff
    opt: -p0
  - content: |
      --- objGlue.c
      +++ objGlue.c
      @@ -393,7 +393,7 @@
               */
              if (SvREFCNT(sv) <= 0 || SvTEMP(sv))
               {
      -         LangDebug("%s %d:\n",__FUNCTION__, objc);
      +         LangDebug("%s %d:\n", __func__, objc); 
                sv_dump(sv);
               }
              av_store(av,objc,sv);
      --- tkGlue.c
      +++ tkGlue.c
      @@ -201,7 +201,7 @@
         ( Tcl_SprintfResult args, Expire(TCL_ERROR) )
       
       #ifdef DEBUG_TAINT
      -#define do_watch() do { if (PL_tainting) taint_proper("tainted", __FUNCTION__); } while (0)
      +#define do_watch() do { static const char *f = __func__; if (PL_tainting) taint_proper("tainted", f); } while (0)
       #else
       extern void do_watch _((void));
       void
      @@ -1248,7 +1248,7 @@
        result = Tcl_GetObjResult(interp);
        if (!count)
         {
      -   LangDebug("%s - No Results\n",__FUNCTION__);
      +  LangDebug("%s - No Results\n", __func__); 
          abort();
          Tcl_Panic("No results");
         }
      @@ -1548,7 +1548,7 @@
            SV *save = sv_2mortal(newSVsv(sv));
            s = SvPV(save, len);
       #if 0
      -     LangDebug("%s error:%.*s\n",__FUNCTION__,na,s);
      +     LangDebug("%s error:%.*s\n",__func__,na,s);
       #endif
            if (!interp)
             croak("%s",s);
      @@ -2009,7 +2009,7 @@
        int old_taint = PL_tainted;
        TAINT_NOT;
       #if 0
      - warn(__FUNCTION__);
      + warn("%s",__func__);
       #endif
        if (InterpHv(interp,0))
         {
      @@ -2477,7 +2477,7 @@
             */
            sv = newSVpvn(p, numItems);
       #if 0
      -     LangDebug("%s %d '%.*s'\n",__FUNCTION__,numItems,numItems,p);
      +     LangDebug("%s %d '%.*s'\n",__func__,numItems,numItems,p);
            LangDumpVec(strType,1,&sv);
            abort();
       #endif
      @@ -3223,7 +3223,7 @@
            /* Tk_CheckHash((SV *) hash, NULL); */
            if (SvREFCNT(hash) < 1)
             {
      -       LangDebug("%s %s has REFCNT=%d\n",__FUNCTION__,cmdName,(int) SvREFCNT(hash));
      +       LangDebug("%s %s has REFCNT=%d\n",__func__,cmdName,(int) SvREFCNT(hash));
              sv_dump(obj);
             }
       
      @@ -3290,7 +3290,7 @@
          /* Tk_CheckHash((SV *) hash, NULL); */
          if (SvREFCNT(hash) < 2)
           {
      -     LangDebug("%s %s has REFCNT=%d",__FUNCTION__,cmdName,(int) SvREFCNT(hash));
      +     LangDebug("%s %s has REFCNT=%d",__func__,cmdName,(int) SvREFCNT(hash));
           }
          SvREFCNT_dec(hash);
         }
    name: Tk-804.029-macro.diff
    opt: -p0
  - content: |
      --- pTk/mTk/unix/tkUnixXft.c
      +++ pTk/mTk/unix/tkUnixXft.c
      @@ -439,7 +439,7 @@
           resultPtr = Tcl_NewListObj(0, NULL);
       
           list = XftListFonts(Tk_Display(tkwin), Tk_ScreenNumber(tkwin), 0,
      -	    XFT_FAMILY, 0);
      +	    XFT_FAMILY, NULL);
           for (i = 0; i < list->nfont; i++) {
       	if (XftPatternGetString(list->fonts[i], XFT_FAMILY, 0,
       		&family) == XftResultMatch) {
    name: Tk-804.029-null.diff
    opt: -p0
  - content: |
      Index: pTk/mTk/unix/tkUnixXft.c
      ===================================================================
      --- pTk/mTk/unix/tkUnixXft.c.orig
      +++ pTk/mTk/unix/tkUnixXft.c
      @@ -165,6 +165,7 @@ InitFont(
       
           for (i = 0; i < set->nfont; i++) {
       	fontPtr->faces[i].ftFont = 0;
      +	FcPatternReference (set->fonts[i]);
       	fontPtr->faces[i].source = set->fonts[i];
       	if (FcPatternGetCharSet(set->fonts[i], FC_CHARSET, 0,
       		&charset) == FcResultMatch) {
    name: Tk-804.029-refcnt.diff
    opt: -p0
  - content: |
      From a26233c844c52f49ef9cca5f88dd9063aac60d0f Mon Sep 17 00:00:00 2001
      From: Niko Tyni <ntyni@debian.org>
      Date: Thu, 11 Jan 2024 18:28:58 +0000
      Subject: [PATCH] Fix STRLEN vs int pointer confusion in Tcl_GetByteArrayFromObj()

      Perl 5.37.2, more precisely commit

       https://github.com/Perl/perl5/commit/1ef9039bccbfe64f47f201b6cfb7d6d23e0b08a7

      changed the implementation of SvPV() et al., breaking t/balloon.t,
      t/canvas2.t and t/photo.t on big-endian 64-bit architectures such as
      ppc64 and s390x because StringMatchGIF() no longer recognized GIF files.

      This is because Tcl_GetByteArrayFromObj() was calling SvPV() with an int
      pointer instead of a correct STRLEN pointer, and the new implementation
      is more sensitive to this: it assigns the pointers as-is, resulting in
      the int pointer pointing at the wrong end of the 64-bit length.

      Other functions taking a length pointer, at least Tcl_GetStringFromObj()
      already seem to do things correctly, so presumably this is not a
      systematic issue.
      ---
       objGlue.c | 5 ++++-
       1 file changed, 4 insertions(+), 1 deletion(-)

      diff --git objGlue.c objGlue.c
      index d4927ea..dbd6a50 100644
      --- objGlue.c
      +++ objGlue.c
      @@ -627,7 +627,10 @@ Tcl_GetByteArrayFromObj(Tcl_Obj * objPtr, int * lengthPtr)
        sv_utf8_downgrade(objPtr, 0);
        if (lengthPtr)
         {
      -   return (unsigned char *) SvPV(objPtr, *lengthPtr);
      +   STRLEN len;
      +   unsigned char *s = SvPV(objPtr, len);
      +   *lengthPtr = len;
      +   return s;
         }
        else
         {
      -- 
      2.30.2
    name: Tk-804.036-fix-strlen-vs-int-pointer-confusion.patch
    opt: -p0
perl-UNIVERSAL-ref:
  '0.14':
  - content: |+
      From f56e531d9c4809a847845c2028eea55dfc1bae50 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Fri, 19 May 2017 13:55:15 +0200
      Subject: [PATCH] Fix building with Perl 5.25.1
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Perl 5.25.1 changed enabled PERL_OP_PARENT and that changed op_sibling
      semantics.

      This fix implements
      <https://rt.perl.org/Public/Bug/Display.html?id=128179#txn-1405910>.

      CPAN RT#118008

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      ---
       MANIFEST |    1 +
       ppport.h | 7908 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ref.xs   |    7 +-
       3 files changed, 7913 insertions(+), 3 deletions(-)
       create mode 100644 ppport.h

      diff --git a/MANIFEST b/MANIFEST
      index 1e1b328..15a46eb 100644
      --- a/MANIFEST
      +++ b/MANIFEST
      @@ -7,6 +7,7 @@ README
       dist.ini
       dist.ini~
       lib/UNIVERSAL/ref.pm
      +ppport.h
       ref.xs
       t/basic.t
       t/release-pod-coverage.t
      diff --git a/ppport.h b/ppport.h
      new file mode 100644
      index 0000000..68ec473
      --- /dev/null
      +++ b/ppport.h
      @@ -0,0 +1,7908 @@
      +#if 0
      +<<'SKIP';
      +#endif
      +/*
      +----------------------------------------------------------------------
      +
      +    ppport.h -- Perl/Pollution/Portability Version 3.36
      +
      +    Automatically created by Devel::PPPort running under perl 5.026000.
      +
      +    Do NOT edit this file directly! -- Edit PPPort_pm.PL and the
      +    includes in parts/inc/ instead.
      +
      +    Use 'perldoc ppport.h' to view the documentation below.
      +
      +----------------------------------------------------------------------
      +
      +SKIP
      +
      +=pod
      +
      +=head1 NAME
      +
      +ppport.h - Perl/Pollution/Portability version 3.36
      +
      +=head1 SYNOPSIS
      +
      +  perl ppport.h [options] [source files]
      +
      +  Searches current directory for files if no [source files] are given
      +
      +  --help                      show short help
      +
      +  --version                   show version
      +
      +  --patch=file                write one patch file with changes
      +  --copy=suffix               write changed copies with suffix
      +  --diff=program              use diff program and options
      +
      +  --compat-version=version    provide compatibility with Perl version
      +  --cplusplus                 accept C++ comments
      +
      +  --quiet                     don't output anything except fatal errors
      +  --nodiag                    don't show diagnostics
      +  --nohints                   don't show hints
      +  --nochanges                 don't suggest changes
      +  --nofilter                  don't filter input files
      +
      +  --strip                     strip all script and doc functionality from
      +                              ppport.h
      +
      +  --list-provided             list provided API
      +  --list-unsupported          list unsupported API
      +  --api-info=name             show Perl API portability information
      +
      +=head1 COMPATIBILITY
      +
      +This version of F<ppport.h> is designed to support operation with Perl
      +installations back to 5.003, and has been tested up to 5.20.
      +
      +=head1 OPTIONS
      +
      +=head2 --help
      +
      +Display a brief usage summary.
      +
      +=head2 --version
      +
      +Display the version of F<ppport.h>.
      +
      +=head2 --patch=I<file>
      +
      +If this option is given, a single patch file will be created if
      +any changes are suggested. This requires a working diff program
      +to be installed on your system.
      +
      +=head2 --copy=I<suffix>
      +
      +If this option is given, a copy of each file will be saved with
      +the given suffix that contains the suggested changes. This does
      +not require any external programs. Note that this does not
      +automagically add a dot between the original filename and the
      +suffix. If you want the dot, you have to include it in the option
      +argument.
      +
      +If neither C<--patch> or C<--copy> are given, the default is to
      +simply print the diffs for each file. This requires either
      +C<Text::Diff> or a C<diff> program to be installed.
      +
      +=head2 --diff=I<program>
      +
      +Manually set the diff program and options to use. The default
      +is to use C<Text::Diff>, when installed, and output unified
      +context diffs.
      +
      +=head2 --compat-version=I<version>
      +
      +Tell F<ppport.h> to check for compatibility with the given
      +Perl version. The default is to check for compatibility with Perl
      +version 5.003. You can use this option to reduce the output
      +of F<ppport.h> if you intend to be backward compatible only
      +down to a certain Perl version.
      +
      +=head2 --cplusplus
      +
      +Usually, F<ppport.h> will detect C++ style comments and
      +replace them with C style comments for portability reasons.
      +Using this option instructs F<ppport.h> to leave C++
      +comments untouched.
      +
      +=head2 --quiet
      +
      +Be quiet. Don't print anything except fatal errors.
      +
      +=head2 --nodiag
      +
      +Don't output any diagnostic messages. Only portability
      +alerts will be printed.
      +
      +=head2 --nohints
      +
      +Don't output any hints. Hints often contain useful portability
      +notes. Warnings will still be displayed.
      +
      +=head2 --nochanges
      +
      +Don't suggest any changes. Only give diagnostic output and hints
      +unless these are also deactivated.
      +
      +=head2 --nofilter
      +
      +Don't filter the list of input files. By default, files not looking
      +like source code (i.e. not *.xs, *.c, *.cc, *.cpp or *.h) are skipped.
      +
      +=head2 --strip
      +
      +Strip all script and documentation functionality from F<ppport.h>.
      +This reduces the size of F<ppport.h> dramatically and may be useful
      +if you want to include F<ppport.h> in smaller modules without
      +increasing their distribution size too much.
      +
      +The stripped F<ppport.h> will have a C<--unstrip> option that allows
      +you to undo the stripping, but only if an appropriate C<Devel::PPPort>
      +module is installed.
      +
      +=head2 --list-provided
      +
      +Lists the API elements for which compatibility is provided by
      +F<ppport.h>. Also lists if it must be explicitly requested,
      +if it has dependencies, and if there are hints or warnings for it.
      +
      +=head2 --list-unsupported
      +
      +Lists the API elements that are known not to be supported by
      +F<ppport.h> and below which version of Perl they probably
      +won't be available or work.
      +
      +=head2 --api-info=I<name>
      +
      +Show portability information for API elements matching I<name>.
      +If I<name> is surrounded by slashes, it is interpreted as a regular
      +expression.
      +
      +=head1 DESCRIPTION
      +
      +In order for a Perl extension (XS) module to be as portable as possible
      +across differing versions of Perl itself, certain steps need to be taken.
      +
      +=over 4
      +
      +=item *
      +
      +Including this header is the first major one. This alone will give you
      +access to a large part of the Perl API that hasn't been available in
      +earlier Perl releases. Use
      +
      +    perl ppport.h --list-provided
      +
      +to see which API elements are provided by ppport.h.
      +
      +=item *
      +
      +You should avoid using deprecated parts of the API. For example, using
      +global Perl variables without the C<PL_> prefix is deprecated. Also,
      +some API functions used to have a C<perl_> prefix. Using this form is
      +also deprecated. You can safely use the supported API, as F<ppport.h>
      +will provide wrappers for older Perl versions.
      +
      +=item *
      +
      +If you use one of a few functions or variables that were not present in
      +earlier versions of Perl, and that can't be provided using a macro, you
      +have to explicitly request support for these functions by adding one or
      +more C<#define>s in your source code before the inclusion of F<ppport.h>.
      +
      +These functions or variables will be marked C<explicit> in the list shown
      +by C<--list-provided>.
      +
      +Depending on whether you module has a single or multiple files that
      +use such functions or variables, you want either C<static> or global
      +variants.
      +
      +For a C<static> function or variable (used only in a single source
      +file), use:
      +
      +    #define NEED_function
      +    #define NEED_variable
      +
      +For a global function or variable (used in multiple source files),
      +use:
      +
      +    #define NEED_function_GLOBAL
      +    #define NEED_variable_GLOBAL
      +
      +Note that you mustn't have more than one global request for the
      +same function or variable in your project.
      +
      +    Function / Variable       Static Request               Global Request
      +    -----------------------------------------------------------------------------------------
      +    PL_parser                 NEED_PL_parser               NEED_PL_parser_GLOBAL
      +    PL_signals                NEED_PL_signals              NEED_PL_signals_GLOBAL
      +    SvRX()                    NEED_SvRX                    NEED_SvRX_GLOBAL
      +    caller_cx()               NEED_caller_cx               NEED_caller_cx_GLOBAL
      +    eval_pv()                 NEED_eval_pv                 NEED_eval_pv_GLOBAL
      +    grok_bin()                NEED_grok_bin                NEED_grok_bin_GLOBAL
      +    grok_hex()                NEED_grok_hex                NEED_grok_hex_GLOBAL
      +    grok_number()             NEED_grok_number             NEED_grok_number_GLOBAL
      +    grok_numeric_radix()      NEED_grok_numeric_radix      NEED_grok_numeric_radix_GLOBAL
      +    grok_oct()                NEED_grok_oct                NEED_grok_oct_GLOBAL
      +    gv_fetchpvn_flags()       NEED_gv_fetchpvn_flags       NEED_gv_fetchpvn_flags_GLOBAL
      +    load_module()             NEED_load_module             NEED_load_module_GLOBAL
      +    mg_findext()              NEED_mg_findext              NEED_mg_findext_GLOBAL
      +    my_snprintf()             NEED_my_snprintf             NEED_my_snprintf_GLOBAL
      +    my_sprintf()              NEED_my_sprintf              NEED_my_sprintf_GLOBAL
      +    my_strlcat()              NEED_my_strlcat              NEED_my_strlcat_GLOBAL
      +    my_strlcpy()              NEED_my_strlcpy              NEED_my_strlcpy_GLOBAL
      +    newCONSTSUB()             NEED_newCONSTSUB             NEED_newCONSTSUB_GLOBAL
      +    newRV_noinc()             NEED_newRV_noinc             NEED_newRV_noinc_GLOBAL
      +    newSV_type()              NEED_newSV_type              NEED_newSV_type_GLOBAL
      +    newSVpvn_flags()          NEED_newSVpvn_flags          NEED_newSVpvn_flags_GLOBAL
      +    newSVpvn_share()          NEED_newSVpvn_share          NEED_newSVpvn_share_GLOBAL
      +    pv_display()              NEED_pv_display              NEED_pv_display_GLOBAL
      +    pv_escape()               NEED_pv_escape               NEED_pv_escape_GLOBAL
      +    pv_pretty()               NEED_pv_pretty               NEED_pv_pretty_GLOBAL
      +    sv_2pv_flags()            NEED_sv_2pv_flags            NEED_sv_2pv_flags_GLOBAL
      +    sv_2pvbyte()              NEED_sv_2pvbyte              NEED_sv_2pvbyte_GLOBAL
      +    sv_catpvf_mg()            NEED_sv_catpvf_mg            NEED_sv_catpvf_mg_GLOBAL
      +    sv_catpvf_mg_nocontext()  NEED_sv_catpvf_mg_nocontext  NEED_sv_catpvf_mg_nocontext_GLOBAL
      +    sv_pvn_force_flags()      NEED_sv_pvn_force_flags      NEED_sv_pvn_force_flags_GLOBAL
      +    sv_setpvf_mg()            NEED_sv_setpvf_mg            NEED_sv_setpvf_mg_GLOBAL
      +    sv_setpvf_mg_nocontext()  NEED_sv_setpvf_mg_nocontext  NEED_sv_setpvf_mg_nocontext_GLOBAL
      +    sv_unmagicext()           NEED_sv_unmagicext           NEED_sv_unmagicext_GLOBAL
      +    vload_module()            NEED_vload_module            NEED_vload_module_GLOBAL
      +    vnewSVpvf()               NEED_vnewSVpvf               NEED_vnewSVpvf_GLOBAL
      +    warner()                  NEED_warner                  NEED_warner_GLOBAL
      +
      +To avoid namespace conflicts, you can change the namespace of the
      +explicitly exported functions / variables using the C<DPPP_NAMESPACE>
      +macro. Just C<#define> the macro before including C<ppport.h>:
      +
      +    #define DPPP_NAMESPACE MyOwnNamespace_
      +    #include "ppport.h"
      +
      +The default namespace is C<DPPP_>.
      +
      +=back
      +
      +The good thing is that most of the above can be checked by running
      +F<ppport.h> on your source code. See the next section for
      +details.
      +
      +=head1 EXAMPLES
      +
      +To verify whether F<ppport.h> is needed for your module, whether you
      +should make any changes to your code, and whether any special defines
      +should be used, F<ppport.h> can be run as a Perl script to check your
      +source code. Simply say:
      +
      +    perl ppport.h
      +
      +The result will usually be a list of patches suggesting changes
      +that should at least be acceptable, if not necessarily the most
      +efficient solution, or a fix for all possible problems.
      +
      +If you know that your XS module uses features only available in
      +newer Perl releases, if you're aware that it uses C++ comments,
      +and if you want all suggestions as a single patch file, you could
      +use something like this:
      +
      +    perl ppport.h --compat-version=5.6.0 --cplusplus --patch=test.diff
      +
      +If you only want your code to be scanned without any suggestions
      +for changes, use:
      +
      +    perl ppport.h --nochanges
      +
      +You can specify a different C<diff> program or options, using
      +the C<--diff> option:
      +
      +    perl ppport.h --diff='diff -C 10'
      +
      +This would output context diffs with 10 lines of context.
      +
      +If you want to create patched copies of your files instead, use:
      +
      +    perl ppport.h --copy=.new
      +
      +To display portability information for the C<newSVpvn> function,
      +use:
      +
      +    perl ppport.h --api-info=newSVpvn
      +
      +Since the argument to C<--api-info> can be a regular expression,
      +you can use
      +
      +    perl ppport.h --api-info=/_nomg$/
      +
      +to display portability information for all C<_nomg> functions or
      +
      +    perl ppport.h --api-info=/./
      +
      +to display information for all known API elements.
      +
      +=head1 BUGS
      +
      +If this version of F<ppport.h> is causing failure during
      +the compilation of this module, please check if newer versions
      +of either this module or C<Devel::PPPort> are available on CPAN
      +before sending a bug report.
      +
      +If F<ppport.h> was generated using the latest version of
      +C<Devel::PPPort> and is causing failure of this module, please
      +file a bug report here: L<https://github.com/mhx/Devel-PPPort/issues/>
      +
      +Please include the following information:
      +
      +=over 4
      +
      +=item 1.
      +
      +The complete output from running "perl -V"
      +
      +=item 2.
      +
      +This file.
      +
      +=item 3.
      +
      +The name and version of the module you were trying to build.
      +
      +=item 4.
      +
      +A full log of the build that failed.
      +
      +=item 5.
      +
      +Any other information that you think could be relevant.
      +
      +=back
      +
      +For the latest version of this code, please get the C<Devel::PPPort>
      +module from CPAN.
      +
      +=head1 COPYRIGHT
      +
      +Version 3.x, Copyright (c) 2004-2013, Marcus Holland-Moritz.
      +
      +Version 2.x, Copyright (C) 2001, Paul Marquess.
      +
      +Version 1.x, Copyright (C) 1999, Kenneth Albanowski.
      +
      +This program is free software; you can redistribute it and/or
      +modify it under the same terms as Perl itself.
      +
      +=head1 SEE ALSO
      +
      +See L<Devel::PPPort>.
      +
      +=cut
      +
      +use strict;
      +
      +# Disable broken TRIE-optimization
      +BEGIN { eval '${^RE_TRIE_MAXBUF} = -1' if $] >= 5.009004 && $] <= 5.009005 }
      +
      +my $VERSION = 3.36;
      +
      +my %opt = (
      +  quiet     => 0,
      +  diag      => 1,
      +  hints     => 1,
      +  changes   => 1,
      +  cplusplus => 0,
      +  filter    => 1,
      +  strip     => 0,
      +  version   => 0,
      +);
      +
      +my($ppport) = $0 =~ /([\w.]+)$/;
      +my $LF = '(?:\r\n|[\r\n])';   # line feed
      +my $HS = "[ \t]";             # horizontal whitespace
      +
      +# Never use C comments in this file!
      +my $ccs  = '/'.'*';
      +my $cce  = '*'.'/';
      +my $rccs = quotemeta $ccs;
      +my $rcce = quotemeta $cce;
      +
      +eval {
      +  require Getopt::Long;
      +  Getopt::Long::GetOptions(\%opt, qw(
      +    help quiet diag! filter! hints! changes! cplusplus strip version
      +    patch=s copy=s diff=s compat-version=s
      +    list-provided list-unsupported api-info=s
      +  )) or usage();
      +};
      +
      +if ($@ and grep /^-/, @ARGV) {
      +  usage() if "@ARGV" =~ /^--?h(?:elp)?$/;
      +  die "Getopt::Long not found. Please don't use any options.\n";
      +}
      +
      +if ($opt{version}) {
      +  print "This is $0 $VERSION.\n";
      +  exit 0;
      +}
      +
      +usage() if $opt{help};
      +strip() if $opt{strip};
      +
      +if (exists $opt{'compat-version'}) {
      +  my($r,$v,$s) = eval { parse_version($opt{'compat-version'}) };
      +  if ($@) {
      +    die "Invalid version number format: '$opt{'compat-version'}'\n";
      +  }
      +  die "Only Perl 5 is supported\n" if $r != 5;
      +  die "Invalid version number: $opt{'compat-version'}\n" if $v >= 1000 || $s >= 1000;
      +  $opt{'compat-version'} = sprintf "%d.%03d%03d", $r, $v, $s;
      +}
      +else {
      +  $opt{'compat-version'} = 5;
      +}
      +
      +my %API = map { /^(\w+)\|([^|]*)\|([^|]*)\|(\w*)$/
      +                ? ( $1 => {
      +                      ($2                  ? ( base     => $2 ) : ()),
      +                      ($3                  ? ( todo     => $3 ) : ()),
      +                      (index($4, 'v') >= 0 ? ( varargs  => 1  ) : ()),
      +                      (index($4, 'p') >= 0 ? ( provided => 1  ) : ()),
      +                      (index($4, 'n') >= 0 ? ( nothxarg => 1  ) : ()),
      +                    } )
      +                : die "invalid spec: $_" } qw(
      +ASCII_TO_NEED||5.007001|n
      +AvFILLp|5.004050||p
      +AvFILL|||
      +BhkDISABLE||5.024000|
      +BhkENABLE||5.024000|
      +BhkENTRY_set||5.024000|
      +BhkENTRY|||
      +BhkFLAGS|||
      +CALL_BLOCK_HOOKS|||
      +CLASS|||n
      +CPERLscope|5.005000||p
      +CX_CURPAD_SAVE|||
      +CX_CURPAD_SV|||
      +C_ARRAY_END|5.013002||p
      +C_ARRAY_LENGTH|5.008001||p
      +CopFILEAV|5.006000||p
      +CopFILEGV_set|5.006000||p
      +CopFILEGV|5.006000||p
      +CopFILESV|5.006000||p
      +CopFILE_set|5.006000||p
      +CopFILE|5.006000||p
      +CopSTASHPV_set|5.006000||p
      +CopSTASHPV|5.006000||p
      +CopSTASH_eq|5.006000||p
      +CopSTASH_set|5.006000||p
      +CopSTASH|5.006000||p
      +CopyD|5.009002|5.004050|p
      +Copy|||
      +CvPADLIST||5.008001|
      +CvSTASH|||
      +CvWEAKOUTSIDE|||
      +DECLARATION_FOR_LC_NUMERIC_MANIPULATION||5.021010|n
      +DEFSV_set|5.010001||p
      +DEFSV|5.004050||p
      +DO_UTF8||5.006000|
      +END_EXTERN_C|5.005000||p
      +ENTER|||
      +ERRSV|5.004050||p
      +EXTEND|||
      +EXTERN_C|5.005000||p
      +F0convert|||n
      +FREETMPS|||
      +GIMME_V||5.004000|n
      +GIMME|||n
      +GROK_NUMERIC_RADIX|5.007002||p
      +G_ARRAY|||
      +G_DISCARD|||
      +G_EVAL|||
      +G_METHOD|5.006001||p
      +G_NOARGS|||
      +G_SCALAR|||
      +G_VOID||5.004000|
      +GetVars|||
      +GvAV|||
      +GvCV|||
      +GvHV|||
      +GvSV|||
      +Gv_AMupdate||5.011000|
      +HEf_SVKEY|5.003070||p
      +HeHASH||5.003070|
      +HeKEY||5.003070|
      +HeKLEN||5.003070|
      +HePV||5.004000|
      +HeSVKEY_force||5.003070|
      +HeSVKEY_set||5.004000|
      +HeSVKEY||5.003070|
      +HeUTF8|5.010001|5.008000|p
      +HeVAL||5.003070|
      +HvENAMELEN||5.015004|
      +HvENAMEUTF8||5.015004|
      +HvENAME||5.013007|
      +HvNAMELEN_get|5.009003||p
      +HvNAMELEN||5.015004|
      +HvNAMEUTF8||5.015004|
      +HvNAME_get|5.009003||p
      +HvNAME|||
      +INT2PTR|5.006000||p
      +IN_LOCALE_COMPILETIME|5.007002||p
      +IN_LOCALE_RUNTIME|5.007002||p
      +IN_LOCALE|5.007002||p
      +IN_PERL_COMPILETIME|5.008001||p
      +IS_NUMBER_GREATER_THAN_UV_MAX|5.007002||p
      +IS_NUMBER_INFINITY|5.007002||p
      +IS_NUMBER_IN_UV|5.007002||p
      +IS_NUMBER_NAN|5.007003||p
      +IS_NUMBER_NEG|5.007002||p
      +IS_NUMBER_NOT_INT|5.007002||p
      +IVSIZE|5.006000||p
      +IVTYPE|5.006000||p
      +IVdf|5.006000||p
      +LEAVE|||
      +LINKLIST||5.013006|
      +LVRET|||
      +MARK|||
      +MULTICALL||5.024000|
      +MUTABLE_PTR|5.010001||p
      +MUTABLE_SV|5.010001||p
      +MY_CXT_CLONE|5.009002||p
      +MY_CXT_INIT|5.007003||p
      +MY_CXT|5.007003||p
      +MoveD|5.009002|5.004050|p
      +Move|||
      +NATIVE_TO_NEED||5.007001|n
      +NOOP|5.005000||p
      +NUM2PTR|5.006000||p
      +NVTYPE|5.006000||p
      +NVef|5.006001||p
      +NVff|5.006001||p
      +NVgf|5.006001||p
      +Newxc|5.009003||p
      +Newxz|5.009003||p
      +Newx|5.009003||p
      +Nullav|||
      +Nullch|||
      +Nullcv|||
      +Nullhv|||
      +Nullsv|||
      +OP_CLASS||5.013007|
      +OP_DESC||5.007003|
      +OP_NAME||5.007003|
      +OP_TYPE_IS_OR_WAS||5.019010|
      +OP_TYPE_IS||5.019007|
      +ORIGMARK|||
      +OpHAS_SIBLING|5.021007||p
      +OpLASTSIB_set|5.021011||p
      +OpMAYBESIB_set|5.021011||p
      +OpMORESIB_set|5.021011||p
      +OpSIBLING|5.021007||p
      +PAD_BASE_SV|||
      +PAD_CLONE_VARS|||
      +PAD_COMPNAME_FLAGS|||
      +PAD_COMPNAME_GEN_set|||
      +PAD_COMPNAME_GEN|||
      +PAD_COMPNAME_OURSTASH|||
      +PAD_COMPNAME_PV|||
      +PAD_COMPNAME_TYPE|||
      +PAD_RESTORE_LOCAL|||
      +PAD_SAVE_LOCAL|||
      +PAD_SAVE_SETNULLPAD|||
      +PAD_SETSV|||
      +PAD_SET_CUR_NOSAVE|||
      +PAD_SET_CUR|||
      +PAD_SVl|||
      +PAD_SV|||
      +PERLIO_FUNCS_CAST|5.009003||p
      +PERLIO_FUNCS_DECL|5.009003||p
      +PERL_ABS|5.008001||p
      +PERL_BCDVERSION|5.024000||p
      +PERL_GCC_BRACE_GROUPS_FORBIDDEN|5.008001||p
      +PERL_HASH|5.003070||p
      +PERL_INT_MAX|5.003070||p
      +PERL_INT_MIN|5.003070||p
      +PERL_LONG_MAX|5.003070||p
      +PERL_LONG_MIN|5.003070||p
      +PERL_MAGIC_arylen|5.007002||p
      +PERL_MAGIC_backref|5.007002||p
      +PERL_MAGIC_bm|5.007002||p
      +PERL_MAGIC_collxfrm|5.007002||p
      +PERL_MAGIC_dbfile|5.007002||p
      +PERL_MAGIC_dbline|5.007002||p
      +PERL_MAGIC_defelem|5.007002||p
      +PERL_MAGIC_envelem|5.007002||p
      +PERL_MAGIC_env|5.007002||p
      +PERL_MAGIC_ext|5.007002||p
      +PERL_MAGIC_fm|5.007002||p
      +PERL_MAGIC_glob|5.024000||p
      +PERL_MAGIC_isaelem|5.007002||p
      +PERL_MAGIC_isa|5.007002||p
      +PERL_MAGIC_mutex|5.024000||p
      +PERL_MAGIC_nkeys|5.007002||p
      +PERL_MAGIC_overload_elem|5.024000||p
      +PERL_MAGIC_overload_table|5.007002||p
      +PERL_MAGIC_overload|5.024000||p
      +PERL_MAGIC_pos|5.007002||p
      +PERL_MAGIC_qr|5.007002||p
      +PERL_MAGIC_regdata|5.007002||p
      +PERL_MAGIC_regdatum|5.007002||p
      +PERL_MAGIC_regex_global|5.007002||p
      +PERL_MAGIC_shared_scalar|5.007003||p
      +PERL_MAGIC_shared|5.007003||p
      +PERL_MAGIC_sigelem|5.007002||p
      +PERL_MAGIC_sig|5.007002||p
      +PERL_MAGIC_substr|5.007002||p
      +PERL_MAGIC_sv|5.007002||p
      +PERL_MAGIC_taint|5.007002||p
      +PERL_MAGIC_tiedelem|5.007002||p
      +PERL_MAGIC_tiedscalar|5.007002||p
      +PERL_MAGIC_tied|5.007002||p
      +PERL_MAGIC_utf8|5.008001||p
      +PERL_MAGIC_uvar_elem|5.007003||p
      +PERL_MAGIC_uvar|5.007002||p
      +PERL_MAGIC_vec|5.007002||p
      +PERL_MAGIC_vstring|5.008001||p
      +PERL_PV_ESCAPE_ALL|5.009004||p
      +PERL_PV_ESCAPE_FIRSTCHAR|5.009004||p
      +PERL_PV_ESCAPE_NOBACKSLASH|5.009004||p
      +PERL_PV_ESCAPE_NOCLEAR|5.009004||p
      +PERL_PV_ESCAPE_QUOTE|5.009004||p
      +PERL_PV_ESCAPE_RE|5.009005||p
      +PERL_PV_ESCAPE_UNI_DETECT|5.009004||p
      +PERL_PV_ESCAPE_UNI|5.009004||p
      +PERL_PV_PRETTY_DUMP|5.009004||p
      +PERL_PV_PRETTY_ELLIPSES|5.010000||p
      +PERL_PV_PRETTY_LTGT|5.009004||p
      +PERL_PV_PRETTY_NOCLEAR|5.010000||p
      +PERL_PV_PRETTY_QUOTE|5.009004||p
      +PERL_PV_PRETTY_REGPROP|5.009004||p
      +PERL_QUAD_MAX|5.003070||p
      +PERL_QUAD_MIN|5.003070||p
      +PERL_REVISION|5.006000||p
      +PERL_SCAN_ALLOW_UNDERSCORES|5.007003||p
      +PERL_SCAN_DISALLOW_PREFIX|5.007003||p
      +PERL_SCAN_GREATER_THAN_UV_MAX|5.007003||p
      +PERL_SCAN_SILENT_ILLDIGIT|5.008001||p
      +PERL_SHORT_MAX|5.003070||p
      +PERL_SHORT_MIN|5.003070||p
      +PERL_SIGNALS_UNSAFE_FLAG|5.008001||p
      +PERL_SUBVERSION|5.006000||p
      +PERL_SYS_INIT3||5.006000|
      +PERL_SYS_INIT|||
      +PERL_SYS_TERM||5.024000|
      +PERL_UCHAR_MAX|5.003070||p
      +PERL_UCHAR_MIN|5.003070||p
      +PERL_UINT_MAX|5.003070||p
      +PERL_UINT_MIN|5.003070||p
      +PERL_ULONG_MAX|5.003070||p
      +PERL_ULONG_MIN|5.003070||p
      +PERL_UNUSED_ARG|5.009003||p
      +PERL_UNUSED_CONTEXT|5.009004||p
      +PERL_UNUSED_DECL|5.007002||p
      +PERL_UNUSED_RESULT|5.021001||p
      +PERL_UNUSED_VAR|5.007002||p
      +PERL_UQUAD_MAX|5.003070||p
      +PERL_UQUAD_MIN|5.003070||p
      +PERL_USE_GCC_BRACE_GROUPS|5.009004||p
      +PERL_USHORT_MAX|5.003070||p
      +PERL_USHORT_MIN|5.003070||p
      +PERL_VERSION|5.006000||p
      +PL_DBsignal|5.005000||p
      +PL_DBsingle|||pn
      +PL_DBsub|||pn
      +PL_DBtrace|||pn
      +PL_Sv|5.005000||p
      +PL_bufend|5.024000||p
      +PL_bufptr|5.024000||p
      +PL_check||5.006000|
      +PL_compiling|5.004050||p
      +PL_comppad_name||5.017004|
      +PL_comppad||5.008001|
      +PL_copline|5.024000||p
      +PL_curcop|5.004050||p
      +PL_curpad||5.005000|
      +PL_curstash|5.004050||p
      +PL_debstash|5.004050||p
      +PL_defgv|5.004050||p
      +PL_diehook|5.004050||p
      +PL_dirty|5.004050||p
      +PL_dowarn|||pn
      +PL_errgv|5.004050||p
      +PL_error_count|5.024000||p
      +PL_expect|5.024000||p
      +PL_hexdigit|5.005000||p
      +PL_hints|5.005000||p
      +PL_in_my_stash|5.024000||p
      +PL_in_my|5.024000||p
      +PL_keyword_plugin||5.011002|
      +PL_last_in_gv|||n
      +PL_laststatval|5.005000||p
      +PL_lex_state|5.024000||p
      +PL_lex_stuff|5.024000||p
      +PL_linestr|5.024000||p
      +PL_modglobal||5.005000|n
      +PL_na|5.004050||pn
      +PL_no_modify|5.006000||p
      +PL_ofsgv|||n
      +PL_opfreehook||5.011000|n
      +PL_parser|5.009005||p
      +PL_peepp||5.007003|n
      +PL_perl_destruct_level|5.004050||p
      +PL_perldb|5.004050||p
      +PL_ppaddr|5.006000||p
      +PL_rpeepp||5.013005|n
      +PL_rsfp_filters|5.024000||p
      +PL_rsfp|5.024000||p
      +PL_rs|||n
      +PL_signals|5.008001||p
      +PL_stack_base|5.004050||p
      +PL_stack_sp|5.004050||p
      +PL_statcache|5.005000||p
      +PL_stdingv|5.004050||p
      +PL_sv_arenaroot|5.004050||p
      +PL_sv_no|5.004050||pn
      +PL_sv_undef|5.004050||pn
      +PL_sv_yes|5.004050||pn
      +PL_tainted|5.004050||p
      +PL_tainting|5.004050||p
      +PL_tokenbuf|5.024000||p
      +POP_MULTICALL||5.024000|
      +POPi|||n
      +POPl|||n
      +POPn|||n
      +POPpbytex||5.007001|n
      +POPpx||5.005030|n
      +POPp|||n
      +POPs|||n
      +POPul||5.006000|n
      +POPu||5.004000|n
      +PTR2IV|5.006000||p
      +PTR2NV|5.006000||p
      +PTR2UV|5.006000||p
      +PTR2nat|5.009003||p
      +PTR2ul|5.007001||p
      +PTRV|5.006000||p
      +PUSHMARK|||
      +PUSH_MULTICALL||5.024000|
      +PUSHi|||
      +PUSHmortal|5.009002||p
      +PUSHn|||
      +PUSHp|||
      +PUSHs|||
      +PUSHu|5.004000||p
      +PUTBACK|||
      +PadARRAY||5.024000|
      +PadMAX||5.024000|
      +PadlistARRAY||5.024000|
      +PadlistMAX||5.024000|
      +PadlistNAMESARRAY||5.024000|
      +PadlistNAMESMAX||5.024000|
      +PadlistNAMES||5.024000|
      +PadlistREFCNT||5.017004|
      +PadnameIsOUR|||
      +PadnameIsSTATE|||
      +PadnameLEN||5.024000|
      +PadnameOURSTASH|||
      +PadnameOUTER|||
      +PadnamePV||5.024000|
      +PadnameREFCNT_dec||5.024000|
      +PadnameREFCNT||5.024000|
      +PadnameSV||5.024000|
      +PadnameTYPE|||
      +PadnameUTF8||5.021007|
      +PadnamelistARRAY||5.024000|
      +PadnamelistMAX||5.024000|
      +PadnamelistREFCNT_dec||5.024000|
      +PadnamelistREFCNT||5.024000|
      +PerlIO_clearerr||5.007003|
      +PerlIO_close||5.007003|
      +PerlIO_context_layers||5.009004|
      +PerlIO_eof||5.007003|
      +PerlIO_error||5.007003|
      +PerlIO_fileno||5.007003|
      +PerlIO_fill||5.007003|
      +PerlIO_flush||5.007003|
      +PerlIO_get_base||5.007003|
      +PerlIO_get_bufsiz||5.007003|
      +PerlIO_get_cnt||5.007003|
      +PerlIO_get_ptr||5.007003|
      +PerlIO_read||5.007003|
      +PerlIO_restore_errno|||
      +PerlIO_save_errno|||
      +PerlIO_seek||5.007003|
      +PerlIO_set_cnt||5.007003|
      +PerlIO_set_ptrcnt||5.007003|
      +PerlIO_setlinebuf||5.007003|
      +PerlIO_stderr||5.007003|
      +PerlIO_stdin||5.007003|
      +PerlIO_stdout||5.007003|
      +PerlIO_tell||5.007003|
      +PerlIO_unread||5.007003|
      +PerlIO_write||5.007003|
      +Perl_signbit||5.009005|n
      +PoisonFree|5.009004||p
      +PoisonNew|5.009004||p
      +PoisonWith|5.009004||p
      +Poison|5.008000||p
      +READ_XDIGIT||5.017006|
      +RESTORE_LC_NUMERIC||5.024000|
      +RETVAL|||n
      +Renewc|||
      +Renew|||
      +SAVECLEARSV|||
      +SAVECOMPPAD|||
      +SAVEPADSV|||
      +SAVETMPS|||
      +SAVE_DEFSV|5.004050||p
      +SPAGAIN|||
      +SP|||
      +START_EXTERN_C|5.005000||p
      +START_MY_CXT|5.007003||p
      +STMT_END|||p
      +STMT_START|||p
      +STORE_LC_NUMERIC_FORCE_TO_UNDERLYING||5.024000|
      +STORE_LC_NUMERIC_SET_TO_NEEDED||5.024000|
      +STR_WITH_LEN|5.009003||p
      +ST|||
      +SV_CONST_RETURN|5.009003||p
      +SV_COW_DROP_PV|5.008001||p
      +SV_COW_SHARED_HASH_KEYS|5.009005||p
      +SV_GMAGIC|5.007002||p
      +SV_HAS_TRAILING_NUL|5.009004||p
      +SV_IMMEDIATE_UNREF|5.007001||p
      +SV_MUTABLE_RETURN|5.009003||p
      +SV_NOSTEAL|5.009002||p
      +SV_SMAGIC|5.009003||p
      +SV_UTF8_NO_ENCODING|5.008001||p
      +SVfARG|5.009005||p
      +SVf_UTF8|5.006000||p
      +SVf|5.006000||p
      +SVt_INVLIST||5.019002|
      +SVt_IV|||
      +SVt_NULL|||
      +SVt_NV|||
      +SVt_PVAV|||
      +SVt_PVCV|||
      +SVt_PVFM|||
      +SVt_PVGV|||
      +SVt_PVHV|||
      +SVt_PVIO|||
      +SVt_PVIV|||
      +SVt_PVLV|||
      +SVt_PVMG|||
      +SVt_PVNV|||
      +SVt_PV|||
      +SVt_REGEXP||5.011000|
      +Safefree|||
      +Slab_Alloc|||
      +Slab_Free|||
      +Slab_to_ro|||
      +Slab_to_rw|||
      +StructCopy|||
      +SvCUR_set|||
      +SvCUR|||
      +SvEND|||
      +SvGAMAGIC||5.006001|
      +SvGETMAGIC|5.004050||p
      +SvGROW|||
      +SvIOK_UV||5.006000|
      +SvIOK_notUV||5.006000|
      +SvIOK_off|||
      +SvIOK_only_UV||5.006000|
      +SvIOK_only|||
      +SvIOK_on|||
      +SvIOKp|||
      +SvIOK|||
      +SvIVX|||
      +SvIV_nomg|5.009001||p
      +SvIV_set|||
      +SvIVx|||
      +SvIV|||
      +SvIsCOW_shared_hash||5.008003|
      +SvIsCOW||5.008003|
      +SvLEN_set|||
      +SvLEN|||
      +SvLOCK||5.007003|
      +SvMAGIC_set|5.009003||p
      +SvNIOK_off|||
      +SvNIOKp|||
      +SvNIOK|||
      +SvNOK_off|||
      +SvNOK_only|||
      +SvNOK_on|||
      +SvNOKp|||
      +SvNOK|||
      +SvNVX|||
      +SvNV_nomg||5.013002|
      +SvNV_set|||
      +SvNVx|||
      +SvNV|||
      +SvOK|||
      +SvOOK_offset||5.011000|
      +SvOOK|||
      +SvPOK_off|||
      +SvPOK_only_UTF8||5.006000|
      +SvPOK_only|||
      +SvPOK_on|||
      +SvPOKp|||
      +SvPOK|||
      +SvPVX_const|5.009003||p
      +SvPVX_mutable|5.009003||p
      +SvPVX|||
      +SvPV_const|5.009003||p
      +SvPV_flags_const_nolen|5.009003||p
      +SvPV_flags_const|5.009003||p
      +SvPV_flags_mutable|5.009003||p
      +SvPV_flags|5.007002||p
      +SvPV_force_flags_mutable|5.009003||p
      +SvPV_force_flags_nolen|5.009003||p
      +SvPV_force_flags|5.007002||p
      +SvPV_force_mutable|5.009003||p
      +SvPV_force_nolen|5.009003||p
      +SvPV_force_nomg_nolen|5.009003||p
      +SvPV_force_nomg|5.007002||p
      +SvPV_force|||p
      +SvPV_mutable|5.009003||p
      +SvPV_nolen_const|5.009003||p
      +SvPV_nolen|5.006000||p
      +SvPV_nomg_const_nolen|5.009003||p
      +SvPV_nomg_const|5.009003||p
      +SvPV_nomg_nolen|5.013007||p
      +SvPV_nomg|5.007002||p
      +SvPV_renew|5.009003||p
      +SvPV_set|||
      +SvPVbyte_force||5.009002|
      +SvPVbyte_nolen||5.006000|
      +SvPVbytex_force||5.006000|
      +SvPVbytex||5.006000|
      +SvPVbyte|5.006000||p
      +SvPVutf8_force||5.006000|
      +SvPVutf8_nolen||5.006000|
      +SvPVutf8x_force||5.006000|
      +SvPVutf8x||5.006000|
      +SvPVutf8||5.006000|
      +SvPVx|||
      +SvPV|||
      +SvREFCNT_dec_NN||5.017007|
      +SvREFCNT_dec|||
      +SvREFCNT_inc_NN|5.009004||p
      +SvREFCNT_inc_simple_NN|5.009004||p
      +SvREFCNT_inc_simple_void_NN|5.009004||p
      +SvREFCNT_inc_simple_void|5.009004||p
      +SvREFCNT_inc_simple|5.009004||p
      +SvREFCNT_inc_void_NN|5.009004||p
      +SvREFCNT_inc_void|5.009004||p
      +SvREFCNT_inc|||p
      +SvREFCNT|||
      +SvROK_off|||
      +SvROK_on|||
      +SvROK|||
      +SvRV_set|5.009003||p
      +SvRV|||
      +SvRXOK|5.009005||p
      +SvRX|5.009005||p
      +SvSETMAGIC|||
      +SvSHARED_HASH|5.009003||p
      +SvSHARE||5.007003|
      +SvSTASH_set|5.009003||p
      +SvSTASH|||
      +SvSetMagicSV_nosteal||5.004000|
      +SvSetMagicSV||5.004000|
      +SvSetSV_nosteal||5.004000|
      +SvSetSV|||
      +SvTAINTED_off||5.004000|
      +SvTAINTED_on||5.004000|
      +SvTAINTED||5.004000|
      +SvTAINT|||
      +SvTHINKFIRST|||
      +SvTRUE_nomg||5.013006|
      +SvTRUE|||
      +SvTYPE|||
      +SvUNLOCK||5.007003|
      +SvUOK|5.007001|5.006000|p
      +SvUPGRADE|||
      +SvUTF8_off||5.006000|
      +SvUTF8_on||5.006000|
      +SvUTF8||5.006000|
      +SvUVXx|5.004000||p
      +SvUVX|5.004000||p
      +SvUV_nomg|5.009001||p
      +SvUV_set|5.009003||p
      +SvUVx|5.004000||p
      +SvUV|5.004000||p
      +SvVOK||5.008001|
      +SvVSTRING_mg|5.009004||p
      +THIS|||n
      +UNDERBAR|5.009002||p
      +UTF8SKIP||5.006000|
      +UTF8_MAXBYTES|5.009002||p
      +UVCHR_SKIP||5.022000|
      +UVSIZE|5.006000||p
      +UVTYPE|5.006000||p
      +UVXf|5.007001||p
      +UVof|5.006000||p
      +UVuf|5.006000||p
      +UVxf|5.006000||p
      +WARN_ALL|5.006000||p
      +WARN_AMBIGUOUS|5.006000||p
      +WARN_ASSERTIONS|5.024000||p
      +WARN_BAREWORD|5.006000||p
      +WARN_CLOSED|5.006000||p
      +WARN_CLOSURE|5.006000||p
      +WARN_DEBUGGING|5.006000||p
      +WARN_DEPRECATED|5.006000||p
      +WARN_DIGIT|5.006000||p
      +WARN_EXEC|5.006000||p
      +WARN_EXITING|5.006000||p
      +WARN_GLOB|5.006000||p
      +WARN_INPLACE|5.006000||p
      +WARN_INTERNAL|5.006000||p
      +WARN_IO|5.006000||p
      +WARN_LAYER|5.008000||p
      +WARN_MALLOC|5.006000||p
      +WARN_MISC|5.006000||p
      +WARN_NEWLINE|5.006000||p
      +WARN_NUMERIC|5.006000||p
      +WARN_ONCE|5.006000||p
      +WARN_OVERFLOW|5.006000||p
      +WARN_PACK|5.006000||p
      +WARN_PARENTHESIS|5.006000||p
      +WARN_PIPE|5.006000||p
      +WARN_PORTABLE|5.006000||p
      +WARN_PRECEDENCE|5.006000||p
      +WARN_PRINTF|5.006000||p
      +WARN_PROTOTYPE|5.006000||p
      +WARN_QW|5.006000||p
      +WARN_RECURSION|5.006000||p
      +WARN_REDEFINE|5.006000||p
      +WARN_REGEXP|5.006000||p
      +WARN_RESERVED|5.006000||p
      +WARN_SEMICOLON|5.006000||p
      +WARN_SEVERE|5.006000||p
      +WARN_SIGNAL|5.006000||p
      +WARN_SUBSTR|5.006000||p
      +WARN_SYNTAX|5.006000||p
      +WARN_TAINT|5.006000||p
      +WARN_THREADS|5.008000||p
      +WARN_UNINITIALIZED|5.006000||p
      +WARN_UNOPENED|5.006000||p
      +WARN_UNPACK|5.006000||p
      +WARN_UNTIE|5.006000||p
      +WARN_UTF8|5.006000||p
      +WARN_VOID|5.006000||p
      +WIDEST_UTYPE|5.015004||p
      +XCPT_CATCH|5.009002||p
      +XCPT_RETHROW|5.009002||p
      +XCPT_TRY_END|5.009002||p
      +XCPT_TRY_START|5.009002||p
      +XPUSHi|||
      +XPUSHmortal|5.009002||p
      +XPUSHn|||
      +XPUSHp|||
      +XPUSHs|||
      +XPUSHu|5.004000||p
      +XSPROTO|5.010000||p
      +XSRETURN_EMPTY|||
      +XSRETURN_IV|||
      +XSRETURN_NO|||
      +XSRETURN_NV|||
      +XSRETURN_PV|||
      +XSRETURN_UNDEF|||
      +XSRETURN_UV|5.008001||p
      +XSRETURN_YES|||
      +XSRETURN|||p
      +XST_mIV|||
      +XST_mNO|||
      +XST_mNV|||
      +XST_mPV|||
      +XST_mUNDEF|||
      +XST_mUV|5.008001||p
      +XST_mYES|||
      +XS_APIVERSION_BOOTCHECK||5.024000|
      +XS_EXTERNAL||5.024000|
      +XS_INTERNAL||5.024000|
      +XS_VERSION_BOOTCHECK||5.024000|
      +XS_VERSION|||
      +XSprePUSH|5.006000||p
      +XS|||
      +XopDISABLE||5.024000|
      +XopENABLE||5.024000|
      +XopENTRYCUSTOM||5.024000|
      +XopENTRY_set||5.024000|
      +XopENTRY||5.024000|
      +XopFLAGS||5.013007|
      +ZeroD|5.009002||p
      +Zero|||
      +_aMY_CXT|5.007003||p
      +_add_range_to_invlist|||
      +_append_range_to_invlist|||
      +_core_swash_init|||
      +_get_encoding|||
      +_get_regclass_nonbitmap_data|||
      +_get_swash_invlist|||
      +_invlistEQ|||
      +_invlist_array_init|||n
      +_invlist_contains_cp|||n
      +_invlist_dump|||
      +_invlist_intersection_maybe_complement_2nd|||
      +_invlist_intersection|||
      +_invlist_invert|||
      +_invlist_len|||n
      +_invlist_populate_swatch|||n
      +_invlist_search|||n
      +_invlist_subtract|||
      +_invlist_union_maybe_complement_2nd|||
      +_invlist_union|||
      +_is_cur_LC_category_utf8|||
      +_is_in_locale_category||5.021001|
      +_is_uni_FOO||5.017008|
      +_is_uni_perl_idcont||5.017008|
      +_is_uni_perl_idstart||5.017007|
      +_is_utf8_FOO||5.017008|
      +_is_utf8_char_slow||5.021001|n
      +_is_utf8_idcont||5.021001|
      +_is_utf8_idstart||5.021001|
      +_is_utf8_mark||5.017008|
      +_is_utf8_perl_idcont||5.017008|
      +_is_utf8_perl_idstart||5.017007|
      +_is_utf8_xidcont||5.021001|
      +_is_utf8_xidstart||5.021001|
      +_load_PL_utf8_foldclosures|||
      +_make_exactf_invlist|||
      +_new_invlist_C_array|||
      +_new_invlist|||
      +_pMY_CXT|5.007003||p
      +_setlocale_debug_string|||n
      +_setup_canned_invlist|||
      +_swash_inversion_hash|||
      +_swash_to_invlist|||
      +_to_fold_latin1|||
      +_to_uni_fold_flags||5.014000|
      +_to_upper_title_latin1|||
      +_to_utf8_case|||
      +_to_utf8_fold_flags||5.019009|
      +_to_utf8_lower_flags||5.019009|
      +_to_utf8_title_flags||5.019009|
      +_to_utf8_upper_flags||5.019009|
      +_warn_problematic_locale|||n
      +aMY_CXT_|5.007003||p
      +aMY_CXT|5.007003||p
      +aTHXR_|5.024000||p
      +aTHXR|5.024000||p
      +aTHX_|5.006000||p
      +aTHX|5.006000||p
      +add_above_Latin1_folds|||
      +add_cp_to_invlist|||
      +add_data|||n
      +add_multi_match|||
      +add_utf16_textfilter|||
      +adjust_size_and_find_bucket|||n
      +advance_one_LB|||
      +advance_one_SB|||
      +advance_one_WB|||
      +alloc_maybe_populate_EXACT|||
      +alloccopstash|||
      +allocmy|||
      +amagic_call|||
      +amagic_cmp_locale|||
      +amagic_cmp|||
      +amagic_deref_call||5.013007|
      +amagic_i_ncmp|||
      +amagic_is_enabled|||
      +amagic_ncmp|||
      +anonymise_cv_maybe|||
      +any_dup|||
      +ao|||
      +append_utf8_from_native_byte||5.019004|n
      +apply_attrs_my|||
      +apply_attrs_string||5.006001|
      +apply_attrs|||
      +apply|||
      +assert_uft8_cache_coherent|||
      +assignment_type|||
      +atfork_lock||5.007003|n
      +atfork_unlock||5.007003|n
      +av_arylen_p||5.009003|
      +av_clear|||
      +av_create_and_push||5.009005|
      +av_create_and_unshift_one||5.009005|
      +av_delete||5.006000|
      +av_exists||5.006000|
      +av_extend_guts|||
      +av_extend|||
      +av_fetch|||
      +av_fill|||
      +av_iter_p||5.011000|
      +av_len|||
      +av_make|||
      +av_pop|||
      +av_push|||
      +av_reify|||
      +av_shift|||
      +av_store|||
      +av_tindex||5.017009|
      +av_top_index||5.017009|
      +av_undef|||
      +av_unshift|||
      +ax|||n
      +backup_one_LB|||
      +backup_one_SB|||
      +backup_one_WB|||
      +bad_type_gv|||
      +bad_type_pv|||
      +bind_match|||
      +block_end||5.004000|
      +block_gimme||5.004000|
      +block_start||5.004000|
      +blockhook_register||5.013003|
      +boolSV|5.004000||p
      +boot_core_PerlIO|||
      +boot_core_UNIVERSAL|||
      +boot_core_mro|||
      +bytes_cmp_utf8||5.013007|
      +bytes_from_utf8||5.007001|
      +bytes_to_utf8||5.006001|
      +cBOOL|5.013000||p
      +call_argv|5.006000||p
      +call_atexit||5.006000|
      +call_list||5.004000|
      +call_method|5.006000||p
      +call_pv|5.006000||p
      +call_sv|5.006000||p
      +caller_cx|5.013005|5.006000|p
      +calloc||5.007002|n
      +cando|||
      +cast_i32||5.006000|n
      +cast_iv||5.006000|n
      +cast_ulong||5.006000|n
      +cast_uv||5.006000|n
      +check_locale_boundary_crossing|||
      +check_type_and_open|||
      +check_uni|||
      +check_utf8_print|||
      +checkcomma|||
      +ckWARN|5.006000||p
      +ck_entersub_args_core|||
      +ck_entersub_args_list||5.013006|
      +ck_entersub_args_proto_or_list||5.013006|
      +ck_entersub_args_proto||5.013006|
      +ck_warner_d||5.011001|v
      +ck_warner||5.011001|v
      +ckwarn_common|||
      +ckwarn_d||5.009003|
      +ckwarn||5.009003|
      +clear_defarray||5.023008|
      +clear_placeholders|||
      +clear_special_blocks|||
      +clone_params_del|||n
      +clone_params_new|||n
      +closest_cop|||
      +cntrl_to_mnemonic|||n
      +compute_EXACTish|||n
      +construct_ahocorasick_from_trie|||
      +cop_fetch_label||5.015001|
      +cop_free|||
      +cop_hints_2hv||5.013007|
      +cop_hints_fetch_pvn||5.013007|
      +cop_hints_fetch_pvs||5.013007|
      +cop_hints_fetch_pv||5.013007|
      +cop_hints_fetch_sv||5.013007|
      +cop_store_label||5.015001|
      +cophh_2hv||5.013007|
      +cophh_copy||5.013007|
      +cophh_delete_pvn||5.013007|
      +cophh_delete_pvs||5.013007|
      +cophh_delete_pv||5.013007|
      +cophh_delete_sv||5.013007|
      +cophh_fetch_pvn||5.013007|
      +cophh_fetch_pvs||5.013007|
      +cophh_fetch_pv||5.013007|
      +cophh_fetch_sv||5.013007|
      +cophh_free||5.013007|
      +cophh_new_empty||5.024000|
      +cophh_store_pvn||5.013007|
      +cophh_store_pvs||5.013007|
      +cophh_store_pv||5.013007|
      +cophh_store_sv||5.013007|
      +core_prototype|||
      +coresub_op|||
      +cr_textfilter|||
      +create_eval_scope|||
      +croak_memory_wrap||5.019003|n
      +croak_no_mem|||n
      +croak_no_modify||5.013003|n
      +croak_nocontext|||vn
      +croak_popstack|||n
      +croak_sv||5.013001|
      +croak_xs_usage||5.010001|n
      +croak|||v
      +csighandler||5.009003|n
      +current_re_engine|||
      +curse|||
      +custom_op_desc||5.007003|
      +custom_op_get_field|||
      +custom_op_name||5.007003|
      +custom_op_register||5.013007|
      +custom_op_xop||5.013007|
      +cv_ckproto_len_flags|||
      +cv_clone_into|||
      +cv_clone|||
      +cv_const_sv_or_av|||n
      +cv_const_sv||5.003070|n
      +cv_dump|||
      +cv_forget_slab|||
      +cv_get_call_checker||5.013006|
      +cv_name||5.021005|
      +cv_set_call_checker_flags||5.021004|
      +cv_set_call_checker||5.013006|
      +cv_undef_flags|||
      +cv_undef|||
      +cvgv_from_hek|||
      +cvgv_set|||
      +cvstash_set|||
      +cx_dump||5.005000|
      +cx_dup|||
      +cx_popblock||5.023008|
      +cx_popeval||5.023008|
      +cx_popformat||5.023008|
      +cx_popgiven||5.023008|
      +cx_poploop||5.023008|
      +cx_popsub_args||5.023008|
      +cx_popsub_common||5.023008|
      +cx_popsub||5.023008|
      +cx_popwhen||5.023008|
      +cx_pushblock||5.023008|
      +cx_pusheval||5.023008|
      +cx_pushformat||5.023008|
      +cx_pushgiven||5.023008|
      +cx_pushloop_for||5.023008|
      +cx_pushloop_plain||5.023008|
      +cx_pushsub||5.023008|
      +cx_pushwhen||5.023008|
      +cx_topblock||5.023008|
      +cxinc|||
      +dAXMARK|5.009003||p
      +dAX|5.007002||p
      +dITEMS|5.007002||p
      +dMARK|||
      +dMULTICALL||5.009003|
      +dMY_CXT_SV|5.007003||p
      +dMY_CXT|5.007003||p
      +dNOOP|5.006000||p
      +dORIGMARK|||
      +dSP|||
      +dTHR|5.004050||p
      +dTHXR|5.024000||p
      +dTHXa|5.006000||p
      +dTHXoa|5.006000||p
      +dTHX|5.006000||p
      +dUNDERBAR|5.009002||p
      +dVAR|5.009003||p
      +dXCPT|5.009002||p
      +dXSARGS|||
      +dXSI32|||
      +dXSTARG|5.006000||p
      +deb_curcv|||
      +deb_nocontext|||vn
      +deb_stack_all|||
      +deb_stack_n|||
      +debop||5.005000|
      +debprofdump||5.005000|
      +debprof|||
      +debstackptrs||5.007003|
      +debstack||5.007003|
      +debug_start_match|||
      +deb||5.007003|v
      +defelem_target|||
      +del_sv|||
      +delete_eval_scope|||
      +delimcpy||5.004000|n
      +deprecate_commaless_var_list|||
      +despatch_signals||5.007001|
      +destroy_matcher|||
      +die_nocontext|||vn
      +die_sv||5.013001|
      +die_unwind|||
      +die|||v
      +dirp_dup|||
      +div128|||
      +djSP|||
      +do_aexec5|||
      +do_aexec|||
      +do_aspawn|||
      +do_binmode||5.004050|
      +do_chomp|||
      +do_close|||
      +do_delete_local|||
      +do_dump_pad|||
      +do_eof|||
      +do_exec3|||
      +do_execfree|||
      +do_exec|||
      +do_gv_dump||5.006000|
      +do_gvgv_dump||5.006000|
      +do_hv_dump||5.006000|
      +do_ipcctl|||
      +do_ipcget|||
      +do_join|||
      +do_magic_dump||5.006000|
      +do_msgrcv|||
      +do_msgsnd|||
      +do_ncmp|||
      +do_oddball|||
      +do_op_dump||5.006000|
      +do_open6|||
      +do_open9||5.006000|
      +do_open_raw|||
      +do_openn||5.007001|
      +do_open||5.003070|
      +do_pmop_dump||5.006000|
      +do_print|||
      +do_readline|||
      +do_seek|||
      +do_semop|||
      +do_shmio|||
      +do_smartmatch|||
      +do_spawn_nowait|||
      +do_spawn|||
      +do_sprintf|||
      +do_sv_dump||5.006000|
      +do_sysseek|||
      +do_tell|||
      +do_trans_complex_utf8|||
      +do_trans_complex|||
      +do_trans_count_utf8|||
      +do_trans_count|||
      +do_trans_simple_utf8|||
      +do_trans_simple|||
      +do_trans|||
      +do_vecget|||
      +do_vecset|||
      +do_vop|||
      +docatch|||
      +doeval_compile|||
      +dofile|||
      +dofindlabel|||
      +doform|||
      +doing_taint||5.008001|n
      +dooneliner|||
      +doopen_pm|||
      +doparseform|||
      +dopoptoeval|||
      +dopoptogivenfor|||
      +dopoptolabel|||
      +dopoptoloop|||
      +dopoptosub_at|||
      +dopoptowhen|||
      +doref||5.009003|
      +dounwind|||
      +dowantarray|||
      +drand48_init_r|||n
      +drand48_r|||n
      +dtrace_probe_call|||
      +dtrace_probe_load|||
      +dtrace_probe_op|||
      +dtrace_probe_phase|||
      +dump_all_perl|||
      +dump_all||5.006000|
      +dump_c_backtrace|||
      +dump_eval||5.006000|
      +dump_exec_pos|||
      +dump_form||5.006000|
      +dump_indent||5.006000|v
      +dump_mstats|||
      +dump_packsubs_perl|||
      +dump_packsubs||5.006000|
      +dump_sub_perl|||
      +dump_sub||5.006000|
      +dump_sv_child|||
      +dump_trie_interim_list|||
      +dump_trie_interim_table|||
      +dump_trie|||
      +dump_vindent||5.006000|
      +dumpuntil|||
      +dup_attrlist|||
      +edit_distance|||n
      +emulate_cop_io|||
      +eval_pv|5.006000||p
      +eval_sv|5.006000||p
      +exec_failed|||
      +expect_number|||
      +fbm_compile||5.005000|
      +fbm_instr||5.005000|
      +feature_is_enabled|||
      +filter_add|||
      +filter_del|||
      +filter_gets|||
      +filter_read|||
      +finalize_optree|||
      +finalize_op|||
      +find_and_forget_pmops|||
      +find_array_subscript|||
      +find_beginning|||
      +find_byclass|||
      +find_default_stash|||
      +find_hash_subscript|||
      +find_in_my_stash|||
      +find_lexical_cv|||
      +find_runcv_where|||
      +find_runcv||5.008001|
      +find_rundefsvoffset||5.009002|
      +find_rundefsv||5.013002|
      +find_script|||
      +find_uninit_var|||
      +first_symbol|||n
      +fixup_errno_string|||
      +foldEQ_latin1||5.013008|n
      +foldEQ_locale||5.013002|n
      +foldEQ_utf8_flags||5.013010|
      +foldEQ_utf8||5.013002|
      +foldEQ||5.013002|n
      +fold_constants|||
      +forbid_setid|||
      +force_ident_maybe_lex|||
      +force_ident|||
      +force_list|||
      +force_next|||
      +force_strict_version|||
      +force_version|||
      +force_word|||
      +forget_pmop|||
      +form_nocontext|||vn
      +form_short_octal_warning|||
      +form||5.004000|v
      +fp_dup|||
      +fprintf_nocontext|||vn
      +free_c_backtrace|||
      +free_global_struct|||
      +free_tied_hv_pool|||
      +free_tmps|||
      +gen_constant_list|||
      +get_ANYOF_cp_list_for_ssc|||
      +get_and_check_backslash_N_name|||
      +get_aux_mg|||
      +get_av|5.006000||p
      +get_c_backtrace_dump|||
      +get_c_backtrace|||
      +get_context||5.006000|n
      +get_cvn_flags|||
      +get_cvs|5.011000||p
      +get_cv|5.006000||p
      +get_db_sub|||
      +get_debug_opts|||
      +get_hash_seed|||
      +get_hv|5.006000||p
      +get_invlist_iter_addr|||n
      +get_invlist_offset_addr|||n
      +get_invlist_previous_index_addr|||n
      +get_mstats|||
      +get_no_modify|||
      +get_num|||
      +get_op_descs||5.005000|
      +get_op_names||5.005000|
      +get_opargs|||
      +get_ppaddr||5.006000|
      +get_re_arg|||
      +get_sv|5.006000||p
      +get_vtbl||5.005030|
      +getcwd_sv||5.007002|
      +getenv_len|||
      +glob_2number|||
      +glob_assign_glob|||
      +gp_dup|||
      +gp_free|||
      +gp_ref|||
      +grok_atoUV|||n
      +grok_bin|5.007003||p
      +grok_bslash_N|||
      +grok_bslash_c|||
      +grok_bslash_o|||
      +grok_bslash_x|||
      +grok_hex|5.007003||p
      +grok_infnan||5.021004|
      +grok_number_flags||5.021002|
      +grok_number|5.007002||p
      +grok_numeric_radix|5.007002||p
      +grok_oct|5.007003||p
      +group_end|||
      +gv_AVadd|||
      +gv_HVadd|||
      +gv_IOadd|||
      +gv_SVadd|||
      +gv_add_by_type||5.011000|
      +gv_autoload4||5.004000|
      +gv_autoload_pvn||5.015004|
      +gv_autoload_pv||5.015004|
      +gv_autoload_sv||5.015004|
      +gv_check|||
      +gv_const_sv||5.009003|
      +gv_dump||5.006000|
      +gv_efullname3||5.003070|
      +gv_efullname4||5.006001|
      +gv_efullname|||
      +gv_fetchfile_flags||5.009005|
      +gv_fetchfile|||
      +gv_fetchmeth_autoload||5.007003|
      +gv_fetchmeth_internal|||
      +gv_fetchmeth_pv_autoload||5.015004|
      +gv_fetchmeth_pvn_autoload||5.015004|
      +gv_fetchmeth_pvn||5.015004|
      +gv_fetchmeth_pv||5.015004|
      +gv_fetchmeth_sv_autoload||5.015004|
      +gv_fetchmeth_sv||5.015004|
      +gv_fetchmethod_autoload||5.004000|
      +gv_fetchmethod_pv_flags||5.015004|
      +gv_fetchmethod_pvn_flags||5.015004|
      +gv_fetchmethod_sv_flags||5.015004|
      +gv_fetchmethod|||
      +gv_fetchmeth|||
      +gv_fetchpvn_flags|5.009002||p
      +gv_fetchpvs|5.009004||p
      +gv_fetchpv|||
      +gv_fetchsv|||
      +gv_fullname3||5.003070|
      +gv_fullname4||5.006001|
      +gv_fullname|||
      +gv_handler||5.007001|
      +gv_init_pvn|||
      +gv_init_pv||5.015004|
      +gv_init_svtype|||
      +gv_init_sv||5.015004|
      +gv_init|||
      +gv_is_in_main|||
      +gv_magicalize_isa|||
      +gv_magicalize|||
      +gv_name_set||5.009004|
      +gv_override|||
      +gv_setref|||
      +gv_stashpvn_internal|||
      +gv_stashpvn|5.003070||p
      +gv_stashpvs|5.009003||p
      +gv_stashpv|||
      +gv_stashsvpvn_cached|||
      +gv_stashsv|||
      +gv_try_downgrade|||
      +handle_named_backref|||
      +handle_possible_posix|||
      +handle_regex_sets|||
      +he_dup|||
      +hek_dup|||
      +hfree_next_entry|||
      +hfreeentries|||
      +hsplit|||
      +hv_assert|||
      +hv_auxinit_internal|||n
      +hv_auxinit|||
      +hv_backreferences_p|||
      +hv_clear_placeholders||5.009001|
      +hv_clear|||
      +hv_common_key_len||5.010000|
      +hv_common||5.010000|
      +hv_copy_hints_hv||5.009004|
      +hv_delayfree_ent||5.004000|
      +hv_delete_common|||
      +hv_delete_ent||5.003070|
      +hv_delete|||
      +hv_eiter_p||5.009003|
      +hv_eiter_set||5.009003|
      +hv_ename_add|||
      +hv_ename_delete|||
      +hv_exists_ent||5.003070|
      +hv_exists|||
      +hv_fetch_ent||5.003070|
      +hv_fetchs|5.009003||p
      +hv_fetch|||
      +hv_fill||5.013002|
      +hv_free_ent_ret|||
      +hv_free_ent||5.004000|
      +hv_iterinit|||
      +hv_iterkeysv||5.003070|
      +hv_iterkey|||
      +hv_iternext_flags||5.008000|
      +hv_iternextsv|||
      +hv_iternext|||
      +hv_iterval|||
      +hv_kill_backrefs|||
      +hv_ksplit||5.003070|
      +hv_magic_check|||n
      +hv_magic|||
      +hv_name_set||5.009003|
      +hv_notallowed|||
      +hv_placeholders_get||5.009003|
      +hv_placeholders_p|||
      +hv_placeholders_set||5.009003|
      +hv_rand_set||5.018000|
      +hv_riter_p||5.009003|
      +hv_riter_set||5.009003|
      +hv_scalar||5.009001|
      +hv_store_ent||5.003070|
      +hv_store_flags||5.008000|
      +hv_stores|5.009004||p
      +hv_store|||
      +hv_undef_flags|||
      +hv_undef|||
      +ibcmp_locale||5.004000|
      +ibcmp_utf8||5.007003|
      +ibcmp|||
      +incline|||
      +incpush_if_exists|||
      +incpush_use_sep|||
      +incpush|||
      +ingroup|||
      +init_argv_symbols|||
      +init_constants|||
      +init_dbargs|||
      +init_debugger|||
      +init_global_struct|||
      +init_i18nl10n||5.006000|
      +init_i18nl14n||5.006000|
      +init_ids|||
      +init_interp|||
      +init_main_stash|||
      +init_perllib|||
      +init_postdump_symbols|||
      +init_predump_symbols|||
      +init_stacks||5.005000|
      +init_tm||5.007002|
      +inplace_aassign|||
      +instr|||n
      +intro_my||5.004000|
      +intuit_method|||
      +intuit_more|||
      +invert|||
      +invlist_array|||n
      +invlist_clear|||
      +invlist_clone|||
      +invlist_contents|||
      +invlist_extend|||
      +invlist_highest|||n
      +invlist_is_iterating|||n
      +invlist_iterfinish|||n
      +invlist_iterinit|||n
      +invlist_iternext|||n
      +invlist_max|||n
      +invlist_previous_index|||n
      +invlist_replace_list_destroys_src|||
      +invlist_set_len|||
      +invlist_set_previous_index|||n
      +invlist_trim|||n
      +invoke_exception_hook|||
      +io_close|||
      +isALNUMC|5.006000||p
      +isALNUM_lazy||5.021001|
      +isALPHANUMERIC||5.017008|
      +isALPHA|||
      +isASCII|5.006000||p
      +isBLANK|5.006001||p
      +isCNTRL|5.006000||p
      +isDIGIT|||
      +isFOO_lc|||
      +isFOO_utf8_lc|||
      +isGCB|||n
      +isGRAPH|5.006000||p
      +isIDCONT||5.017008|
      +isIDFIRST_lazy||5.021001|
      +isIDFIRST|||
      +isLB|||
      +isLOWER|||
      +isOCTAL||5.013005|
      +isPRINT|5.004000||p
      +isPSXSPC|5.006001||p
      +isPUNCT|5.006000||p
      +isSB|||
      +isSPACE|||
      +isUPPER|||
      +isUTF8_CHAR||5.021001|
      +isWB|||
      +isWORDCHAR||5.013006|
      +isXDIGIT|5.006000||p
      +is_an_int|||
      +is_ascii_string||5.011000|
      +is_handle_constructor|||n
      +is_invariant_string||5.021007|n
      +is_lvalue_sub||5.007001|
      +is_safe_syscall||5.019004|
      +is_ssc_worth_it|||n
      +is_uni_alnum_lc||5.006000|
      +is_uni_alnumc_lc||5.017007|
      +is_uni_alnumc||5.017007|
      +is_uni_alnum||5.006000|
      +is_uni_alpha_lc||5.006000|
      +is_uni_alpha||5.006000|
      +is_uni_ascii_lc||5.006000|
      +is_uni_ascii||5.006000|
      +is_uni_blank_lc||5.017002|
      +is_uni_blank||5.017002|
      +is_uni_cntrl_lc||5.006000|
      +is_uni_cntrl||5.006000|
      +is_uni_digit_lc||5.006000|
      +is_uni_digit||5.006000|
      +is_uni_graph_lc||5.006000|
      +is_uni_graph||5.006000|
      +is_uni_idfirst_lc||5.006000|
      +is_uni_idfirst||5.006000|
      +is_uni_lower_lc||5.006000|
      +is_uni_lower||5.006000|
      +is_uni_print_lc||5.006000|
      +is_uni_print||5.006000|
      +is_uni_punct_lc||5.006000|
      +is_uni_punct||5.006000|
      +is_uni_space_lc||5.006000|
      +is_uni_space||5.006000|
      +is_uni_upper_lc||5.006000|
      +is_uni_upper||5.006000|
      +is_uni_xdigit_lc||5.006000|
      +is_uni_xdigit||5.006000|
      +is_utf8_alnumc||5.017007|
      +is_utf8_alnum||5.006000|
      +is_utf8_alpha||5.006000|
      +is_utf8_ascii||5.006000|
      +is_utf8_blank||5.017002|
      +is_utf8_char_buf||5.015008|n
      +is_utf8_char||5.006000|n
      +is_utf8_cntrl||5.006000|
      +is_utf8_common|||
      +is_utf8_digit||5.006000|
      +is_utf8_graph||5.006000|
      +is_utf8_idcont||5.008000|
      +is_utf8_idfirst||5.006000|
      +is_utf8_lower||5.006000|
      +is_utf8_mark||5.006000|
      +is_utf8_perl_space||5.011001|
      +is_utf8_perl_word||5.011001|
      +is_utf8_posix_digit||5.011001|
      +is_utf8_print||5.006000|
      +is_utf8_punct||5.006000|
      +is_utf8_space||5.006000|
      +is_utf8_string_loclen||5.009003|n
      +is_utf8_string_loc||5.008001|n
      +is_utf8_string||5.006001|n
      +is_utf8_upper||5.006000|
      +is_utf8_xdigit||5.006000|
      +is_utf8_xidcont||5.013010|
      +is_utf8_xidfirst||5.013010|
      +isa_lookup|||
      +isinfnansv|||
      +isinfnan||5.021004|n
      +items|||n
      +ix|||n
      +jmaybe|||
      +join_exact|||
      +keyword_plugin_standard|||
      +keyword|||
      +leave_adjust_stacks||5.023008|
      +leave_scope|||
      +lex_bufutf8||5.011002|
      +lex_discard_to||5.011002|
      +lex_grow_linestr||5.011002|
      +lex_next_chunk||5.011002|
      +lex_peek_unichar||5.011002|
      +lex_read_space||5.011002|
      +lex_read_to||5.011002|
      +lex_read_unichar||5.011002|
      +lex_start||5.009005|
      +lex_stuff_pvn||5.011002|
      +lex_stuff_pvs||5.013005|
      +lex_stuff_pv||5.013006|
      +lex_stuff_sv||5.011002|
      +lex_unstuff||5.011002|
      +listkids|||
      +list|||
      +load_module_nocontext|||vn
      +load_module|5.006000||pv
      +localize|||
      +looks_like_bool|||
      +looks_like_number|||
      +lop|||
      +mPUSHi|5.009002||p
      +mPUSHn|5.009002||p
      +mPUSHp|5.009002||p
      +mPUSHs|5.010001||p
      +mPUSHu|5.009002||p
      +mXPUSHi|5.009002||p
      +mXPUSHn|5.009002||p
      +mXPUSHp|5.009002||p
      +mXPUSHs|5.010001||p
      +mXPUSHu|5.009002||p
      +magic_clear_all_env|||
      +magic_cleararylen_p|||
      +magic_clearenv|||
      +magic_clearhints|||
      +magic_clearhint|||
      +magic_clearisa|||
      +magic_clearpack|||
      +magic_clearsig|||
      +magic_copycallchecker|||
      +magic_dump||5.006000|
      +magic_existspack|||
      +magic_freearylen_p|||
      +magic_freeovrld|||
      +magic_getarylen|||
      +magic_getdebugvar|||
      +magic_getdefelem|||
      +magic_getnkeys|||
      +magic_getpack|||
      +magic_getpos|||
      +magic_getsig|||
      +magic_getsubstr|||
      +magic_gettaint|||
      +magic_getuvar|||
      +magic_getvec|||
      +magic_get|||
      +magic_killbackrefs|||
      +magic_methcall1|||
      +magic_methcall|||v
      +magic_methpack|||
      +magic_nextpack|||
      +magic_regdata_cnt|||
      +magic_regdatum_get|||
      +magic_regdatum_set|||
      +magic_scalarpack|||
      +magic_set_all_env|||
      +magic_setarylen|||
      +magic_setcollxfrm|||
      +magic_setdbline|||
      +magic_setdebugvar|||
      +magic_setdefelem|||
      +magic_setenv|||
      +magic_sethint|||
      +magic_setisa|||
      +magic_setlvref|||
      +magic_setmglob|||
      +magic_setnkeys|||
      +magic_setpack|||
      +magic_setpos|||
      +magic_setregexp|||
      +magic_setsig|||
      +magic_setsubstr|||
      +magic_settaint|||
      +magic_setutf8|||
      +magic_setuvar|||
      +magic_setvec|||
      +magic_set|||
      +magic_sizepack|||
      +magic_wipepack|||
      +make_matcher|||
      +make_trie|||
      +malloc_good_size|||n
      +malloced_size|||n
      +malloc||5.007002|n
      +markstack_grow||5.021001|
      +matcher_matches_sv|||
      +maybe_multimagic_gv|||
      +mayberelocate|||
      +measure_struct|||
      +memEQs|5.009005||p
      +memEQ|5.004000||p
      +memNEs|5.009005||p
      +memNE|5.004000||p
      +mem_collxfrm|||
      +mem_log_alloc|||n
      +mem_log_common|||n
      +mem_log_free|||n
      +mem_log_realloc|||n
      +mess_alloc|||
      +mess_nocontext|||vn
      +mess_sv||5.013001|
      +mess||5.006000|v
      +mfree||5.007002|n
      +mg_clear|||
      +mg_copy|||
      +mg_dup|||
      +mg_find_mglob|||
      +mg_findext|5.013008||pn
      +mg_find|||n
      +mg_free_type||5.013006|
      +mg_free|||
      +mg_get|||
      +mg_length||5.005000|
      +mg_localize|||
      +mg_magical|||n
      +mg_set|||
      +mg_size||5.005000|
      +mini_mktime||5.007002|n
      +minus_v|||
      +missingterm|||
      +mode_from_discipline|||
      +modkids|||
      +more_bodies|||
      +more_sv|||
      +moreswitches|||
      +move_proto_attr|||
      +mro_clean_isarev|||
      +mro_gather_and_rename|||
      +mro_get_from_name||5.010001|
      +mro_get_linear_isa_dfs|||
      +mro_get_linear_isa||5.009005|
      +mro_get_private_data||5.010001|
      +mro_isa_changed_in|||
      +mro_meta_dup|||
      +mro_meta_init|||
      +mro_method_changed_in||5.009005|
      +mro_package_moved|||
      +mro_register||5.010001|
      +mro_set_mro||5.010001|
      +mro_set_private_data||5.010001|
      +mul128|||
      +mulexp10|||n
      +multideref_stringify|||
      +my_atof2||5.007002|
      +my_atof||5.006000|
      +my_attrs|||
      +my_bcopy||5.004050|n
      +my_bytes_to_utf8|||n
      +my_bzero|||n
      +my_chsize|||
      +my_clearenv|||
      +my_cxt_index|||
      +my_cxt_init|||
      +my_dirfd||5.009005|n
      +my_exit_jump|||
      +my_exit|||
      +my_failure_exit||5.004000|
      +my_fflush_all||5.006000|
      +my_fork||5.007003|n
      +my_kid|||
      +my_lstat_flags|||
      +my_lstat||5.024000|
      +my_memcmp|||n
      +my_memset|||n
      +my_pclose||5.003070|
      +my_popen_list||5.007001|
      +my_popen||5.003070|
      +my_setenv|||
      +my_setlocale|||
      +my_snprintf|5.009004||pvn
      +my_socketpair||5.007003|n
      +my_sprintf|5.009003||pvn
      +my_stat_flags|||
      +my_stat||5.024000|
      +my_strerror||5.021001|
      +my_strftime||5.007002|
      +my_strlcat|5.009004||pn
      +my_strlcpy|5.009004||pn
      +my_unexec|||
      +my_vsnprintf||5.009004|n
      +need_utf8|||n
      +newANONATTRSUB||5.006000|
      +newANONHASH|||
      +newANONLIST|||
      +newANONSUB|||
      +newASSIGNOP|||
      +newATTRSUB_x|||
      +newATTRSUB||5.006000|
      +newAVREF|||
      +newAV|||
      +newBINOP|||
      +newCONDOP|||
      +newCONSTSUB_flags||5.015006|
      +newCONSTSUB|5.004050||p
      +newCVREF|||
      +newDEFSVOP||5.021006|
      +newFORM|||
      +newFOROP||5.013007|
      +newGIVENOP||5.009003|
      +newGIVWHENOP|||
      +newGP|||
      +newGVOP|||
      +newGVREF|||
      +newGVgen_flags||5.015004|
      +newGVgen|||
      +newHVREF|||
      +newHVhv||5.005000|
      +newHV|||
      +newIO|||
      +newLISTOP|||
      +newLOGOP|||
      +newLOOPEX|||
      +newLOOPOP|||
      +newMETHOP_internal|||
      +newMETHOP_named||5.021005|
      +newMETHOP||5.021005|
      +newMYSUB||5.017004|
      +newNULLLIST|||
      +newOP|||
      +newPADNAMELIST||5.021007|n
      +newPADNAMEouter||5.021007|n
      +newPADNAMEpvn||5.021007|n
      +newPADOP|||
      +newPMOP|||
      +newPROG|||
      +newPVOP|||
      +newRANGE|||
      +newRV_inc|5.004000||p
      +newRV_noinc|5.004000||p
      +newRV|||
      +newSLICEOP|||
      +newSTATEOP|||
      +newSTUB|||
      +newSUB|||
      +newSVOP|||
      +newSVREF|||
      +newSV_type|5.009005||p
      +newSVavdefelem|||
      +newSVhek||5.009003|
      +newSViv|||
      +newSVnv|||
      +newSVpadname||5.017004|
      +newSVpv_share||5.013006|
      +newSVpvf_nocontext|||vn
      +newSVpvf||5.004000|v
      +newSVpvn_flags|5.010001||p
      +newSVpvn_share|5.007001||p
      +newSVpvn_utf8|5.010001||p
      +newSVpvn|5.004050||p
      +newSVpvs_flags|5.010001||p
      +newSVpvs_share|5.009003||p
      +newSVpvs|5.009003||p
      +newSVpv|||
      +newSVrv|||
      +newSVsv|||
      +newSVuv|5.006000||p
      +newSV|||
      +newUNOP_AUX||5.021007|
      +newUNOP|||
      +newWHENOP||5.009003|
      +newWHILEOP||5.013007|
      +newXS_deffile|||
      +newXS_flags||5.009004|
      +newXS_len_flags|||
      +newXSproto||5.006000|
      +newXS||5.006000|
      +new_collate||5.006000|
      +new_constant|||
      +new_ctype||5.006000|
      +new_he|||
      +new_logop|||
      +new_numeric||5.006000|
      +new_stackinfo||5.005000|
      +new_version||5.009000|
      +new_warnings_bitfield|||
      +next_symbol|||
      +nextargv|||
      +nextchar|||
      +ninstr|||n
      +no_bareword_allowed|||
      +no_fh_allowed|||
      +no_op|||
      +noperl_die|||vn
      +not_a_number|||
      +not_incrementable|||
      +nothreadhook||5.008000|
      +nuke_stacks|||
      +num_overflow|||n
      +oopsAV|||
      +oopsHV|||
      +op_append_elem||5.013006|
      +op_append_list||5.013006|
      +op_clear|||
      +op_contextualize||5.013006|
      +op_convert_list||5.021006|
      +op_dump||5.006000|
      +op_free|||
      +op_integerize|||
      +op_linklist||5.013006|
      +op_lvalue_flags|||
      +op_lvalue||5.013007|
      +op_null||5.007002|
      +op_parent|||n
      +op_prepend_elem||5.013006|
      +op_refcnt_dec|||
      +op_refcnt_inc|||
      +op_refcnt_lock||5.009002|
      +op_refcnt_unlock||5.009002|
      +op_relocate_sv|||
      +op_scope||5.013007|
      +op_sibling_splice||5.021002|n
      +op_std_init|||
      +op_unscope|||
      +open_script|||
      +openn_cleanup|||
      +openn_setup|||
      +opmethod_stash|||
      +opslab_force_free|||
      +opslab_free_nopad|||
      +opslab_free|||
      +output_or_return_posix_warnings|||
      +pMY_CXT_|5.007003||p
      +pMY_CXT|5.007003||p
      +pTHX_|5.006000||p
      +pTHX|5.006000||p
      +packWARN|5.007003||p
      +pack_cat||5.007003|
      +pack_rec|||
      +package_version|||
      +package|||
      +packlist||5.008001|
      +pad_add_anon||5.008001|
      +pad_add_name_pvn||5.015001|
      +pad_add_name_pvs||5.015001|
      +pad_add_name_pv||5.015001|
      +pad_add_name_sv||5.015001|
      +pad_add_weakref|||
      +pad_alloc_name|||
      +pad_alloc|||
      +pad_block_start|||
      +pad_check_dup|||
      +pad_compname_type||5.009003|
      +pad_findlex|||
      +pad_findmy_pvn||5.015001|
      +pad_findmy_pvs||5.015001|
      +pad_findmy_pv||5.015001|
      +pad_findmy_sv||5.015001|
      +pad_fixup_inner_anons|||
      +pad_free|||
      +pad_leavemy|||
      +pad_new||5.008001|
      +pad_push|||
      +pad_reset|||
      +pad_setsv|||
      +pad_sv|||
      +pad_swipe|||
      +pad_tidy||5.008001|
      +padlist_dup|||
      +padlist_store|||
      +padname_dup|||
      +padname_free|||
      +padnamelist_dup|||
      +padnamelist_fetch||5.021007|n
      +padnamelist_free|||
      +padnamelist_store||5.021007|
      +parse_arithexpr||5.013008|
      +parse_barestmt||5.013007|
      +parse_block||5.013007|
      +parse_body|||
      +parse_fullexpr||5.013008|
      +parse_fullstmt||5.013005|
      +parse_gv_stash_name|||
      +parse_ident|||
      +parse_label||5.013007|
      +parse_listexpr||5.013008|
      +parse_lparen_question_flags|||
      +parse_stmtseq||5.013006|
      +parse_subsignature|||
      +parse_termexpr||5.013008|
      +parse_unicode_opts|||
      +parser_dup|||
      +parser_free_nexttoke_ops|||
      +parser_free|||
      +path_is_searchable|||n
      +peep|||
      +pending_ident|||
      +perl_alloc_using|||n
      +perl_alloc|||n
      +perl_clone_using|||n
      +perl_clone|||n
      +perl_construct|||n
      +perl_destruct||5.007003|n
      +perl_free|||n
      +perl_parse||5.006000|n
      +perl_run|||n
      +pidgone|||
      +pm_description|||
      +pmop_dump||5.006000|
      +pmruntime|||
      +pmtrans|||
      +pop_scope|||
      +populate_ANYOF_from_invlist|||
      +populate_isa|||v
      +pregcomp||5.009005|
      +pregexec|||
      +pregfree2||5.011000|
      +pregfree|||
      +prescan_version||5.011004|
      +printbuf|||
      +printf_nocontext|||vn
      +process_special_blocks|||
      +ptr_hash|||n
      +ptr_table_clear||5.009005|
      +ptr_table_fetch||5.009005|
      +ptr_table_find|||n
      +ptr_table_free||5.009005|
      +ptr_table_new||5.009005|
      +ptr_table_split||5.009005|
      +ptr_table_store||5.009005|
      +push_scope|||
      +put_charclass_bitmap_innards_common|||
      +put_charclass_bitmap_innards_invlist|||
      +put_charclass_bitmap_innards|||
      +put_code_point|||
      +put_range|||
      +pv_display|5.006000||p
      +pv_escape|5.009004||p
      +pv_pretty|5.009004||p
      +pv_uni_display||5.007003|
      +qerror|||
      +qsortsvu|||
      +quadmath_format_needed|||n
      +quadmath_format_single|||n
      +re_compile||5.009005|
      +re_croak2|||
      +re_dup_guts|||
      +re_exec_indentf|||v
      +re_indentf|||v
      +re_intuit_start||5.019001|
      +re_intuit_string||5.006000|
      +re_op_compile|||
      +re_printf|||v
      +realloc||5.007002|n
      +reentrant_free||5.024000|
      +reentrant_init||5.024000|
      +reentrant_retry||5.024000|vn
      +reentrant_size||5.024000|
      +ref_array_or_hash|||
      +refcounted_he_chain_2hv|||
      +refcounted_he_fetch_pvn|||
      +refcounted_he_fetch_pvs|||
      +refcounted_he_fetch_pv|||
      +refcounted_he_fetch_sv|||
      +refcounted_he_free|||
      +refcounted_he_inc|||
      +refcounted_he_new_pvn|||
      +refcounted_he_new_pvs|||
      +refcounted_he_new_pv|||
      +refcounted_he_new_sv|||
      +refcounted_he_value|||
      +refkids|||
      +refto|||
      +ref||5.024000|
      +reg2Lanode|||
      +reg_check_named_buff_matched|||n
      +reg_named_buff_all||5.009005|
      +reg_named_buff_exists||5.009005|
      +reg_named_buff_fetch||5.009005|
      +reg_named_buff_firstkey||5.009005|
      +reg_named_buff_iter|||
      +reg_named_buff_nextkey||5.009005|
      +reg_named_buff_scalar||5.009005|
      +reg_named_buff|||
      +reg_node|||
      +reg_numbered_buff_fetch|||
      +reg_numbered_buff_length|||
      +reg_numbered_buff_store|||
      +reg_qr_package|||
      +reg_recode|||
      +reg_scan_name|||
      +reg_skipcomment|||n
      +reg_temp_copy|||
      +reganode|||
      +regatom|||
      +regbranch|||
      +regclass_swash||5.009004|
      +regclass|||
      +regcppop|||
      +regcppush|||
      +regcurly|||n
      +regdump_extflags|||
      +regdump_intflags|||
      +regdump||5.005000|
      +regdupe_internal|||
      +regex_set_precedence|||n
      +regexec_flags||5.005000|
      +regfree_internal||5.009005|
      +reghop3|||n
      +reghop4|||n
      +reghopmaybe3|||n
      +reginclass|||
      +reginitcolors||5.006000|
      +reginsert|||
      +regmatch|||
      +regnext||5.005000|
      +regnode_guts|||
      +regpiece|||
      +regprop|||
      +regrepeat|||
      +regtail_study|||
      +regtail|||
      +regtry|||
      +reg|||
      +repeatcpy|||n
      +report_evil_fh|||
      +report_redefined_cv|||
      +report_uninit|||
      +report_wrongway_fh|||
      +require_pv||5.006000|
      +require_tie_mod|||
      +restore_magic|||
      +rninstr|||n
      +rpeep|||
      +rsignal_restore|||
      +rsignal_save|||
      +rsignal_state||5.004000|
      +rsignal||5.004000|
      +run_body|||
      +run_user_filter|||
      +runops_debug||5.005000|
      +runops_standard||5.005000|
      +rv2cv_op_cv||5.013006|
      +rvpv_dup|||
      +rxres_free|||
      +rxres_restore|||
      +rxres_save|||
      +safesyscalloc||5.006000|n
      +safesysfree||5.006000|n
      +safesysmalloc||5.006000|n
      +safesysrealloc||5.006000|n
      +same_dirent|||
      +save_I16||5.004000|
      +save_I32|||
      +save_I8||5.006000|
      +save_adelete||5.011000|
      +save_aelem_flags||5.011000|
      +save_aelem||5.004050|
      +save_alloc||5.006000|
      +save_aptr|||
      +save_ary|||
      +save_bool||5.008001|
      +save_clearsv|||
      +save_delete|||
      +save_destructor_x||5.006000|
      +save_destructor||5.006000|
      +save_freeop|||
      +save_freepv|||
      +save_freesv|||
      +save_generic_pvref||5.006001|
      +save_generic_svref||5.005030|
      +save_gp||5.004000|
      +save_hash|||
      +save_hdelete||5.011000|
      +save_hek_flags|||n
      +save_helem_flags||5.011000|
      +save_helem||5.004050|
      +save_hints||5.010001|
      +save_hptr|||
      +save_int|||
      +save_item|||
      +save_iv||5.005000|
      +save_lines|||
      +save_list|||
      +save_long|||
      +save_magic_flags|||
      +save_mortalizesv||5.007001|
      +save_nogv|||
      +save_op||5.005000|
      +save_padsv_and_mortalize||5.010001|
      +save_pptr|||
      +save_pushi32ptr||5.010001|
      +save_pushptri32ptr|||
      +save_pushptrptr||5.010001|
      +save_pushptr||5.010001|
      +save_re_context||5.006000|
      +save_scalar_at|||
      +save_scalar|||
      +save_set_svflags||5.009000|
      +save_shared_pvref||5.007003|
      +save_sptr|||
      +save_strlen|||
      +save_svref|||
      +save_vptr||5.006000|
      +savepvn|||
      +savepvs||5.009003|
      +savepv|||
      +savesharedpvn||5.009005|
      +savesharedpvs||5.013006|
      +savesharedpv||5.007003|
      +savesharedsvpv||5.013006|
      +savestack_grow_cnt||5.008001|
      +savestack_grow|||
      +savesvpv||5.009002|
      +savetmps||5.023008|
      +sawparens|||
      +scalar_mod_type|||n
      +scalarboolean|||
      +scalarkids|||
      +scalarseq|||
      +scalarvoid|||
      +scalar|||
      +scan_bin||5.006000|
      +scan_commit|||
      +scan_const|||
      +scan_formline|||
      +scan_heredoc|||
      +scan_hex|||
      +scan_ident|||
      +scan_inputsymbol|||
      +scan_num||5.007001|
      +scan_oct|||
      +scan_pat|||
      +scan_str|||
      +scan_subst|||
      +scan_trans|||
      +scan_version||5.009001|
      +scan_vstring||5.009005|
      +scan_word|||
      +search_const|||
      +seed||5.008001|
      +sequence_num|||
      +set_ANYOF_arg|||
      +set_caret_X|||
      +set_context||5.006000|n
      +set_numeric_local||5.006000|
      +set_numeric_radix||5.006000|
      +set_numeric_standard||5.006000|
      +set_padlist|||n
      +setdefout|||
      +share_hek_flags|||
      +share_hek||5.004000|
      +should_warn_nl|||n
      +si_dup|||
      +sighandler|||n
      +simplify_sort|||
      +skip_to_be_ignored_text|||
      +skipspace_flags|||
      +softref2xv|||
      +sortcv_stacked|||
      +sortcv_xsub|||
      +sortcv|||
      +sortsv_flags||5.009003|
      +sortsv||5.007003|
      +space_join_names_mortal|||
      +ss_dup|||
      +ssc_add_range|||
      +ssc_and|||
      +ssc_anything|||
      +ssc_clear_locale|||n
      +ssc_cp_and|||
      +ssc_finalize|||
      +ssc_init|||
      +ssc_intersection|||
      +ssc_is_anything|||n
      +ssc_is_cp_posixl_init|||n
      +ssc_or|||
      +ssc_union|||
      +stack_grow|||
      +start_glob|||
      +start_subparse||5.004000|
      +stdize_locale|||
      +strEQ|||
      +strGE|||
      +strGT|||
      +strLE|||
      +strLT|||
      +strNE|||
      +str_to_version||5.006000|
      +strip_return|||
      +strnEQ|||
      +strnNE|||
      +study_chunk|||
      +sub_crush_depth|||
      +sublex_done|||
      +sublex_push|||
      +sublex_start|||
      +sv_2bool_flags||5.013006|
      +sv_2bool|||
      +sv_2cv|||
      +sv_2io|||
      +sv_2iuv_common|||
      +sv_2iuv_non_preserve|||
      +sv_2iv_flags||5.009001|
      +sv_2iv|||
      +sv_2mortal|||
      +sv_2num|||
      +sv_2nv_flags||5.013001|
      +sv_2pv_flags|5.007002||p
      +sv_2pv_nolen|5.006000||p
      +sv_2pvbyte_nolen|5.006000||p
      +sv_2pvbyte|5.006000||p
      +sv_2pvutf8_nolen||5.006000|
      +sv_2pvutf8||5.006000|
      +sv_2pv|||
      +sv_2uv_flags||5.009001|
      +sv_2uv|5.004000||p
      +sv_add_arena|||
      +sv_add_backref|||
      +sv_backoff|||n
      +sv_bless|||
      +sv_buf_to_ro|||
      +sv_buf_to_rw|||
      +sv_cat_decode||5.008001|
      +sv_catpv_flags||5.013006|
      +sv_catpv_mg|5.004050||p
      +sv_catpv_nomg||5.013006|
      +sv_catpvf_mg_nocontext|||pvn
      +sv_catpvf_mg|5.006000|5.004000|pv
      +sv_catpvf_nocontext|||vn
      +sv_catpvf||5.004000|v
      +sv_catpvn_flags||5.007002|
      +sv_catpvn_mg|5.004050||p
      +sv_catpvn_nomg|5.007002||p
      +sv_catpvn|||
      +sv_catpvs_flags||5.013006|
      +sv_catpvs_mg||5.013006|
      +sv_catpvs_nomg||5.013006|
      +sv_catpvs|5.009003||p
      +sv_catpv|||
      +sv_catsv_flags||5.007002|
      +sv_catsv_mg|5.004050||p
      +sv_catsv_nomg|5.007002||p
      +sv_catsv|||
      +sv_chop|||
      +sv_clean_all|||
      +sv_clean_objs|||
      +sv_clear|||
      +sv_cmp_flags||5.013006|
      +sv_cmp_locale_flags||5.013006|
      +sv_cmp_locale||5.004000|
      +sv_cmp|||
      +sv_collxfrm_flags||5.013006|
      +sv_collxfrm|||
      +sv_copypv_flags||5.017002|
      +sv_copypv_nomg||5.017002|
      +sv_copypv|||
      +sv_dec_nomg||5.013002|
      +sv_dec|||
      +sv_del_backref|||
      +sv_derived_from_pvn||5.015004|
      +sv_derived_from_pv||5.015004|
      +sv_derived_from_sv||5.015004|
      +sv_derived_from||5.004000|
      +sv_destroyable||5.010000|
      +sv_display|||
      +sv_does_pvn||5.015004|
      +sv_does_pv||5.015004|
      +sv_does_sv||5.015004|
      +sv_does||5.009004|
      +sv_dump|||
      +sv_dup_common|||
      +sv_dup_inc_multiple|||
      +sv_dup_inc|||
      +sv_dup|||
      +sv_eq_flags||5.013006|
      +sv_eq|||
      +sv_exp_grow|||
      +sv_force_normal_flags||5.007001|
      +sv_force_normal||5.006000|
      +sv_free2|||
      +sv_free_arenas|||
      +sv_free|||
      +sv_get_backrefs||5.021008|n
      +sv_gets||5.003070|
      +sv_grow|||
      +sv_i_ncmp|||
      +sv_inc_nomg||5.013002|
      +sv_inc|||
      +sv_insert_flags||5.010001|
      +sv_insert|||
      +sv_isa|||
      +sv_isobject|||
      +sv_iv||5.005000|
      +sv_kill_backrefs|||
      +sv_len_utf8_nomg|||
      +sv_len_utf8||5.006000|
      +sv_len|||
      +sv_magic_portable|5.024000|5.004000|p
      +sv_magicext_mglob|||
      +sv_magicext||5.007003|
      +sv_magic|||
      +sv_mortalcopy_flags|||
      +sv_mortalcopy|||
      +sv_ncmp|||
      +sv_newmortal|||
      +sv_newref|||
      +sv_nolocking||5.007003|
      +sv_nosharing||5.007003|
      +sv_nounlocking|||
      +sv_nv||5.005000|
      +sv_only_taint_gmagic|||n
      +sv_or_pv_pos_u2b|||
      +sv_peek||5.005000|
      +sv_pos_b2u_flags||5.019003|
      +sv_pos_b2u_midway|||
      +sv_pos_b2u||5.006000|
      +sv_pos_u2b_cached|||
      +sv_pos_u2b_flags||5.011005|
      +sv_pos_u2b_forwards|||n
      +sv_pos_u2b_midway|||n
      +sv_pos_u2b||5.006000|
      +sv_pvbyten_force||5.006000|
      +sv_pvbyten||5.006000|
      +sv_pvbyte||5.006000|
      +sv_pvn_force_flags|5.007002||p
      +sv_pvn_force|||
      +sv_pvn_nomg|5.007003|5.005000|p
      +sv_pvn||5.005000|
      +sv_pvutf8n_force||5.006000|
      +sv_pvutf8n||5.006000|
      +sv_pvutf8||5.006000|
      +sv_pv||5.006000|
      +sv_recode_to_utf8||5.007003|
      +sv_reftype|||
      +sv_ref||5.015004|
      +sv_replace|||
      +sv_report_used|||
      +sv_resetpvn|||
      +sv_reset|||
      +sv_rvweaken||5.006000|
      +sv_sethek|||
      +sv_setiv_mg|5.004050||p
      +sv_setiv|||
      +sv_setnv_mg|5.006000||p
      +sv_setnv|||
      +sv_setpv_mg|5.004050||p
      +sv_setpvf_mg_nocontext|||pvn
      +sv_setpvf_mg|5.006000|5.004000|pv
      +sv_setpvf_nocontext|||vn
      +sv_setpvf||5.004000|v
      +sv_setpviv_mg||5.008001|
      +sv_setpviv||5.008001|
      +sv_setpvn_mg|5.004050||p
      +sv_setpvn|||
      +sv_setpvs_mg||5.013006|
      +sv_setpvs|5.009004||p
      +sv_setpv|||
      +sv_setref_iv|||
      +sv_setref_nv|||
      +sv_setref_pvn|||
      +sv_setref_pvs||5.024000|
      +sv_setref_pv|||
      +sv_setref_uv||5.007001|
      +sv_setsv_cow|||
      +sv_setsv_flags||5.007002|
      +sv_setsv_mg|5.004050||p
      +sv_setsv_nomg|5.007002||p
      +sv_setsv|||
      +sv_setuv_mg|5.004050||p
      +sv_setuv|5.004000||p
      +sv_tainted||5.004000|
      +sv_taint||5.004000|
      +sv_true||5.005000|
      +sv_unglob|||
      +sv_uni_display||5.007003|
      +sv_unmagicext|5.013008||p
      +sv_unmagic|||
      +sv_unref_flags||5.007001|
      +sv_unref|||
      +sv_untaint||5.004000|
      +sv_upgrade|||
      +sv_usepvn_flags||5.009004|
      +sv_usepvn_mg|5.004050||p
      +sv_usepvn|||
      +sv_utf8_decode||5.006000|
      +sv_utf8_downgrade||5.006000|
      +sv_utf8_encode||5.006000|
      +sv_utf8_upgrade_flags_grow||5.011000|
      +sv_utf8_upgrade_flags||5.007002|
      +sv_utf8_upgrade_nomg||5.007002|
      +sv_utf8_upgrade||5.007001|
      +sv_uv|5.005000||p
      +sv_vcatpvf_mg|5.006000|5.004000|p
      +sv_vcatpvfn_flags||5.017002|
      +sv_vcatpvfn||5.004000|
      +sv_vcatpvf|5.006000|5.004000|p
      +sv_vsetpvf_mg|5.006000|5.004000|p
      +sv_vsetpvfn||5.004000|
      +sv_vsetpvf|5.006000|5.004000|p
      +svtype|||
      +swallow_bom|||
      +swash_fetch||5.007002|
      +swash_init||5.006000|
      +swash_scan_list_line|||
      +swatch_get|||
      +sync_locale||5.021004|
      +sys_init3||5.010000|n
      +sys_init||5.010000|n
      +sys_intern_clear|||
      +sys_intern_dup|||
      +sys_intern_init|||
      +sys_term||5.010000|n
      +taint_env|||
      +taint_proper|||
      +tied_method|||v
      +tmps_grow_p|||
      +toFOLD_utf8||5.019001|
      +toFOLD_uvchr||5.023009|
      +toFOLD||5.019001|
      +toLOWER_L1||5.019001|
      +toLOWER_LC||5.004000|
      +toLOWER_utf8||5.015007|
      +toLOWER_uvchr||5.023009|
      +toLOWER|||
      +toTITLE_utf8||5.015007|
      +toTITLE_uvchr||5.023009|
      +toTITLE||5.019001|
      +toUPPER_utf8||5.015007|
      +toUPPER_uvchr||5.023009|
      +toUPPER|||
      +to_byte_substr|||
      +to_lower_latin1|||n
      +to_uni_fold||5.007003|
      +to_uni_lower_lc||5.006000|
      +to_uni_lower||5.007003|
      +to_uni_title_lc||5.006000|
      +to_uni_title||5.007003|
      +to_uni_upper_lc||5.006000|
      +to_uni_upper||5.007003|
      +to_utf8_case||5.007003|
      +to_utf8_fold||5.015007|
      +to_utf8_lower||5.015007|
      +to_utf8_substr|||
      +to_utf8_title||5.015007|
      +to_utf8_upper||5.015007|
      +tokenize_use|||
      +tokeq|||
      +tokereport|||
      +too_few_arguments_pv|||
      +too_many_arguments_pv|||
      +translate_substr_offsets|||n
      +try_amagic_bin|||
      +try_amagic_un|||
      +uiv_2buf|||n
      +unlnk|||
      +unpack_rec|||
      +unpack_str||5.007003|
      +unpackstring||5.008001|
      +unreferenced_to_tmp_stack|||
      +unshare_hek_or_pvn|||
      +unshare_hek|||
      +unsharepvn||5.003070|
      +unwind_handler_stack|||
      +update_debugger_info|||
      +upg_version||5.009005|
      +usage|||
      +utf16_textfilter|||
      +utf16_to_utf8_reversed||5.006001|
      +utf16_to_utf8||5.006001|
      +utf8_distance||5.006000|
      +utf8_hop||5.006000|n
      +utf8_length||5.007001|
      +utf8_mg_len_cache_update|||
      +utf8_mg_pos_cache_update|||
      +utf8_to_bytes||5.006001|
      +utf8_to_uvchr_buf||5.015009|
      +utf8_to_uvchr||5.007001|
      +utf8_to_uvuni_buf||5.015009|
      +utf8_to_uvuni||5.007001|
      +utf8n_to_uvchr||5.007001|
      +utf8n_to_uvuni||5.007001|
      +utilize|||
      +uvchr_to_utf8_flags||5.007003|
      +uvchr_to_utf8||5.007001|
      +uvoffuni_to_utf8_flags||5.019004|
      +uvuni_to_utf8_flags||5.007003|
      +uvuni_to_utf8||5.007001|
      +valid_utf8_to_uvchr||5.015009|
      +valid_utf8_to_uvuni||5.015009|
      +validate_proto|||
      +validate_suid|||
      +varname|||
      +vcmp||5.009000|
      +vcroak||5.006000|
      +vdeb||5.007003|
      +vform||5.006000|
      +visit|||
      +vivify_defelem|||
      +vivify_ref|||
      +vload_module|5.006000||p
      +vmess||5.006000|
      +vnewSVpvf|5.006000|5.004000|p
      +vnormal||5.009002|
      +vnumify||5.009000|
      +vstringify||5.009000|
      +vverify||5.009003|
      +vwarner||5.006000|
      +vwarn||5.006000|
      +wait4pid|||
      +warn_nocontext|||vn
      +warn_sv||5.013001|
      +warner_nocontext|||vn
      +warner|5.006000|5.004000|pv
      +warn|||v
      +was_lvalue_sub|||
      +watch|||
      +whichsig_pvn||5.015004|
      +whichsig_pv||5.015004|
      +whichsig_sv||5.015004|
      +whichsig|||
      +win32_croak_not_implemented|||n
      +with_queued_errors|||
      +wrap_op_checker||5.015008|
      +write_to_stderr|||
      +xs_boot_epilog|||
      +xs_handshake|||vn
      +xs_version_bootcheck|||
      +yyerror_pvn|||
      +yyerror_pv|||
      +yyerror|||
      +yylex|||
      +yyparse|||
      +yyunlex|||
      +yywarn|||
      +);
      +
      +if (exists $opt{'list-unsupported'}) {
      +  my $f;
      +  for $f (sort { lc $a cmp lc $b } keys %API) {
      +    next unless $API{$f}{todo};
      +    print "$f ", '.'x(40-length($f)), " ", format_version($API{$f}{todo}), "\n";
      +  }
      +  exit 0;
      +}
      +
      +# Scan for possible replacement candidates
      +
      +my(%replace, %need, %hints, %warnings, %depends);
      +my $replace = 0;
      +my($hint, $define, $function);
      +
      +sub find_api
      +{
      +  my $code = shift;
      +  $code =~ s{
      +    / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)
      +  | "[^"\\]*(?:\\.[^"\\]*)*"
      +  | '[^'\\]*(?:\\.[^'\\]*)*' }{}egsx;
      +  grep { exists $API{$_} } $code =~ /(\w+)/mg;
      +}
      +
      +while (<DATA>) {
      +  if ($hint) {
      +    my $h = $hint->[0] eq 'Hint' ? \%hints : \%warnings;
      +    if (m{^\s*\*\s(.*?)\s*$}) {
      +      for (@{$hint->[1]}) {
      +        $h->{$_} ||= '';  # suppress warning with older perls
      +        $h->{$_} .= "$1\n";
      +      }
      +    }
      +    else { undef $hint }
      +  }
      +
      +  $hint = [$1, [split /,?\s+/, $2]]
      +      if m{^\s*$rccs\s+(Hint|Warning):\s+(\w+(?:,?\s+\w+)*)\s*$};
      +
      +  if ($define) {
      +    if ($define->[1] =~ /\\$/) {
      +      $define->[1] .= $_;
      +    }
      +    else {
      +      if (exists $API{$define->[0]} && $define->[1] !~ /^DPPP_\(/) {
      +        my @n = find_api($define->[1]);
      +        push @{$depends{$define->[0]}}, @n if @n
      +      }
      +      undef $define;
      +    }
      +  }
      +
      +  $define = [$1, $2] if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(.*)};
      +
      +  if ($function) {
      +    if (/^}/) {
      +      if (exists $API{$function->[0]}) {
      +        my @n = find_api($function->[1]);
      +        push @{$depends{$function->[0]}}, @n if @n
      +      }
      +      undef $function;
      +    }
      +    else {
      +      $function->[1] .= $_;
      +    }
      +  }
      +
      +  $function = [$1, ''] if m{^DPPP_\(my_(\w+)\)};
      +
      +  $replace     = $1 if m{^\s*$rccs\s+Replace:\s+(\d+)\s+$rcce\s*$};
      +  $replace{$2} = $1 if $replace and m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+)};
      +  $replace{$2} = $1 if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+).*$rccs\s+Replace\s+$rcce};
      +  $replace{$1} = $2 if m{^\s*$rccs\s+Replace (\w+) with (\w+)\s+$rcce\s*$};
      +
      +  if (m{^\s*$rccs\s+(\w+(\s*,\s*\w+)*)\s+depends\s+on\s+(\w+(\s*,\s*\w+)*)\s+$rcce\s*$}) {
      +    my @deps = map { s/\s+//g; $_ } split /,/, $3;
      +    my $d;
      +    for $d (map { s/\s+//g; $_ } split /,/, $1) {
      +      push @{$depends{$d}}, @deps;
      +    }
      +  }
      +
      +  $need{$1} = 1 if m{^#if\s+defined\(NEED_(\w+)(?:_GLOBAL)?\)};
      +}
      +
      +for (values %depends) {
      +  my %s;
      +  $_ = [sort grep !$s{$_}++, @$_];
      +}
      +
      +if (exists $opt{'api-info'}) {
      +  my $f;
      +  my $count = 0;
      +  my $match = $opt{'api-info'} =~ m!^/(.*)/$! ? $1 : "^\Q$opt{'api-info'}\E\$";
      +  for $f (sort { lc $a cmp lc $b } keys %API) {
      +    next unless $f =~ /$match/;
      +    print "\n=== $f ===\n\n";
      +    my $info = 0;
      +    if ($API{$f}{base} || $API{$f}{todo}) {
      +      my $base = format_version($API{$f}{base} || $API{$f}{todo});
      +      print "Supported at least starting from perl-$base.\n";
      +      $info++;
      +    }
      +    if ($API{$f}{provided}) {
      +      my $todo = $API{$f}{todo} ? format_version($API{$f}{todo}) : "5.003";
      +      print "Support by $ppport provided back to perl-$todo.\n";
      +      print "Support needs to be explicitly requested by NEED_$f.\n" if exists $need{$f};
      +      print "Depends on: ", join(', ', @{$depends{$f}}), ".\n" if exists $depends{$f};
      +      print "\n$hints{$f}" if exists $hints{$f};
      +      print "\nWARNING:\n$warnings{$f}" if exists $warnings{$f};
      +      $info++;
      +    }
      +    print "No portability information available.\n" unless $info;
      +    $count++;
      +  }
      +  $count or print "Found no API matching '$opt{'api-info'}'.";
      +  print "\n";
      +  exit 0;
      +}
      +
      +if (exists $opt{'list-provided'}) {
      +  my $f;
      +  for $f (sort { lc $a cmp lc $b } keys %API) {
      +    next unless $API{$f}{provided};
      +    my @flags;
      +    push @flags, 'explicit' if exists $need{$f};
      +    push @flags, 'depend'   if exists $depends{$f};
      +    push @flags, 'hint'     if exists $hints{$f};
      +    push @flags, 'warning'  if exists $warnings{$f};
      +    my $flags = @flags ? '  ['.join(', ', @flags).']' : '';
      +    print "$f$flags\n";
      +  }
      +  exit 0;
      +}
      +
      +my @files;
      +my @srcext = qw( .xs .c .h .cc .cpp -c.inc -xs.inc );
      +my $srcext = join '|', map { quotemeta $_ } @srcext;
      +
      +if (@ARGV) {
      +  my %seen;
      +  for (@ARGV) {
      +    if (-e) {
      +      if (-f) {
      +        push @files, $_ unless $seen{$_}++;
      +      }
      +      else { warn "'$_' is not a file.\n" }
      +    }
      +    else {
      +      my @new = grep { -f } glob $_
      +          or warn "'$_' does not exist.\n";
      +      push @files, grep { !$seen{$_}++ } @new;
      +    }
      +  }
      +}
      +else {
      +  eval {
      +    require File::Find;
      +    File::Find::find(sub {
      +      $File::Find::name =~ /($srcext)$/i
      +          and push @files, $File::Find::name;
      +    }, '.');
      +  };
      +  if ($@) {
      +    @files = map { glob "*$_" } @srcext;
      +  }
      +}
      +
      +if (!@ARGV || $opt{filter}) {
      +  my(@in, @out);
      +  my %xsc = map { /(.*)\.xs$/ ? ("$1.c" => 1, "$1.cc" => 1) : () } @files;
      +  for (@files) {
      +    my $out = exists $xsc{$_} || /\b\Q$ppport\E$/i || !/($srcext)$/i;
      +    push @{ $out ? \@out : \@in }, $_;
      +  }
      +  if (@ARGV && @out) {
      +    warning("Skipping the following files (use --nofilter to avoid this):\n| ", join "\n| ", @out);
      +  }
      +  @files = @in;
      +}
      +
      +die "No input files given!\n" unless @files;
      +
      +my(%files, %global, %revreplace);
      +%revreplace = reverse %replace;
      +my $filename;
      +my $patch_opened = 0;
      +
      +for $filename (@files) {
      +  unless (open IN, "<$filename") {
      +    warn "Unable to read from $filename: $!\n";
      +    next;
      +  }
      +
      +  info("Scanning $filename ...");
      +
      +  my $c = do { local $/; <IN> };
      +  close IN;
      +
      +  my %file = (orig => $c, changes => 0);
      +
      +  # Temporarily remove C/XS comments and strings from the code
      +  my @ccom;
      +
      +  $c =~ s{
      +    ( ^$HS*\#$HS*include\b[^\r\n]+\b(?:\Q$ppport\E|XSUB\.h)\b[^\r\n]*
      +    | ^$HS*\#$HS*(?:define|elif|if(?:def)?)\b[^\r\n]* )
      +  | ( ^$HS*\#[^\r\n]*
      +    | "[^"\\]*(?:\\.[^"\\]*)*"
      +    | '[^'\\]*(?:\\.[^'\\]*)*'
      +    | / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]* ) )
      +  }{ defined $2 and push @ccom, $2;
      +     defined $1 ? $1 : "$ccs$#ccom$cce" }mgsex;
      +
      +  $file{ccom} = \@ccom;
      +  $file{code} = $c;
      +  $file{has_inc_ppport} = $c =~ /^$HS*#$HS*include[^\r\n]+\b\Q$ppport\E\b/m;
      +
      +  my $func;
      +
      +  for $func (keys %API) {
      +    my $match = $func;
      +    $match .= "|$revreplace{$func}" if exists $revreplace{$func};
      +    if ($c =~ /\b(?:Perl_)?($match)\b/) {
      +      $file{uses_replace}{$1}++ if exists $revreplace{$func} && $1 eq $revreplace{$func};
      +      $file{uses_Perl}{$func}++ if $c =~ /\bPerl_$func\b/;
      +      if (exists $API{$func}{provided}) {
      +        $file{uses_provided}{$func}++;
      +        if (!exists $API{$func}{base} || $API{$func}{base} > $opt{'compat-version'}) {
      +          $file{uses}{$func}++;
      +          my @deps = rec_depend($func);
      +          if (@deps) {
      +            $file{uses_deps}{$func} = \@deps;
      +            for (@deps) {
      +              $file{uses}{$_} = 0 unless exists $file{uses}{$_};
      +            }
      +          }
      +          for ($func, @deps) {
      +            $file{needs}{$_} = 'static' if exists $need{$_};
      +          }
      +        }
      +      }
      +      if (exists $API{$func}{todo} && $API{$func}{todo} > $opt{'compat-version'}) {
      +        if ($c =~ /\b$func\b/) {
      +          $file{uses_todo}{$func}++;
      +        }
      +      }
      +    }
      +  }
      +
      +  while ($c =~ /^$HS*#$HS*define$HS+(NEED_(\w+?)(_GLOBAL)?)\b/mg) {
      +    if (exists $need{$2}) {
      +      $file{defined $3 ? 'needed_global' : 'needed_static'}{$2}++;
      +    }
      +    else { warning("Possibly wrong #define $1 in $filename") }
      +  }
      +
      +  for (qw(uses needs uses_todo needed_global needed_static)) {
      +    for $func (keys %{$file{$_}}) {
      +      push @{$global{$_}{$func}}, $filename;
      +    }
      +  }
      +
      +  $files{$filename} = \%file;
      +}
      +
      +# Globally resolve NEED_'s
      +my $need;
      +for $need (keys %{$global{needs}}) {
      +  if (@{$global{needs}{$need}} > 1) {
      +    my @targets = @{$global{needs}{$need}};
      +    my @t = grep $files{$_}{needed_global}{$need}, @targets;
      +    @targets = @t if @t;
      +    @t = grep /\.xs$/i, @targets;
      +    @targets = @t if @t;
      +    my $target = shift @targets;
      +    $files{$target}{needs}{$need} = 'global';
      +    for (@{$global{needs}{$need}}) {
      +      $files{$_}{needs}{$need} = 'extern' if $_ ne $target;
      +    }
      +  }
      +}
      +
      +for $filename (@files) {
      +  exists $files{$filename} or next;
      +
      +  info("=== Analyzing $filename ===");
      +
      +  my %file = %{$files{$filename}};
      +  my $func;
      +  my $c = $file{code};
      +  my $warnings = 0;
      +
      +  for $func (sort keys %{$file{uses_Perl}}) {
      +    if ($API{$func}{varargs}) {
      +      unless ($API{$func}{nothxarg}) {
      +        my $changes = ($c =~ s{\b(Perl_$func\s*\(\s*)(?!aTHX_?)(\)|[^\s)]*\))}
      +                              { $1 . ($2 eq ')' ? 'aTHX' : 'aTHX_ ') . $2 }ge);
      +        if ($changes) {
      +          warning("Doesn't pass interpreter argument aTHX to Perl_$func");
      +          $file{changes} += $changes;
      +        }
      +      }
      +    }
      +    else {
      +      warning("Uses Perl_$func instead of $func");
      +      $file{changes} += ($c =~ s{\bPerl_$func(\s*)\((\s*aTHX_?)?\s*}
      +                                {$func$1(}g);
      +    }
      +  }
      +
      +  for $func (sort keys %{$file{uses_replace}}) {
      +    warning("Uses $func instead of $replace{$func}");
      +    $file{changes} += ($c =~ s/\b$func\b/$replace{$func}/g);
      +  }
      +
      +  for $func (sort keys %{$file{uses_provided}}) {
      +    if ($file{uses}{$func}) {
      +      if (exists $file{uses_deps}{$func}) {
      +        diag("Uses $func, which depends on ", join(', ', @{$file{uses_deps}{$func}}));
      +      }
      +      else {
      +        diag("Uses $func");
      +      }
      +    }
      +    $warnings += hint($func);
      +  }
      +
      +  unless ($opt{quiet}) {
      +    for $func (sort keys %{$file{uses_todo}}) {
      +      print "*** WARNING: Uses $func, which may not be portable below perl ",
      +            format_version($API{$func}{todo}), ", even with '$ppport'\n";
      +      $warnings++;
      +    }
      +  }
      +
      +  for $func (sort keys %{$file{needed_static}}) {
      +    my $message = '';
      +    if (not exists $file{uses}{$func}) {
      +      $message = "No need to define NEED_$func if $func is never used";
      +    }
      +    elsif (exists $file{needs}{$func} && $file{needs}{$func} ne 'static') {
      +      $message = "No need to define NEED_$func when already needed globally";
      +    }
      +    if ($message) {
      +      diag($message);
      +      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_$func\b.*$LF//mg);
      +    }
      +  }
      +
      +  for $func (sort keys %{$file{needed_global}}) {
      +    my $message = '';
      +    if (not exists $global{uses}{$func}) {
      +      $message = "No need to define NEED_${func}_GLOBAL if $func is never used";
      +    }
      +    elsif (exists $file{needs}{$func}) {
      +      if ($file{needs}{$func} eq 'extern') {
      +        $message = "No need to define NEED_${func}_GLOBAL when already needed globally";
      +      }
      +      elsif ($file{needs}{$func} eq 'static') {
      +        $message = "No need to define NEED_${func}_GLOBAL when only used in this file";
      +      }
      +    }
      +    if ($message) {
      +      diag($message);
      +      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_${func}_GLOBAL\b.*$LF//mg);
      +    }
      +  }
      +
      +  $file{needs_inc_ppport} = keys %{$file{uses}};
      +
      +  if ($file{needs_inc_ppport}) {
      +    my $pp = '';
      +
      +    for $func (sort keys %{$file{needs}}) {
      +      my $type = $file{needs}{$func};
      +      next if $type eq 'extern';
      +      my $suffix = $type eq 'global' ? '_GLOBAL' : '';
      +      unless (exists $file{"needed_$type"}{$func}) {
      +        if ($type eq 'global') {
      +          diag("Files [@{$global{needs}{$func}}] need $func, adding global request");
      +        }
      +        else {
      +          diag("File needs $func, adding static request");
      +        }
      +        $pp .= "#define NEED_$func$suffix\n";
      +      }
      +    }
      +
      +    if ($pp && ($c =~ s/^(?=$HS*#$HS*define$HS+NEED_\w+)/$pp/m)) {
      +      $pp = '';
      +      $file{changes}++;
      +    }
      +
      +    unless ($file{has_inc_ppport}) {
      +      diag("Needs to include '$ppport'");
      +      $pp .= qq(#include "$ppport"\n)
      +    }
      +
      +    if ($pp) {
      +      $file{changes} += ($c =~ s/^($HS*#$HS*define$HS+NEED_\w+.*?)^/$1$pp/ms)
      +                     || ($c =~ s/^(?=$HS*#$HS*include.*\Q$ppport\E)/$pp/m)
      +                     || ($c =~ s/^($HS*#$HS*include.*XSUB.*\s*?)^/$1$pp/m)
      +                     || ($c =~ s/^/$pp/);
      +    }
      +  }
      +  else {
      +    if ($file{has_inc_ppport}) {
      +      diag("No need to include '$ppport'");
      +      $file{changes} += ($c =~ s/^$HS*?#$HS*include.*\Q$ppport\E.*?$LF//m);
      +    }
      +  }
      +
      +  # put back in our C comments
      +  my $ix;
      +  my $cppc = 0;
      +  my @ccom = @{$file{ccom}};
      +  for $ix (0 .. $#ccom) {
      +    if (!$opt{cplusplus} && $ccom[$ix] =~ s!^//!!) {
      +      $cppc++;
      +      $file{changes} += $c =~ s/$rccs$ix$rcce/$ccs$ccom[$ix] $cce/;
      +    }
      +    else {
      +      $c =~ s/$rccs$ix$rcce/$ccom[$ix]/;
      +    }
      +  }
      +
      +  if ($cppc) {
      +    my $s = $cppc != 1 ? 's' : '';
      +    warning("Uses $cppc C++ style comment$s, which is not portable");
      +  }
      +
      +  my $s = $warnings != 1 ? 's' : '';
      +  my $warn = $warnings ? " ($warnings warning$s)" : '';
      +  info("Analysis completed$warn");
      +
      +  if ($file{changes}) {
      +    if (exists $opt{copy}) {
      +      my $newfile = "$filename$opt{copy}";
      +      if (-e $newfile) {
      +        error("'$newfile' already exists, refusing to write copy of '$filename'");
      +      }
      +      else {
      +        local *F;
      +        if (open F, ">$newfile") {
      +          info("Writing copy of '$filename' with changes to '$newfile'");
      +          print F $c;
      +          close F;
      +        }
      +        else {
      +          error("Cannot open '$newfile' for writing: $!");
      +        }
      +      }
      +    }
      +    elsif (exists $opt{patch} || $opt{changes}) {
      +      if (exists $opt{patch}) {
      +        unless ($patch_opened) {
      +          if (open PATCH, ">$opt{patch}") {
      +            $patch_opened = 1;
      +          }
      +          else {
      +            error("Cannot open '$opt{patch}' for writing: $!");
      +            delete $opt{patch};
      +            $opt{changes} = 1;
      +            goto fallback;
      +          }
      +        }
      +        mydiff(\*PATCH, $filename, $c);
      +      }
      +      else {
      +fallback:
      +        info("Suggested changes:");
      +        mydiff(\*STDOUT, $filename, $c);
      +      }
      +    }
      +    else {
      +      my $s = $file{changes} == 1 ? '' : 's';
      +      info("$file{changes} potentially required change$s detected");
      +    }
      +  }
      +  else {
      +    info("Looks good");
      +  }
      +}
      +
      +close PATCH if $patch_opened;
      +
      +exit 0;
      +
      +
      +sub try_use { eval "use @_;"; return $@ eq '' }
      +
      +sub mydiff
      +{
      +  local *F = shift;
      +  my($file, $str) = @_;
      +  my $diff;
      +
      +  if (exists $opt{diff}) {
      +    $diff = run_diff($opt{diff}, $file, $str);
      +  }
      +
      +  if (!defined $diff and try_use('Text::Diff')) {
      +    $diff = Text::Diff::diff($file, \$str, { STYLE => 'Unified' });
      +    $diff = <<HEADER . $diff;
      +--- $file
      ++++ $file.patched
      +HEADER
      +  }
      +
      +  if (!defined $diff) {
      +    $diff = run_diff('diff -u', $file, $str);
      +  }
      +
      +  if (!defined $diff) {
      +    $diff = run_diff('diff', $file, $str);
      +  }
      +
      +  if (!defined $diff) {
      +    error("Cannot generate a diff. Please install Text::Diff or use --copy.");
      +    return;
      +  }
      +
      +  print F $diff;
      +}
      +
      +sub run_diff
      +{
      +  my($prog, $file, $str) = @_;
      +  my $tmp = 'dppptemp';
      +  my $suf = 'aaa';
      +  my $diff = '';
      +  local *F;
      +
      +  while (-e "$tmp.$suf") { $suf++ }
      +  $tmp = "$tmp.$suf";
      +
      +  if (open F, ">$tmp") {
      +    print F $str;
      +    close F;
      +
      +    if (open F, "$prog $file $tmp |") {
      +      while (<F>) {
      +        s/\Q$tmp\E/$file.patched/;
      +        $diff .= $_;
      +      }
      +      close F;
      +      unlink $tmp;
      +      return $diff;
      +    }
      +
      +    unlink $tmp;
      +  }
      +  else {
      +    error("Cannot open '$tmp' for writing: $!");
      +  }
      +
      +  return undef;
      +}
      +
      +sub rec_depend
      +{
      +  my($func, $seen) = @_;
      +  return () unless exists $depends{$func};
      +  $seen = {%{$seen||{}}};
      +  return () if $seen->{$func}++;
      +  my %s;
      +  grep !$s{$_}++, map { ($_, rec_depend($_, $seen)) } @{$depends{$func}};
      +}
      +
      +sub parse_version
      +{
      +  my $ver = shift;
      +
      +  if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {
      +    return ($1, $2, $3);
      +  }
      +  elsif ($ver !~ /^\d+\.[\d_]+$/) {
      +    die "cannot parse version '$ver'\n";
      +  }
      +
      +  $ver =~ s/_//g;
      +  $ver =~ s/$/000000/;
      +
      +  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;
      +
      +  $v = int $v;
      +  $s = int $s;
      +
      +  if ($r < 5 || ($r == 5 && $v < 6)) {
      +    if ($s % 10) {
      +      die "cannot parse version '$ver'\n";
      +    }
      +  }
      +
      +  return ($r, $v, $s);
      +}
      +
      +sub format_version
      +{
      +  my $ver = shift;
      +
      +  $ver =~ s/$/000000/;
      +  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;
      +
      +  $v = int $v;
      +  $s = int $s;
      +
      +  if ($r < 5 || ($r == 5 && $v < 6)) {
      +    if ($s % 10) {
      +      die "invalid version '$ver'\n";
      +    }
      +    $s /= 10;
      +
      +    $ver = sprintf "%d.%03d", $r, $v;
      +    $s > 0 and $ver .= sprintf "_%02d", $s;
      +
      +    return $ver;
      +  }
      +
      +  return sprintf "%d.%d.%d", $r, $v, $s;
      +}
      +
      +sub info
      +{
      +  $opt{quiet} and return;
      +  print @_, "\n";
      +}
      +
      +sub diag
      +{
      +  $opt{quiet} and return;
      +  $opt{diag} and print @_, "\n";
      +}
      +
      +sub warning
      +{
      +  $opt{quiet} and return;
      +  print "*** ", @_, "\n";
      +}
      +
      +sub error
      +{
      +  print "*** ERROR: ", @_, "\n";
      +}
      +
      +my %given_hints;
      +my %given_warnings;
      +sub hint
      +{
      +  $opt{quiet} and return;
      +  my $func = shift;
      +  my $rv = 0;
      +  if (exists $warnings{$func} && !$given_warnings{$func}++) {
      +    my $warn = $warnings{$func};
      +    $warn =~ s!^!*** !mg;
      +    print "*** WARNING: $func\n", $warn;
      +    $rv++;
      +  }
      +  if ($opt{hints} && exists $hints{$func} && !$given_hints{$func}++) {
      +    my $hint = $hints{$func};
      +    $hint =~ s/^/   /mg;
      +    print "   --- hint for $func ---\n", $hint;
      +  }
      +  $rv;
      +}
      +
      +sub usage
      +{
      +  my($usage) = do { local(@ARGV,$/)=($0); <> } =~ /^=head\d$HS+SYNOPSIS\s*^(.*?)\s*^=/ms;
      +  my %M = ( 'I' => '*' );
      +  $usage =~ s/^\s*perl\s+\S+/$^X $0/;
      +  $usage =~ s/([A-Z])<([^>]+)>/$M{$1}$2$M{$1}/g;
      +
      +  print <<ENDUSAGE;
      +
      +Usage: $usage
      +
      +See perldoc $0 for details.
      +
      +ENDUSAGE
      +
      +  exit 2;
      +}
      +
      +sub strip
      +{
      +  my $self = do { local(@ARGV,$/)=($0); <> };
      +  my($copy) = $self =~ /^=head\d\s+COPYRIGHT\s*^(.*?)^=\w+/ms;
      +  $copy =~ s/^(?=\S+)/    /gms;
      +  $self =~ s/^$HS+Do NOT edit.*?(?=^-)/$copy/ms;
      +  $self =~ s/^SKIP.*(?=^__DATA__)/SKIP
      +if (\@ARGV && \$ARGV[0] eq '--unstrip') {
      +  eval { require Devel::PPPort };
      +  \$@ and die "Cannot require Devel::PPPort, please install.\\n";
      +  if (eval \$Devel::PPPort::VERSION < $VERSION) {
      +    die "$0 was originally generated with Devel::PPPort $VERSION.\\n"
      +      . "Your Devel::PPPort is only version \$Devel::PPPort::VERSION.\\n"
      +      . "Please install a newer version, or --unstrip will not work.\\n";
      +  }
      +  Devel::PPPort::WriteFile(\$0);
      +  exit 0;
      +}
      +print <<END;
      +
      +Sorry, but this is a stripped version of \$0.
      +
      +To be able to use its original script and doc functionality,
      +please try to regenerate this file using:
      +
      +  \$^X \$0 --unstrip
      +
      +END
      +/ms;
      +  my($pl, $c) = $self =~ /(.*^__DATA__)(.*)/ms;
      +  $c =~ s{
      +    / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)
      +  | ( "[^"\\]*(?:\\.[^"\\]*)*"
      +    | '[^'\\]*(?:\\.[^'\\]*)*' )
      +  | ($HS+) }{ defined $2 ? ' ' : ($1 || '') }gsex;
      +  $c =~ s!\s+$!!mg;
      +  $c =~ s!^$LF!!mg;
      +  $c =~ s!^\s*#\s*!#!mg;
      +  $c =~ s!^\s+!!mg;
      +
      +  open OUT, ">$0" or die "cannot strip $0: $!\n";
      +  print OUT "$pl$c\n";
      +
      +  exit 0;
      +}
      +
      +__DATA__
      +*/
      +
      +#ifndef _P_P_PORTABILITY_H_
      +#define _P_P_PORTABILITY_H_
      +
      +#ifndef DPPP_NAMESPACE
      +#  define DPPP_NAMESPACE DPPP_
      +#endif
      +
      +#define DPPP_CAT2(x,y) CAT2(x,y)
      +#define DPPP_(name) DPPP_CAT2(DPPP_NAMESPACE, name)
      +
      +#ifndef PERL_REVISION
      +#  if !defined(__PATCHLEVEL_H_INCLUDED__) && !(defined(PATCHLEVEL) && defined(SUBVERSION))
      +#    define PERL_PATCHLEVEL_H_IMPLICIT
      +#    include <patchlevel.h>
      +#  endif
      +#  if !(defined(PERL_VERSION) || (defined(SUBVERSION) && defined(PATCHLEVEL)))
      +#    include <could_not_find_Perl_patchlevel.h>
      +#  endif
      +#  ifndef PERL_REVISION
      +#    define PERL_REVISION       (5)
      +     /* Replace: 1 */
      +#    define PERL_VERSION        PATCHLEVEL
      +#    define PERL_SUBVERSION     SUBVERSION
      +     /* Replace PERL_PATCHLEVEL with PERL_VERSION */
      +     /* Replace: 0 */
      +#  endif
      +#endif
      +
      +#define _dpppDEC2BCD(dec) ((((dec)/100)<<8)|((((dec)%100)/10)<<4)|((dec)%10))
      +#define PERL_BCDVERSION ((_dpppDEC2BCD(PERL_REVISION)<<24)|(_dpppDEC2BCD(PERL_VERSION)<<12)|_dpppDEC2BCD(PERL_SUBVERSION))
      +
      +/* It is very unlikely that anyone will try to use this with Perl 6
      +   (or greater), but who knows.
      + */
      +#if PERL_REVISION != 5
      +#  error ppport.h only works with Perl version 5
      +#endif /* PERL_REVISION != 5 */
      +#ifndef dTHR
      +#  define dTHR                           dNOOP
      +#endif
      +#ifndef dTHX
      +#  define dTHX                           dNOOP
      +#endif
      +
      +#ifndef dTHXa
      +#  define dTHXa(x)                       dNOOP
      +#endif
      +#ifndef pTHX
      +#  define pTHX                           void
      +#endif
      +
      +#ifndef pTHX_
      +#  define pTHX_
      +#endif
      +
      +#ifndef aTHX
      +#  define aTHX
      +#endif
      +
      +#ifndef aTHX_
      +#  define aTHX_
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5006000)
      +#  ifdef USE_THREADS
      +#    define aTHXR  thr
      +#    define aTHXR_ thr,
      +#  else
      +#    define aTHXR
      +#    define aTHXR_
      +#  endif
      +#  define dTHXR  dTHR
      +#else
      +#  define aTHXR  aTHX
      +#  define aTHXR_ aTHX_
      +#  define dTHXR  dTHX
      +#endif
      +#ifndef dTHXoa
      +#  define dTHXoa(x)                      dTHXa(x)
      +#endif
      +
      +#ifdef I_LIMITS
      +#  include <limits.h>
      +#endif
      +
      +#ifndef PERL_UCHAR_MIN
      +#  define PERL_UCHAR_MIN ((unsigned char)0)
      +#endif
      +
      +#ifndef PERL_UCHAR_MAX
      +#  ifdef UCHAR_MAX
      +#    define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
      +#  else
      +#    ifdef MAXUCHAR
      +#      define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
      +#    else
      +#      define PERL_UCHAR_MAX ((unsigned char)~(unsigned)0)
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_USHORT_MIN
      +#  define PERL_USHORT_MIN ((unsigned short)0)
      +#endif
      +
      +#ifndef PERL_USHORT_MAX
      +#  ifdef USHORT_MAX
      +#    define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
      +#  else
      +#    ifdef MAXUSHORT
      +#      define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
      +#    else
      +#      ifdef USHRT_MAX
      +#        define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
      +#      else
      +#        define PERL_USHORT_MAX ((unsigned short)~(unsigned)0)
      +#      endif
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_SHORT_MAX
      +#  ifdef SHORT_MAX
      +#    define PERL_SHORT_MAX ((short)SHORT_MAX)
      +#  else
      +#    ifdef MAXSHORT    /* Often used in <values.h> */
      +#      define PERL_SHORT_MAX ((short)MAXSHORT)
      +#    else
      +#      ifdef SHRT_MAX
      +#        define PERL_SHORT_MAX ((short)SHRT_MAX)
      +#      else
      +#        define PERL_SHORT_MAX ((short) (PERL_USHORT_MAX >> 1))
      +#      endif
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_SHORT_MIN
      +#  ifdef SHORT_MIN
      +#    define PERL_SHORT_MIN ((short)SHORT_MIN)
      +#  else
      +#    ifdef MINSHORT
      +#      define PERL_SHORT_MIN ((short)MINSHORT)
      +#    else
      +#      ifdef SHRT_MIN
      +#        define PERL_SHORT_MIN ((short)SHRT_MIN)
      +#      else
      +#        define PERL_SHORT_MIN (-PERL_SHORT_MAX - ((3 & -1) == 3))
      +#      endif
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_UINT_MAX
      +#  ifdef UINT_MAX
      +#    define PERL_UINT_MAX ((unsigned int)UINT_MAX)
      +#  else
      +#    ifdef MAXUINT
      +#      define PERL_UINT_MAX ((unsigned int)MAXUINT)
      +#    else
      +#      define PERL_UINT_MAX (~(unsigned int)0)
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_UINT_MIN
      +#  define PERL_UINT_MIN ((unsigned int)0)
      +#endif
      +
      +#ifndef PERL_INT_MAX
      +#  ifdef INT_MAX
      +#    define PERL_INT_MAX ((int)INT_MAX)
      +#  else
      +#    ifdef MAXINT    /* Often used in <values.h> */
      +#      define PERL_INT_MAX ((int)MAXINT)
      +#    else
      +#      define PERL_INT_MAX ((int)(PERL_UINT_MAX >> 1))
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_INT_MIN
      +#  ifdef INT_MIN
      +#    define PERL_INT_MIN ((int)INT_MIN)
      +#  else
      +#    ifdef MININT
      +#      define PERL_INT_MIN ((int)MININT)
      +#    else
      +#      define PERL_INT_MIN (-PERL_INT_MAX - ((3 & -1) == 3))
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_ULONG_MAX
      +#  ifdef ULONG_MAX
      +#    define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
      +#  else
      +#    ifdef MAXULONG
      +#      define PERL_ULONG_MAX ((unsigned long)MAXULONG)
      +#    else
      +#      define PERL_ULONG_MAX (~(unsigned long)0)
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_ULONG_MIN
      +#  define PERL_ULONG_MIN ((unsigned long)0L)
      +#endif
      +
      +#ifndef PERL_LONG_MAX
      +#  ifdef LONG_MAX
      +#    define PERL_LONG_MAX ((long)LONG_MAX)
      +#  else
      +#    ifdef MAXLONG
      +#      define PERL_LONG_MAX ((long)MAXLONG)
      +#    else
      +#      define PERL_LONG_MAX ((long) (PERL_ULONG_MAX >> 1))
      +#    endif
      +#  endif
      +#endif
      +
      +#ifndef PERL_LONG_MIN
      +#  ifdef LONG_MIN
      +#    define PERL_LONG_MIN ((long)LONG_MIN)
      +#  else
      +#    ifdef MINLONG
      +#      define PERL_LONG_MIN ((long)MINLONG)
      +#    else
      +#      define PERL_LONG_MIN (-PERL_LONG_MAX - ((3 & -1) == 3))
      +#    endif
      +#  endif
      +#endif
      +
      +#if defined(HAS_QUAD) && (defined(convex) || defined(uts))
      +#  ifndef PERL_UQUAD_MAX
      +#    ifdef ULONGLONG_MAX
      +#      define PERL_UQUAD_MAX ((unsigned long long)ULONGLONG_MAX)
      +#    else
      +#      ifdef MAXULONGLONG
      +#        define PERL_UQUAD_MAX ((unsigned long long)MAXULONGLONG)
      +#      else
      +#        define PERL_UQUAD_MAX (~(unsigned long long)0)
      +#      endif
      +#    endif
      +#  endif
      +
      +#  ifndef PERL_UQUAD_MIN
      +#    define PERL_UQUAD_MIN ((unsigned long long)0L)
      +#  endif
      +
      +#  ifndef PERL_QUAD_MAX
      +#    ifdef LONGLONG_MAX
      +#      define PERL_QUAD_MAX ((long long)LONGLONG_MAX)
      +#    else
      +#      ifdef MAXLONGLONG
      +#        define PERL_QUAD_MAX ((long long)MAXLONGLONG)
      +#      else
      +#        define PERL_QUAD_MAX ((long long) (PERL_UQUAD_MAX >> 1))
      +#      endif
      +#    endif
      +#  endif
      +
      +#  ifndef PERL_QUAD_MIN
      +#    ifdef LONGLONG_MIN
      +#      define PERL_QUAD_MIN ((long long)LONGLONG_MIN)
      +#    else
      +#      ifdef MINLONGLONG
      +#        define PERL_QUAD_MIN ((long long)MINLONGLONG)
      +#      else
      +#        define PERL_QUAD_MIN (-PERL_QUAD_MAX - ((3 & -1) == 3))
      +#      endif
      +#    endif
      +#  endif
      +#endif
      +
      +/* This is based on code from 5.003 perl.h */
      +#ifdef HAS_QUAD
      +#  ifdef cray
      +#ifndef IVTYPE
      +#  define IVTYPE                         int
      +#endif
      +
      +#ifndef IV_MIN
      +#  define IV_MIN                         PERL_INT_MIN
      +#endif
      +
      +#ifndef IV_MAX
      +#  define IV_MAX                         PERL_INT_MAX
      +#endif
      +
      +#ifndef UV_MIN
      +#  define UV_MIN                         PERL_UINT_MIN
      +#endif
      +
      +#ifndef UV_MAX
      +#  define UV_MAX                         PERL_UINT_MAX
      +#endif
      +
      +#    ifdef INTSIZE
      +#ifndef IVSIZE
      +#  define IVSIZE                         INTSIZE
      +#endif
      +
      +#    endif
      +#  else
      +#    if defined(convex) || defined(uts)
      +#ifndef IVTYPE
      +#  define IVTYPE                         long long
      +#endif
      +
      +#ifndef IV_MIN
      +#  define IV_MIN                         PERL_QUAD_MIN
      +#endif
      +
      +#ifndef IV_MAX
      +#  define IV_MAX                         PERL_QUAD_MAX
      +#endif
      +
      +#ifndef UV_MIN
      +#  define UV_MIN                         PERL_UQUAD_MIN
      +#endif
      +
      +#ifndef UV_MAX
      +#  define UV_MAX                         PERL_UQUAD_MAX
      +#endif
      +
      +#      ifdef LONGLONGSIZE
      +#ifndef IVSIZE
      +#  define IVSIZE                         LONGLONGSIZE
      +#endif
      +
      +#      endif
      +#    else
      +#ifndef IVTYPE
      +#  define IVTYPE                         long
      +#endif
      +
      +#ifndef IV_MIN
      +#  define IV_MIN                         PERL_LONG_MIN
      +#endif
      +
      +#ifndef IV_MAX
      +#  define IV_MAX                         PERL_LONG_MAX
      +#endif
      +
      +#ifndef UV_MIN
      +#  define UV_MIN                         PERL_ULONG_MIN
      +#endif
      +
      +#ifndef UV_MAX
      +#  define UV_MAX                         PERL_ULONG_MAX
      +#endif
      +
      +#      ifdef LONGSIZE
      +#ifndef IVSIZE
      +#  define IVSIZE                         LONGSIZE
      +#endif
      +
      +#      endif
      +#    endif
      +#  endif
      +#ifndef IVSIZE
      +#  define IVSIZE                         8
      +#endif
      +
      +#ifndef LONGSIZE
      +#  define LONGSIZE                       8
      +#endif
      +
      +#ifndef PERL_QUAD_MIN
      +#  define PERL_QUAD_MIN                  IV_MIN
      +#endif
      +
      +#ifndef PERL_QUAD_MAX
      +#  define PERL_QUAD_MAX                  IV_MAX
      +#endif
      +
      +#ifndef PERL_UQUAD_MIN
      +#  define PERL_UQUAD_MIN                 UV_MIN
      +#endif
      +
      +#ifndef PERL_UQUAD_MAX
      +#  define PERL_UQUAD_MAX                 UV_MAX
      +#endif
      +
      +#else
      +#ifndef IVTYPE
      +#  define IVTYPE                         long
      +#endif
      +
      +#ifndef LONGSIZE
      +#  define LONGSIZE                       4
      +#endif
      +
      +#ifndef IV_MIN
      +#  define IV_MIN                         PERL_LONG_MIN
      +#endif
      +
      +#ifndef IV_MAX
      +#  define IV_MAX                         PERL_LONG_MAX
      +#endif
      +
      +#ifndef UV_MIN
      +#  define UV_MIN                         PERL_ULONG_MIN
      +#endif
      +
      +#ifndef UV_MAX
      +#  define UV_MAX                         PERL_ULONG_MAX
      +#endif
      +
      +#endif
      +
      +#ifndef IVSIZE
      +#  ifdef LONGSIZE
      +#    define IVSIZE LONGSIZE
      +#  else
      +#    define IVSIZE 4 /* A bold guess, but the best we can make. */
      +#  endif
      +#endif
      +#ifndef UVTYPE
      +#  define UVTYPE                         unsigned IVTYPE
      +#endif
      +
      +#ifndef UVSIZE
      +#  define UVSIZE                         IVSIZE
      +#endif
      +#ifndef sv_setuv
      +#  define sv_setuv(sv, uv)               \
      +               STMT_START {                         \
      +                 UV TeMpUv = uv;                    \
      +                 if (TeMpUv <= IV_MAX)              \
      +                   sv_setiv(sv, TeMpUv);            \
      +                 else                               \
      +                   sv_setnv(sv, (double)TeMpUv);    \
      +               } STMT_END
      +#endif
      +#ifndef newSVuv
      +#  define newSVuv(uv)                    ((uv) <= IV_MAX ? newSViv((IV)uv) : newSVnv((NV)uv))
      +#endif
      +#ifndef sv_2uv
      +#  define sv_2uv(sv)                     ((PL_Sv = (sv)), (UV) (SvNOK(PL_Sv) ? SvNV(PL_Sv) : sv_2nv(PL_Sv)))
      +#endif
      +
      +#ifndef SvUVX
      +#  define SvUVX(sv)                      ((UV)SvIVX(sv))
      +#endif
      +
      +#ifndef SvUVXx
      +#  define SvUVXx(sv)                     SvUVX(sv)
      +#endif
      +
      +#ifndef SvUV
      +#  define SvUV(sv)                       (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
      +#endif
      +
      +#ifndef SvUVx
      +#  define SvUVx(sv)                      ((PL_Sv = (sv)), SvUV(PL_Sv))
      +#endif
      +
      +/* Hint: sv_uv
      + * Always use the SvUVx() macro instead of sv_uv().
      + */
      +#ifndef sv_uv
      +#  define sv_uv(sv)                      SvUVx(sv)
      +#endif
      +
      +#if !defined(SvUOK) && defined(SvIOK_UV)
      +#  define SvUOK(sv) SvIOK_UV(sv)
      +#endif
      +#ifndef XST_mUV
      +#  define XST_mUV(i,v)                   (ST(i) = sv_2mortal(newSVuv(v))  )
      +#endif
      +
      +#ifndef XSRETURN_UV
      +#  define XSRETURN_UV(v)                 STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
      +#endif
      +#ifndef PUSHu
      +#  define PUSHu(u)                       STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG;  } STMT_END
      +#endif
      +
      +#ifndef XPUSHu
      +#  define XPUSHu(u)                      STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
      +#endif
      +
      +#ifdef HAS_MEMCMP
      +#ifndef memNE
      +#  define memNE(s1,s2,l)                 (memcmp(s1,s2,l))
      +#endif
      +
      +#ifndef memEQ
      +#  define memEQ(s1,s2,l)                 (!memcmp(s1,s2,l))
      +#endif
      +
      +#else
      +#ifndef memNE
      +#  define memNE(s1,s2,l)                 (bcmp(s1,s2,l))
      +#endif
      +
      +#ifndef memEQ
      +#  define memEQ(s1,s2,l)                 (!bcmp(s1,s2,l))
      +#endif
      +
      +#endif
      +#ifndef memEQs
      +#  define memEQs(s1, l, s2)              \
      +                   (sizeof(s2)-1 == l && memEQ(s1, (s2 ""), (sizeof(s2)-1)))
      +#endif
      +
      +#ifndef memNEs
      +#  define memNEs(s1, l, s2)              !memEQs(s1, l, s2)
      +#endif
      +#ifndef MoveD
      +#  define MoveD(s,d,n,t)                 memmove((char*)(d),(char*)(s), (n) * sizeof(t))
      +#endif
      +
      +#ifndef CopyD
      +#  define CopyD(s,d,n,t)                 memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
      +#endif
      +
      +#ifdef HAS_MEMSET
      +#ifndef ZeroD
      +#  define ZeroD(d,n,t)                   memzero((char*)(d), (n) * sizeof(t))
      +#endif
      +
      +#else
      +#ifndef ZeroD
      +#  define ZeroD(d,n,t)                   ((void)memzero((char*)(d), (n) * sizeof(t)), d)
      +#endif
      +
      +#endif
      +#ifndef PoisonWith
      +#  define PoisonWith(d,n,t,b)            (void)memset((char*)(d), (U8)(b), (n) * sizeof(t))
      +#endif
      +
      +#ifndef PoisonNew
      +#  define PoisonNew(d,n,t)               PoisonWith(d,n,t,0xAB)
      +#endif
      +
      +#ifndef PoisonFree
      +#  define PoisonFree(d,n,t)              PoisonWith(d,n,t,0xEF)
      +#endif
      +
      +#ifndef Poison
      +#  define Poison(d,n,t)                  PoisonFree(d,n,t)
      +#endif
      +#ifndef Newx
      +#  define Newx(v,n,t)                    New(0,v,n,t)
      +#endif
      +
      +#ifndef Newxc
      +#  define Newxc(v,n,t,c)                 Newc(0,v,n,t,c)
      +#endif
      +
      +#ifndef Newxz
      +#  define Newxz(v,n,t)                   Newz(0,v,n,t)
      +#endif
      +#ifndef PERL_MAGIC_qr
      +#  define PERL_MAGIC_qr                  'r'
      +#endif
      +#ifndef cBOOL
      +#  define cBOOL(cbool)                   ((cbool) ? (bool)1 : (bool)0)
      +#endif
      +
      +#ifndef OpHAS_SIBLING
      +#  define OpHAS_SIBLING(o)               (cBOOL((o)->op_sibling))
      +#endif
      +
      +#ifndef OpSIBLING
      +#  define OpSIBLING(o)                   (0 + (o)->op_sibling)
      +#endif
      +
      +#ifndef OpMORESIB_set
      +#  define OpMORESIB_set(o, sib)          ((o)->op_sibling = (sib))
      +#endif
      +
      +#ifndef OpLASTSIB_set
      +#  define OpLASTSIB_set(o, parent)       ((o)->op_sibling = NULL)
      +#endif
      +
      +#ifndef OpMAYBESIB_set
      +#  define OpMAYBESIB_set(o, sib, parent) ((o)->op_sibling = (sib))
      +#endif
      +
      +#ifndef SvRX
      +#if defined(NEED_SvRX)
      +static void * DPPP_(my_SvRX)(pTHX_ SV *rv);
      +static
      +#else
      +extern void * DPPP_(my_SvRX)(pTHX_ SV *rv);
      +#endif
      +
      +#ifdef SvRX
      +#  undef SvRX
      +#endif
      +#define SvRX(a) DPPP_(my_SvRX)(aTHX_ a)
      +
      +#if defined(NEED_SvRX) || defined(NEED_SvRX_GLOBAL)
      +
      +void *
      +DPPP_(my_SvRX)(pTHX_ SV *rv)
      +{
      +	if (SvROK(rv)) {
      +		SV *sv = SvRV(rv);
      +		if (SvMAGICAL(sv)) {
      +			MAGIC *mg = mg_find(sv, PERL_MAGIC_qr);
      +			if (mg && mg->mg_obj) {
      +				return mg->mg_obj;
      +			}
      +		}
      +	}
      +	return 0;
      +}
      +#endif
      +#endif
      +#ifndef SvRXOK
      +#  define SvRXOK(sv)                     (!!SvRX(sv))
      +#endif
      +
      +#ifndef PERL_UNUSED_DECL
      +#  ifdef HASATTRIBUTE
      +#    if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
      +#      define PERL_UNUSED_DECL
      +#    else
      +#      define PERL_UNUSED_DECL __attribute__((unused))
      +#    endif
      +#  else
      +#    define PERL_UNUSED_DECL
      +#  endif
      +#endif
      +
      +#ifndef PERL_UNUSED_ARG
      +#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
      +#    include <note.h>
      +#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
      +#  else
      +#    define PERL_UNUSED_ARG(x) ((void)x)
      +#  endif
      +#endif
      +
      +#ifndef PERL_UNUSED_VAR
      +#  define PERL_UNUSED_VAR(x) ((void)x)
      +#endif
      +
      +#ifndef PERL_UNUSED_CONTEXT
      +#  ifdef USE_ITHREADS
      +#    define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
      +#  else
      +#    define PERL_UNUSED_CONTEXT
      +#  endif
      +#endif
      +
      +#ifndef PERL_UNUSED_RESULT
      +#  if defined(__GNUC__) && defined(HASATTRIBUTE_WARN_UNUSED_RESULT)
      +#    define PERL_UNUSED_RESULT(v) STMT_START { __typeof__(v) z = (v); (void)sizeof(z); } STMT_END
      +#  else
      +#    define PERL_UNUSED_RESULT(v) ((void)(v))
      +#  endif
      +#endif
      +#ifndef NOOP
      +#  define NOOP                           /*EMPTY*/(void)0
      +#endif
      +
      +#ifndef dNOOP
      +#  define dNOOP                          extern int /*@unused@*/ Perl___notused PERL_UNUSED_DECL
      +#endif
      +
      +#ifndef NVTYPE
      +#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
      +#    define NVTYPE long double
      +#  else
      +#    define NVTYPE double
      +#  endif
      +typedef NVTYPE NV;
      +#endif
      +
      +#ifndef INT2PTR
      +#  if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
      +#    define PTRV                  UV
      +#    define INT2PTR(any,d)        (any)(d)
      +#  else
      +#    if PTRSIZE == LONGSIZE
      +#      define PTRV                unsigned long
      +#    else
      +#      define PTRV                unsigned
      +#    endif
      +#    define INT2PTR(any,d)        (any)(PTRV)(d)
      +#  endif
      +#endif
      +
      +#ifndef PTR2ul
      +#  if PTRSIZE == LONGSIZE
      +#    define PTR2ul(p)     (unsigned long)(p)
      +#  else
      +#    define PTR2ul(p)     INT2PTR(unsigned long,p)
      +#  endif
      +#endif
      +#ifndef PTR2nat
      +#  define PTR2nat(p)                     (PTRV)(p)
      +#endif
      +
      +#ifndef NUM2PTR
      +#  define NUM2PTR(any,d)                 (any)PTR2nat(d)
      +#endif
      +
      +#ifndef PTR2IV
      +#  define PTR2IV(p)                      INT2PTR(IV,p)
      +#endif
      +
      +#ifndef PTR2UV
      +#  define PTR2UV(p)                      INT2PTR(UV,p)
      +#endif
      +
      +#ifndef PTR2NV
      +#  define PTR2NV(p)                      NUM2PTR(NV,p)
      +#endif
      +
      +#undef START_EXTERN_C
      +#undef END_EXTERN_C
      +#undef EXTERN_C
      +#ifdef __cplusplus
      +#  define START_EXTERN_C extern "C" {
      +#  define END_EXTERN_C }
      +#  define EXTERN_C extern "C"
      +#else
      +#  define START_EXTERN_C
      +#  define END_EXTERN_C
      +#  define EXTERN_C extern
      +#endif
      +
      +#if defined(PERL_GCC_PEDANTIC)
      +#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
      +#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
      +#  endif
      +#endif
      +
      +#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
      +#  ifndef PERL_USE_GCC_BRACE_GROUPS
      +#    define PERL_USE_GCC_BRACE_GROUPS
      +#  endif
      +#endif
      +
      +#undef STMT_START
      +#undef STMT_END
      +#ifdef PERL_USE_GCC_BRACE_GROUPS
      +#  define STMT_START    (void)( /* gcc supports ``({ STATEMENTS; })'' */
      +#  define STMT_END      )
      +#else
      +#  if defined(VOIDFLAGS) && (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
      +#    define STMT_START  if (1)
      +#    define STMT_END    else (void)0
      +#  else
      +#    define STMT_START  do
      +#    define STMT_END    while (0)
      +#  endif
      +#endif
      +#ifndef boolSV
      +#  define boolSV(b)                      ((b) ? &PL_sv_yes : &PL_sv_no)
      +#endif
      +
      +/* DEFSV appears first in 5.004_56 */
      +#ifndef DEFSV
      +#  define DEFSV                          GvSV(PL_defgv)
      +#endif
      +
      +#ifndef SAVE_DEFSV
      +#  define SAVE_DEFSV                     SAVESPTR(GvSV(PL_defgv))
      +#endif
      +
      +#ifndef DEFSV_set
      +#  define DEFSV_set(sv)                  (DEFSV = (sv))
      +#endif
      +
      +/* Older perls (<=5.003) lack AvFILLp */
      +#ifndef AvFILLp
      +#  define AvFILLp                        AvFILL
      +#endif
      +#ifndef ERRSV
      +#  define ERRSV                          get_sv("@",FALSE)
      +#endif
      +
      +/* Hint: gv_stashpvn
      + * This function's backport doesn't support the length parameter, but
      + * rather ignores it. Portability can only be ensured if the length
      + * parameter is used for speed reasons, but the length can always be
      + * correctly computed from the string argument.
      + */
      +#ifndef gv_stashpvn
      +#  define gv_stashpvn(str,len,create)    gv_stashpv(str,create)
      +#endif
      +
      +/* Replace: 1 */
      +#ifndef get_cv
      +#  define get_cv                         perl_get_cv
      +#endif
      +
      +#ifndef get_sv
      +#  define get_sv                         perl_get_sv
      +#endif
      +
      +#ifndef get_av
      +#  define get_av                         perl_get_av
      +#endif
      +
      +#ifndef get_hv
      +#  define get_hv                         perl_get_hv
      +#endif
      +
      +/* Replace: 0 */
      +#ifndef dUNDERBAR
      +#  define dUNDERBAR                      dNOOP
      +#endif
      +
      +#ifndef UNDERBAR
      +#  define UNDERBAR                       DEFSV
      +#endif
      +#ifndef dAX
      +#  define dAX                            I32 ax = MARK - PL_stack_base + 1
      +#endif
      +
      +#ifndef dITEMS
      +#  define dITEMS                         I32 items = SP - MARK
      +#endif
      +#ifndef dXSTARG
      +#  define dXSTARG                        SV * targ = sv_newmortal()
      +#endif
      +#ifndef dAXMARK
      +#  define dAXMARK                        I32 ax = POPMARK; \
      +                               register SV ** const mark = PL_stack_base + ax++
      +#endif
      +#ifndef XSprePUSH
      +#  define XSprePUSH                      (sp = PL_stack_base + ax - 1)
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5005000)
      +#  undef XSRETURN
      +#  define XSRETURN(off)                                   \
      +      STMT_START {                                        \
      +          PL_stack_sp = PL_stack_base + ax + ((off) - 1); \
      +          return;                                         \
      +      } STMT_END
      +#endif
      +#ifndef XSPROTO
      +#  define XSPROTO(name)                  void name(pTHX_ CV* cv)
      +#endif
      +
      +#ifndef SVfARG
      +#  define SVfARG(p)                      ((void*)(p))
      +#endif
      +#ifndef PERL_ABS
      +#  define PERL_ABS(x)                    ((x) < 0 ? -(x) : (x))
      +#endif
      +#ifndef dVAR
      +#  define dVAR                           dNOOP
      +#endif
      +#ifndef SVf
      +#  define SVf                            "_"
      +#endif
      +#ifndef UTF8_MAXBYTES
      +#  define UTF8_MAXBYTES                  UTF8_MAXLEN
      +#endif
      +#ifndef CPERLscope
      +#  define CPERLscope(x)                  x
      +#endif
      +#ifndef PERL_HASH
      +#  define PERL_HASH(hash,str,len)        \
      +     STMT_START { \
      +        const char *s_PeRlHaSh = str; \
      +        I32 i_PeRlHaSh = len; \
      +        U32 hash_PeRlHaSh = 0; \
      +        while (i_PeRlHaSh--) \
      +            hash_PeRlHaSh = hash_PeRlHaSh * 33 + *s_PeRlHaSh++; \
      +        (hash) = hash_PeRlHaSh; \
      +    } STMT_END
      +#endif
      +
      +#ifndef PERLIO_FUNCS_DECL
      +# ifdef PERLIO_FUNCS_CONST
      +#  define PERLIO_FUNCS_DECL(funcs) const PerlIO_funcs funcs
      +#  define PERLIO_FUNCS_CAST(funcs) (PerlIO_funcs*)(funcs)
      +# else
      +#  define PERLIO_FUNCS_DECL(funcs) PerlIO_funcs funcs
      +#  define PERLIO_FUNCS_CAST(funcs) (funcs)
      +# endif
      +#endif
      +
      +/* provide these typedefs for older perls */
      +#if (PERL_BCDVERSION < 0x5009003)
      +
      +# ifdef ARGSproto
      +typedef OP* (CPERLscope(*Perl_ppaddr_t))(ARGSproto);
      +# else
      +typedef OP* (CPERLscope(*Perl_ppaddr_t))(pTHX);
      +# endif
      +
      +typedef OP* (CPERLscope(*Perl_check_t)) (pTHX_ OP*);
      +
      +#endif
      +#ifndef isPSXSPC
      +#  define isPSXSPC(c)                    (isSPACE(c) || (c) == '\v')
      +#endif
      +
      +#ifndef isBLANK
      +#  define isBLANK(c)                     ((c) == ' ' || (c) == '\t')
      +#endif
      +
      +#ifdef EBCDIC
      +#ifndef isALNUMC
      +#  define isALNUMC(c)                    isalnum(c)
      +#endif
      +
      +#ifndef isASCII
      +#  define isASCII(c)                     isascii(c)
      +#endif
      +
      +#ifndef isCNTRL
      +#  define isCNTRL(c)                     iscntrl(c)
      +#endif
      +
      +#ifndef isGRAPH
      +#  define isGRAPH(c)                     isgraph(c)
      +#endif
      +
      +#ifndef isPRINT
      +#  define isPRINT(c)                     isprint(c)
      +#endif
      +
      +#ifndef isPUNCT
      +#  define isPUNCT(c)                     ispunct(c)
      +#endif
      +
      +#ifndef isXDIGIT
      +#  define isXDIGIT(c)                    isxdigit(c)
      +#endif
      +
      +#else
      +# if (PERL_BCDVERSION < 0x5010000)
      +/* Hint: isPRINT
      + * The implementation in older perl versions includes all of the
      + * isSPACE() characters, which is wrong. The version provided by
      + * Devel::PPPort always overrides a present buggy version.
      + */
      +#  undef isPRINT
      +# endif
      +
      +#ifdef HAS_QUAD
      +# ifdef U64TYPE
      +#  define WIDEST_UTYPE U64TYPE
      +# else
      +#  define WIDEST_UTYPE Quad_t
      +# endif
      +#else
      +# define WIDEST_UTYPE U32
      +#endif
      +#ifndef isALNUMC
      +#  define isALNUMC(c)                    (isALPHA(c) || isDIGIT(c))
      +#endif
      +
      +#ifndef isASCII
      +#  define isASCII(c)                     ((WIDEST_UTYPE) (c) <= 127)
      +#endif
      +
      +#ifndef isCNTRL
      +#  define isCNTRL(c)                     ((WIDEST_UTYPE) (c) < ' ' || (c) == 127)
      +#endif
      +
      +#ifndef isGRAPH
      +#  define isGRAPH(c)                     (isALNUM(c) || isPUNCT(c))
      +#endif
      +
      +#ifndef isPRINT
      +#  define isPRINT(c)                     (((c) >= 32 && (c) < 127))
      +#endif
      +
      +#ifndef isPUNCT
      +#  define isPUNCT(c)                     (((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
      +#endif
      +
      +#ifndef isXDIGIT
      +#  define isXDIGIT(c)                    (isDIGIT(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
      +#endif
      +
      +#endif
      +
      +/* Until we figure out how to support this in older perls... */
      +#if (PERL_BCDVERSION >= 0x5008000)
      +#ifndef HeUTF8
      +#  define HeUTF8(he)                     ((HeKLEN(he) == HEf_SVKEY) ?            \
      +                                 SvUTF8(HeKEY_sv(he)) :                 \
      +                                 (U32)HeKUTF8(he))
      +#endif
      +
      +#endif
      +#ifndef C_ARRAY_LENGTH
      +#  define C_ARRAY_LENGTH(a)              (sizeof(a)/sizeof((a)[0]))
      +#endif
      +
      +#ifndef C_ARRAY_END
      +#  define C_ARRAY_END(a)                 ((a) + C_ARRAY_LENGTH(a))
      +#endif
      +
      +#ifndef PERL_SIGNALS_UNSAFE_FLAG
      +
      +#define PERL_SIGNALS_UNSAFE_FLAG 0x0001
      +
      +#if (PERL_BCDVERSION < 0x5008000)
      +#  define D_PPP_PERL_SIGNALS_INIT   PERL_SIGNALS_UNSAFE_FLAG
      +#else
      +#  define D_PPP_PERL_SIGNALS_INIT   0
      +#endif
      +
      +#if defined(NEED_PL_signals)
      +static U32 DPPP_(my_PL_signals) = D_PPP_PERL_SIGNALS_INIT;
      +#elif defined(NEED_PL_signals_GLOBAL)
      +U32 DPPP_(my_PL_signals) = D_PPP_PERL_SIGNALS_INIT;
      +#else
      +extern U32 DPPP_(my_PL_signals);
      +#endif
      +#define PL_signals DPPP_(my_PL_signals)
      +
      +#endif
      +
      +/* Hint: PL_ppaddr
      + * Calling an op via PL_ppaddr requires passing a context argument
      + * for threaded builds. Since the context argument is different for
      + * 5.005 perls, you can use aTHXR (supplied by ppport.h), which will
      + * automatically be defined as the correct argument.
      + */
      +
      +#if (PERL_BCDVERSION <= 0x5005005)
      +/* Replace: 1 */
      +#  define PL_ppaddr                 ppaddr
      +#  define PL_no_modify              no_modify
      +/* Replace: 0 */
      +#endif
      +
      +#if (PERL_BCDVERSION <= 0x5004005)
      +/* Replace: 1 */
      +#  define PL_DBsignal               DBsignal
      +#  define PL_DBsingle               DBsingle
      +#  define PL_DBsub                  DBsub
      +#  define PL_DBtrace                DBtrace
      +#  define PL_Sv                     Sv
      +#  define PL_bufend                 bufend
      +#  define PL_bufptr                 bufptr
      +#  define PL_compiling              compiling
      +#  define PL_copline                copline
      +#  define PL_curcop                 curcop
      +#  define PL_curstash               curstash
      +#  define PL_debstash               debstash
      +#  define PL_defgv                  defgv
      +#  define PL_diehook                diehook
      +#  define PL_dirty                  dirty
      +#  define PL_dowarn                 dowarn
      +#  define PL_errgv                  errgv
      +#  define PL_error_count            error_count
      +#  define PL_expect                 expect
      +#  define PL_hexdigit               hexdigit
      +#  define PL_hints                  hints
      +#  define PL_in_my                  in_my
      +#  define PL_laststatval            laststatval
      +#  define PL_lex_state              lex_state
      +#  define PL_lex_stuff              lex_stuff
      +#  define PL_linestr                linestr
      +#  define PL_na                     na
      +#  define PL_perl_destruct_level    perl_destruct_level
      +#  define PL_perldb                 perldb
      +#  define PL_rsfp_filters           rsfp_filters
      +#  define PL_rsfp                   rsfp
      +#  define PL_stack_base             stack_base
      +#  define PL_stack_sp               stack_sp
      +#  define PL_statcache              statcache
      +#  define PL_stdingv                stdingv
      +#  define PL_sv_arenaroot           sv_arenaroot
      +#  define PL_sv_no                  sv_no
      +#  define PL_sv_undef               sv_undef
      +#  define PL_sv_yes                 sv_yes
      +#  define PL_tainted                tainted
      +#  define PL_tainting               tainting
      +#  define PL_tokenbuf               tokenbuf
      +/* Replace: 0 */
      +#endif
      +
      +/* Warning: PL_parser
      + * For perl versions earlier than 5.9.5, this is an always
      + * non-NULL dummy. Also, it cannot be dereferenced. Don't
      + * use it if you can avoid is and unless you absolutely know
      + * what you're doing.
      + * If you always check that PL_parser is non-NULL, you can
      + * define DPPP_PL_parser_NO_DUMMY to avoid the creation of
      + * a dummy parser structure.
      + */
      +
      +#if (PERL_BCDVERSION >= 0x5009005)
      +# ifdef DPPP_PL_parser_NO_DUMMY
      +#  define D_PPP_my_PL_parser_var(var) ((PL_parser ? PL_parser : \
      +                (croak("panic: PL_parser == NULL in %s:%d", \
      +                       __FILE__, __LINE__), (yy_parser *) NULL))->var)
      +# else
      +#  ifdef DPPP_PL_parser_NO_DUMMY_WARNING
      +#   define D_PPP_parser_dummy_warning(var)
      +#  else
      +#   define D_PPP_parser_dummy_warning(var) \
      +             warn("warning: dummy PL_" #var " used in %s:%d", __FILE__, __LINE__),
      +#  endif
      +#  define D_PPP_my_PL_parser_var(var) ((PL_parser ? PL_parser : \
      +                (D_PPP_parser_dummy_warning(var) &DPPP_(dummy_PL_parser)))->var)
      +#if defined(NEED_PL_parser)
      +static yy_parser DPPP_(dummy_PL_parser);
      +#elif defined(NEED_PL_parser_GLOBAL)
      +yy_parser DPPP_(dummy_PL_parser);
      +#else
      +extern yy_parser DPPP_(dummy_PL_parser);
      +#endif
      +
      +# endif
      +
      +/* PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf depends on PL_parser */
      +/* Warning: PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf
      + * Do not use this variable unless you know exactly what you're
      + * doing. It is internal to the perl parser and may change or even
      + * be removed in the future. As of perl 5.9.5, you have to check
      + * for (PL_parser != NULL) for this variable to have any effect.
      + * An always non-NULL PL_parser dummy is provided for earlier
      + * perl versions.
      + * If PL_parser is NULL when you try to access this variable, a
      + * dummy is being accessed instead and a warning is issued unless
      + * you define DPPP_PL_parser_NO_DUMMY_WARNING.
      + * If DPPP_PL_parser_NO_DUMMY is defined, the code trying to access
      + * this variable will croak with a panic message.
      + */
      +
      +# define PL_expect         D_PPP_my_PL_parser_var(expect)
      +# define PL_copline        D_PPP_my_PL_parser_var(copline)
      +# define PL_rsfp           D_PPP_my_PL_parser_var(rsfp)
      +# define PL_rsfp_filters   D_PPP_my_PL_parser_var(rsfp_filters)
      +# define PL_linestr        D_PPP_my_PL_parser_var(linestr)
      +# define PL_bufptr         D_PPP_my_PL_parser_var(bufptr)
      +# define PL_bufend         D_PPP_my_PL_parser_var(bufend)
      +# define PL_lex_state      D_PPP_my_PL_parser_var(lex_state)
      +# define PL_lex_stuff      D_PPP_my_PL_parser_var(lex_stuff)
      +# define PL_tokenbuf       D_PPP_my_PL_parser_var(tokenbuf)
      +# define PL_in_my          D_PPP_my_PL_parser_var(in_my)
      +# define PL_in_my_stash    D_PPP_my_PL_parser_var(in_my_stash)
      +# define PL_error_count    D_PPP_my_PL_parser_var(error_count)
      +
      +
      +#else
      +
      +/* ensure that PL_parser != NULL and cannot be dereferenced */
      +# define PL_parser         ((void *) 1)
      +
      +#endif
      +#ifndef mPUSHs
      +#  define mPUSHs(s)                      PUSHs(sv_2mortal(s))
      +#endif
      +
      +#ifndef PUSHmortal
      +#  define PUSHmortal                     PUSHs(sv_newmortal())
      +#endif
      +
      +#ifndef mPUSHp
      +#  define mPUSHp(p,l)                    sv_setpvn(PUSHmortal, (p), (l))
      +#endif
      +
      +#ifndef mPUSHn
      +#  define mPUSHn(n)                      sv_setnv(PUSHmortal, (NV)(n))
      +#endif
      +
      +#ifndef mPUSHi
      +#  define mPUSHi(i)                      sv_setiv(PUSHmortal, (IV)(i))
      +#endif
      +
      +#ifndef mPUSHu
      +#  define mPUSHu(u)                      sv_setuv(PUSHmortal, (UV)(u))
      +#endif
      +#ifndef mXPUSHs
      +#  define mXPUSHs(s)                     XPUSHs(sv_2mortal(s))
      +#endif
      +
      +#ifndef XPUSHmortal
      +#  define XPUSHmortal                    XPUSHs(sv_newmortal())
      +#endif
      +
      +#ifndef mXPUSHp
      +#  define mXPUSHp(p,l)                   STMT_START { EXTEND(sp,1); sv_setpvn(PUSHmortal, (p), (l)); } STMT_END
      +#endif
      +
      +#ifndef mXPUSHn
      +#  define mXPUSHn(n)                     STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
      +#endif
      +
      +#ifndef mXPUSHi
      +#  define mXPUSHi(i)                     STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
      +#endif
      +
      +#ifndef mXPUSHu
      +#  define mXPUSHu(u)                     STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END
      +#endif
      +
      +/* Replace: 1 */
      +#ifndef call_sv
      +#  define call_sv                        perl_call_sv
      +#endif
      +
      +#ifndef call_pv
      +#  define call_pv                        perl_call_pv
      +#endif
      +
      +#ifndef call_argv
      +#  define call_argv                      perl_call_argv
      +#endif
      +
      +#ifndef call_method
      +#  define call_method                    perl_call_method
      +#endif
      +#ifndef eval_sv
      +#  define eval_sv                        perl_eval_sv
      +#endif
      +
      +/* Replace: 0 */
      +#ifndef PERL_LOADMOD_DENY
      +#  define PERL_LOADMOD_DENY              0x1
      +#endif
      +
      +#ifndef PERL_LOADMOD_NOIMPORT
      +#  define PERL_LOADMOD_NOIMPORT          0x2
      +#endif
      +
      +#ifndef PERL_LOADMOD_IMPORT_OPS
      +#  define PERL_LOADMOD_IMPORT_OPS        0x4
      +#endif
      +
      +#ifndef G_METHOD
      +# define G_METHOD               64
      +# ifdef call_sv
      +#  undef call_sv
      +# endif
      +# if (PERL_BCDVERSION < 0x5006000)
      +#  define call_sv(sv, flags)  ((flags) & G_METHOD ? perl_call_method((char *) SvPV_nolen_const(sv), \
      +                                (flags) & ~G_METHOD) : perl_call_sv(sv, flags))
      +# else
      +#  define call_sv(sv, flags)  ((flags) & G_METHOD ? Perl_call_method(aTHX_ (char *) SvPV_nolen_const(sv), \
      +                                (flags) & ~G_METHOD) : Perl_call_sv(aTHX_ sv, flags))
      +# endif
      +#endif
      +
      +/* Replace perl_eval_pv with eval_pv */
      +
      +#ifndef eval_pv
      +#if defined(NEED_eval_pv)
      +static SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
      +static
      +#else
      +extern SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
      +#endif
      +
      +#ifdef eval_pv
      +#  undef eval_pv
      +#endif
      +#define eval_pv(a,b) DPPP_(my_eval_pv)(aTHX_ a,b)
      +#define Perl_eval_pv DPPP_(my_eval_pv)
      +
      +#if defined(NEED_eval_pv) || defined(NEED_eval_pv_GLOBAL)
      +
      +SV*
      +DPPP_(my_eval_pv)(char *p, I32 croak_on_error)
      +{
      +    dSP;
      +    SV* sv = newSVpv(p, 0);
      +
      +    PUSHMARK(sp);
      +    eval_sv(sv, G_SCALAR);
      +    SvREFCNT_dec(sv);
      +
      +    SPAGAIN;
      +    sv = POPs;
      +    PUTBACK;
      +
      +    if (croak_on_error && SvTRUE(GvSV(errgv)))
      +        croak(SvPVx(GvSV(errgv), na));
      +
      +    return sv;
      +}
      +
      +#endif
      +#endif
      +
      +#ifndef vload_module
      +#if defined(NEED_vload_module)
      +static void DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args);
      +static
      +#else
      +extern void DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args);
      +#endif
      +
      +#ifdef vload_module
      +#  undef vload_module
      +#endif
      +#define vload_module(a,b,c,d) DPPP_(my_vload_module)(aTHX_ a,b,c,d)
      +#define Perl_vload_module DPPP_(my_vload_module)
      +
      +#if defined(NEED_vload_module) || defined(NEED_vload_module_GLOBAL)
      +
      +void
      +DPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args)
      +{
      +    dTHR;
      +    dVAR;
      +    OP *veop, *imop;
      +
      +    OP * const modname = newSVOP(OP_CONST, 0, name);
      +    /* 5.005 has a somewhat hacky force_normal that doesn't croak on
      +       SvREADONLY() if PL_compling is true. Current perls take care in
      +       ck_require() to correctly turn off SvREADONLY before calling
      +       force_normal_flags(). This seems a better fix than fudging PL_compling
      +     */
      +    SvREADONLY_off(((SVOP*)modname)->op_sv);
      +    modname->op_private |= OPpCONST_BARE;
      +    if (ver) {
      +        veop = newSVOP(OP_CONST, 0, ver);
      +    }
      +    else
      +        veop = NULL;
      +    if (flags & PERL_LOADMOD_NOIMPORT) {
      +        imop = sawparens(newNULLLIST());
      +    }
      +    else if (flags & PERL_LOADMOD_IMPORT_OPS) {
      +        imop = va_arg(*args, OP*);
      +    }
      +    else {
      +        SV *sv;
      +        imop = NULL;
      +        sv = va_arg(*args, SV*);
      +        while (sv) {
      +            imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
      +            sv = va_arg(*args, SV*);
      +        }
      +    }
      +    {
      +        const line_t ocopline = PL_copline;
      +        COP * const ocurcop = PL_curcop;
      +        const int oexpect = PL_expect;
      +
      +#if (PERL_BCDVERSION >= 0x5004000)
      +        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
      +                veop, modname, imop);
      +#elif (PERL_BCDVERSION > 0x5003000)
      +        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),
      +                veop, modname, imop);
      +#else
      +        utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),
      +                modname, imop);
      +#endif
      +        PL_expect = oexpect;
      +        PL_copline = ocopline;
      +        PL_curcop = ocurcop;
      +    }
      +}
      +
      +#endif
      +#endif
      +
      +#ifndef load_module
      +#if defined(NEED_load_module)
      +static void DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...);
      +static
      +#else
      +extern void DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...);
      +#endif
      +
      +#ifdef load_module
      +#  undef load_module
      +#endif
      +#define load_module DPPP_(my_load_module)
      +#define Perl_load_module DPPP_(my_load_module)
      +
      +#if defined(NEED_load_module) || defined(NEED_load_module_GLOBAL)
      +
      +void
      +DPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...)
      +{
      +    va_list args;
      +    va_start(args, ver);
      +    vload_module(flags, name, ver, &args);
      +    va_end(args);
      +}
      +
      +#endif
      +#endif
      +#ifndef newRV_inc
      +#  define newRV_inc(sv)                  newRV(sv)   /* Replace */
      +#endif
      +
      +#ifndef newRV_noinc
      +#if defined(NEED_newRV_noinc)
      +static SV * DPPP_(my_newRV_noinc)(SV *sv);
      +static
      +#else
      +extern SV * DPPP_(my_newRV_noinc)(SV *sv);
      +#endif
      +
      +#ifdef newRV_noinc
      +#  undef newRV_noinc
      +#endif
      +#define newRV_noinc(a) DPPP_(my_newRV_noinc)(aTHX_ a)
      +#define Perl_newRV_noinc DPPP_(my_newRV_noinc)
      +
      +#if defined(NEED_newRV_noinc) || defined(NEED_newRV_noinc_GLOBAL)
      +SV *
      +DPPP_(my_newRV_noinc)(SV *sv)
      +{
      +  SV *rv = (SV *)newRV(sv);
      +  SvREFCNT_dec(sv);
      +  return rv;
      +}
      +#endif
      +#endif
      +
      +/* Hint: newCONSTSUB
      + * Returns a CV* as of perl-5.7.1. This return value is not supported
      + * by Devel::PPPort.
      + */
      +
      +/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
      +#if (PERL_BCDVERSION < 0x5004063) && (PERL_BCDVERSION != 0x5004005)
      +#if defined(NEED_newCONSTSUB)
      +static void DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv);
      +static
      +#else
      +extern void DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv);
      +#endif
      +
      +#ifdef newCONSTSUB
      +#  undef newCONSTSUB
      +#endif
      +#define newCONSTSUB(a,b,c) DPPP_(my_newCONSTSUB)(aTHX_ a,b,c)
      +#define Perl_newCONSTSUB DPPP_(my_newCONSTSUB)
      +
      +#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)
      +
      +/* This is just a trick to avoid a dependency of newCONSTSUB on PL_parser */
      +/* (There's no PL_parser in perl < 5.005, so this is completely safe)     */
      +#define D_PPP_PL_copline PL_copline
      +
      +void
      +DPPP_(my_newCONSTSUB)(HV *stash, const char *name, SV *sv)
      +{
      +        U32 oldhints = PL_hints;
      +        HV *old_cop_stash = PL_curcop->cop_stash;
      +        HV *old_curstash = PL_curstash;
      +        line_t oldline = PL_curcop->cop_line;
      +        PL_curcop->cop_line = D_PPP_PL_copline;
      +
      +        PL_hints &= ~HINT_BLOCK_SCOPE;
      +        if (stash)
      +                PL_curstash = PL_curcop->cop_stash = stash;
      +
      +        newSUB(
      +
      +#if   (PERL_BCDVERSION < 0x5003022)
      +                start_subparse(),
      +#elif (PERL_BCDVERSION == 0x5003022)
      +                start_subparse(0),
      +#else  /* 5.003_23  onwards */
      +                start_subparse(FALSE, 0),
      +#endif
      +
      +                newSVOP(OP_CONST, 0, newSVpv((char *) name, 0)),
      +                newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
      +                newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
      +        );
      +
      +        PL_hints = oldhints;
      +        PL_curcop->cop_stash = old_cop_stash;
      +        PL_curstash = old_curstash;
      +        PL_curcop->cop_line = oldline;
      +}
      +#endif
      +#endif
      +
      +/*
      + * Boilerplate macros for initializing and accessing interpreter-local
      + * data from C.  All statics in extensions should be reworked to use
      + * this, if you want to make the extension thread-safe.  See ext/re/re.xs
      + * for an example of the use of these macros.
      + *
      + * Code that uses these macros is responsible for the following:
      + * 1. #define MY_CXT_KEY to a unique string, e.g. "DynaLoader_guts"
      + * 2. Declare a typedef named my_cxt_t that is a structure that contains
      + *    all the data that needs to be interpreter-local.
      + * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
      + * 4. Use the MY_CXT_INIT macro such that it is called exactly once
      + *    (typically put in the BOOT: section).
      + * 5. Use the members of the my_cxt_t structure everywhere as
      + *    MY_CXT.member.
      + * 6. Use the dMY_CXT macro (a declaration) in all the functions that
      + *    access MY_CXT.
      + */
      +
      +#if defined(MULTIPLICITY) || defined(PERL_OBJECT) || \
      +    defined(PERL_CAPI)    || defined(PERL_IMPLICIT_CONTEXT)
      +
      +#ifndef START_MY_CXT
      +
      +/* This must appear in all extensions that define a my_cxt_t structure,
      + * right after the definition (i.e. at file scope).  The non-threads
      + * case below uses it to declare the data as static. */
      +#define START_MY_CXT
      +
      +#if (PERL_BCDVERSION < 0x5004068)
      +/* Fetches the SV that keeps the per-interpreter data. */
      +#define dMY_CXT_SV \
      +        SV *my_cxt_sv = get_sv(MY_CXT_KEY, FALSE)
      +#else /* >= perl5.004_68 */
      +#define dMY_CXT_SV \
      +        SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,             \
      +                                  sizeof(MY_CXT_KEY)-1, TRUE)
      +#endif /* < perl5.004_68 */
      +
      +/* This declaration should be used within all functions that use the
      + * interpreter-local data. */
      +#define dMY_CXT \
      +        dMY_CXT_SV;                                                     \
      +        my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*,SvUV(my_cxt_sv))
      +
      +/* Creates and zeroes the per-interpreter data.
      + * (We allocate my_cxtp in a Perl SV so that it will be released when
      + * the interpreter goes away.) */
      +#define MY_CXT_INIT \
      +        dMY_CXT_SV;                                                     \
      +        /* newSV() allocates one more than needed */                    \
      +        my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
      +        Zero(my_cxtp, 1, my_cxt_t);                                     \
      +        sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
      +
      +/* This macro must be used to access members of the my_cxt_t structure.
      + * e.g. MYCXT.some_data */
      +#define MY_CXT          (*my_cxtp)
      +
      +/* Judicious use of these macros can reduce the number of times dMY_CXT
      + * is used.  Use is similar to pTHX, aTHX etc. */
      +#define pMY_CXT         my_cxt_t *my_cxtp
      +#define pMY_CXT_        pMY_CXT,
      +#define _pMY_CXT        ,pMY_CXT
      +#define aMY_CXT         my_cxtp
      +#define aMY_CXT_        aMY_CXT,
      +#define _aMY_CXT        ,aMY_CXT
      +
      +#endif /* START_MY_CXT */
      +
      +#ifndef MY_CXT_CLONE
      +/* Clones the per-interpreter data. */
      +#define MY_CXT_CLONE \
      +        dMY_CXT_SV;                                                     \
      +        my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
      +        Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\
      +        sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
      +#endif
      +
      +#else /* single interpreter */
      +
      +#ifndef START_MY_CXT
      +
      +#define START_MY_CXT    static my_cxt_t my_cxt;
      +#define dMY_CXT_SV      dNOOP
      +#define dMY_CXT         dNOOP
      +#define MY_CXT_INIT     NOOP
      +#define MY_CXT          my_cxt
      +
      +#define pMY_CXT         void
      +#define pMY_CXT_
      +#define _pMY_CXT
      +#define aMY_CXT
      +#define aMY_CXT_
      +#define _aMY_CXT
      +
      +#endif /* START_MY_CXT */
      +
      +#ifndef MY_CXT_CLONE
      +#define MY_CXT_CLONE    NOOP
      +#endif
      +
      +#endif
      +
      +#ifndef IVdf
      +#  if IVSIZE == LONGSIZE
      +#    define     IVdf      "ld"
      +#    define     UVuf      "lu"
      +#    define     UVof      "lo"
      +#    define     UVxf      "lx"
      +#    define     UVXf      "lX"
      +#  elif IVSIZE == INTSIZE
      +#    define   IVdf      "d"
      +#    define   UVuf      "u"
      +#    define   UVof      "o"
      +#    define   UVxf      "x"
      +#    define   UVXf      "X"
      +#  else
      +#    error "cannot define IV/UV formats"
      +#  endif
      +#endif
      +
      +#ifndef NVef
      +#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE) && \
      +      defined(PERL_PRIfldbl) && (PERL_BCDVERSION != 0x5006000)
      +            /* Not very likely, but let's try anyway. */
      +#    define NVef          PERL_PRIeldbl
      +#    define NVff          PERL_PRIfldbl
      +#    define NVgf          PERL_PRIgldbl
      +#  else
      +#    define NVef          "e"
      +#    define NVff          "f"
      +#    define NVgf          "g"
      +#  endif
      +#endif
      +
      +#ifndef SvREFCNT_inc
      +#  ifdef PERL_USE_GCC_BRACE_GROUPS
      +#    define SvREFCNT_inc(sv)            \
      +      ({                                \
      +          SV * const _sv = (SV*)(sv);   \
      +          if (_sv)                      \
      +               (SvREFCNT(_sv))++;       \
      +          _sv;                          \
      +      })
      +#  else
      +#    define SvREFCNT_inc(sv)    \
      +          ((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
      +#  endif
      +#endif
      +
      +#ifndef SvREFCNT_inc_simple
      +#  ifdef PERL_USE_GCC_BRACE_GROUPS
      +#    define SvREFCNT_inc_simple(sv)     \
      +      ({                                        \
      +          if (sv)                               \
      +               (SvREFCNT(sv))++;                \
      +          (SV *)(sv);                           \
      +      })
      +#  else
      +#    define SvREFCNT_inc_simple(sv) \
      +          ((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
      +#  endif
      +#endif
      +
      +#ifndef SvREFCNT_inc_NN
      +#  ifdef PERL_USE_GCC_BRACE_GROUPS
      +#    define SvREFCNT_inc_NN(sv)         \
      +      ({                                        \
      +          SV * const _sv = (SV*)(sv);   \
      +          SvREFCNT(_sv)++;              \
      +          _sv;                          \
      +      })
      +#  else
      +#    define SvREFCNT_inc_NN(sv) \
      +          (PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
      +#  endif
      +#endif
      +
      +#ifndef SvREFCNT_inc_void
      +#  ifdef PERL_USE_GCC_BRACE_GROUPS
      +#    define SvREFCNT_inc_void(sv)               \
      +      ({                                        \
      +          SV * const _sv = (SV*)(sv);   \
      +          if (_sv)                      \
      +              (void)(SvREFCNT(_sv)++);  \
      +      })
      +#  else
      +#    define SvREFCNT_inc_void(sv) \
      +          (void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
      +#  endif
      +#endif
      +#ifndef SvREFCNT_inc_simple_void
      +#  define SvREFCNT_inc_simple_void(sv)   STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
      +#endif
      +
      +#ifndef SvREFCNT_inc_simple_NN
      +#  define SvREFCNT_inc_simple_NN(sv)     (++SvREFCNT(sv), (SV*)(sv))
      +#endif
      +
      +#ifndef SvREFCNT_inc_void_NN
      +#  define SvREFCNT_inc_void_NN(sv)       (void)(++SvREFCNT((SV*)(sv)))
      +#endif
      +
      +#ifndef SvREFCNT_inc_simple_void_NN
      +#  define SvREFCNT_inc_simple_void_NN(sv) (void)(++SvREFCNT((SV*)(sv)))
      +#endif
      +
      +#ifndef newSV_type
      +
      +#if defined(NEED_newSV_type)
      +static SV* DPPP_(my_newSV_type)(pTHX_ svtype const t);
      +static
      +#else
      +extern SV* DPPP_(my_newSV_type)(pTHX_ svtype const t);
      +#endif
      +
      +#ifdef newSV_type
      +#  undef newSV_type
      +#endif
      +#define newSV_type(a) DPPP_(my_newSV_type)(aTHX_ a)
      +#define Perl_newSV_type DPPP_(my_newSV_type)
      +
      +#if defined(NEED_newSV_type) || defined(NEED_newSV_type_GLOBAL)
      +
      +SV*
      +DPPP_(my_newSV_type)(pTHX_ svtype const t)
      +{
      +  SV* const sv = newSV(0);
      +  sv_upgrade(sv, t);
      +  return sv;
      +}
      +
      +#endif
      +
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5006000)
      +# define D_PPP_CONSTPV_ARG(x)  ((char *) (x))
      +#else
      +# define D_PPP_CONSTPV_ARG(x)  (x)
      +#endif
      +#ifndef newSVpvn
      +#  define newSVpvn(data,len)             ((data)                                              \
      +                                    ? ((len) ? newSVpv((data), (len)) : newSVpv("", 0)) \
      +                                    : newSV(0))
      +#endif
      +#ifndef newSVpvn_utf8
      +#  define newSVpvn_utf8(s, len, u)       newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
      +#endif
      +#ifndef SVf_UTF8
      +#  define SVf_UTF8                       0
      +#endif
      +
      +#ifndef newSVpvn_flags
      +
      +#if defined(NEED_newSVpvn_flags)
      +static SV * DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags);
      +static
      +#else
      +extern SV * DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags);
      +#endif
      +
      +#ifdef newSVpvn_flags
      +#  undef newSVpvn_flags
      +#endif
      +#define newSVpvn_flags(a,b,c) DPPP_(my_newSVpvn_flags)(aTHX_ a,b,c)
      +#define Perl_newSVpvn_flags DPPP_(my_newSVpvn_flags)
      +
      +#if defined(NEED_newSVpvn_flags) || defined(NEED_newSVpvn_flags_GLOBAL)
      +
      +SV *
      +DPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)
      +{
      +  SV *sv = newSVpvn(D_PPP_CONSTPV_ARG(s), len);
      +  SvFLAGS(sv) |= (flags & SVf_UTF8);
      +  return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;
      +}
      +
      +#endif
      +
      +#endif
      +
      +/* Backwards compatibility stuff... :-( */
      +#if !defined(NEED_sv_2pv_flags) && defined(NEED_sv_2pv_nolen)
      +#  define NEED_sv_2pv_flags
      +#endif
      +#if !defined(NEED_sv_2pv_flags_GLOBAL) && defined(NEED_sv_2pv_nolen_GLOBAL)
      +#  define NEED_sv_2pv_flags_GLOBAL
      +#endif
      +
      +/* Hint: sv_2pv_nolen
      + * Use the SvPV_nolen() or SvPV_nolen_const() macros instead of sv_2pv_nolen().
      + */
      +#ifndef sv_2pv_nolen
      +#  define sv_2pv_nolen(sv)               SvPV_nolen(sv)
      +#endif
      +
      +#ifdef SvPVbyte
      +
      +/* Hint: SvPVbyte
      + * Does not work in perl-5.6.1, ppport.h implements a version
      + * borrowed from perl-5.7.3.
      + */
      +
      +#if (PERL_BCDVERSION < 0x5007000)
      +
      +#if defined(NEED_sv_2pvbyte)
      +static char * DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp);
      +static
      +#else
      +extern char * DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp);
      +#endif
      +
      +#ifdef sv_2pvbyte
      +#  undef sv_2pvbyte
      +#endif
      +#define sv_2pvbyte(a,b) DPPP_(my_sv_2pvbyte)(aTHX_ a,b)
      +#define Perl_sv_2pvbyte DPPP_(my_sv_2pvbyte)
      +
      +#if defined(NEED_sv_2pvbyte) || defined(NEED_sv_2pvbyte_GLOBAL)
      +
      +char *
      +DPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)
      +{
      +  sv_utf8_downgrade(sv,0);
      +  return SvPV(sv,*lp);
      +}
      +
      +#endif
      +
      +/* Hint: sv_2pvbyte
      + * Use the SvPVbyte() macro instead of sv_2pvbyte().
      + */
      +
      +#undef SvPVbyte
      +
      +#define SvPVbyte(sv, lp)                                                \
      +        ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)                \
      +         ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))
      +
      +#endif
      +
      +#else
      +
      +#  define SvPVbyte          SvPV
      +#  define sv_2pvbyte        sv_2pv
      +
      +#endif
      +#ifndef sv_2pvbyte_nolen
      +#  define sv_2pvbyte_nolen(sv)           sv_2pv_nolen(sv)
      +#endif
      +
      +/* Hint: sv_pvn
      + * Always use the SvPV() macro instead of sv_pvn().
      + */
      +
      +/* Hint: sv_pvn_force
      + * Always use the SvPV_force() macro instead of sv_pvn_force().
      + */
      +
      +/* If these are undefined, they're not handled by the core anyway */
      +#ifndef SV_IMMEDIATE_UNREF
      +#  define SV_IMMEDIATE_UNREF             0
      +#endif
      +
      +#ifndef SV_GMAGIC
      +#  define SV_GMAGIC                      0
      +#endif
      +
      +#ifndef SV_COW_DROP_PV
      +#  define SV_COW_DROP_PV                 0
      +#endif
      +
      +#ifndef SV_UTF8_NO_ENCODING
      +#  define SV_UTF8_NO_ENCODING            0
      +#endif
      +
      +#ifndef SV_NOSTEAL
      +#  define SV_NOSTEAL                     0
      +#endif
      +
      +#ifndef SV_CONST_RETURN
      +#  define SV_CONST_RETURN                0
      +#endif
      +
      +#ifndef SV_MUTABLE_RETURN
      +#  define SV_MUTABLE_RETURN              0
      +#endif
      +
      +#ifndef SV_SMAGIC
      +#  define SV_SMAGIC                      0
      +#endif
      +
      +#ifndef SV_HAS_TRAILING_NUL
      +#  define SV_HAS_TRAILING_NUL            0
      +#endif
      +
      +#ifndef SV_COW_SHARED_HASH_KEYS
      +#  define SV_COW_SHARED_HASH_KEYS        0
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5007002)
      +
      +#if defined(NEED_sv_2pv_flags)
      +static char * DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
      +static
      +#else
      +extern char * DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
      +#endif
      +
      +#ifdef sv_2pv_flags
      +#  undef sv_2pv_flags
      +#endif
      +#define sv_2pv_flags(a,b,c) DPPP_(my_sv_2pv_flags)(aTHX_ a,b,c)
      +#define Perl_sv_2pv_flags DPPP_(my_sv_2pv_flags)
      +
      +#if defined(NEED_sv_2pv_flags) || defined(NEED_sv_2pv_flags_GLOBAL)
      +
      +char *
      +DPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)
      +{
      +  STRLEN n_a = (STRLEN) flags;
      +  return sv_2pv(sv, lp ? lp : &n_a);
      +}
      +
      +#endif
      +
      +#if defined(NEED_sv_pvn_force_flags)
      +static char * DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
      +static
      +#else
      +extern char * DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags);
      +#endif
      +
      +#ifdef sv_pvn_force_flags
      +#  undef sv_pvn_force_flags
      +#endif
      +#define sv_pvn_force_flags(a,b,c) DPPP_(my_sv_pvn_force_flags)(aTHX_ a,b,c)
      +#define Perl_sv_pvn_force_flags DPPP_(my_sv_pvn_force_flags)
      +
      +#if defined(NEED_sv_pvn_force_flags) || defined(NEED_sv_pvn_force_flags_GLOBAL)
      +
      +char *
      +DPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)
      +{
      +  STRLEN n_a = (STRLEN) flags;
      +  return sv_pvn_force(sv, lp ? lp : &n_a);
      +}
      +
      +#endif
      +
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5008008) || ( (PERL_BCDVERSION >= 0x5009000) && (PERL_BCDVERSION < 0x5009003) )
      +# define DPPP_SVPV_NOLEN_LP_ARG &PL_na
      +#else
      +# define DPPP_SVPV_NOLEN_LP_ARG 0
      +#endif
      +#ifndef SvPV_const
      +#  define SvPV_const(sv, lp)             SvPV_flags_const(sv, lp, SV_GMAGIC)
      +#endif
      +
      +#ifndef SvPV_mutable
      +#  define SvPV_mutable(sv, lp)           SvPV_flags_mutable(sv, lp, SV_GMAGIC)
      +#endif
      +#ifndef SvPV_flags
      +#  define SvPV_flags(sv, lp, flags)      \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
      +#endif
      +#ifndef SvPV_flags_const
      +#  define SvPV_flags_const(sv, lp, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
      +                  (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
      +#endif
      +#ifndef SvPV_flags_const_nolen
      +#  define SvPV_flags_const_nolen(sv, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? SvPVX_const(sv) : \
      +                  (const char*) sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags|SV_CONST_RETURN))
      +#endif
      +#ifndef SvPV_flags_mutable
      +#  define SvPV_flags_mutable(sv, lp, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
      +                  sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
      +#endif
      +#ifndef SvPV_force
      +#  define SvPV_force(sv, lp)             SvPV_force_flags(sv, lp, SV_GMAGIC)
      +#endif
      +
      +#ifndef SvPV_force_nolen
      +#  define SvPV_force_nolen(sv)           SvPV_force_flags_nolen(sv, SV_GMAGIC)
      +#endif
      +
      +#ifndef SvPV_force_mutable
      +#  define SvPV_force_mutable(sv, lp)     SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)
      +#endif
      +
      +#ifndef SvPV_force_nomg
      +#  define SvPV_force_nomg(sv, lp)        SvPV_force_flags(sv, lp, 0)
      +#endif
      +
      +#ifndef SvPV_force_nomg_nolen
      +#  define SvPV_force_nomg_nolen(sv)      SvPV_force_flags_nolen(sv, 0)
      +#endif
      +#ifndef SvPV_force_flags
      +#  define SvPV_force_flags(sv, lp, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
      +                 ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))
      +#endif
      +#ifndef SvPV_force_flags_nolen
      +#  define SvPV_force_flags_nolen(sv, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
      +                 ? SvPVX(sv) : sv_pvn_force_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags))
      +#endif
      +#ifndef SvPV_force_flags_mutable
      +#  define SvPV_force_flags_mutable(sv, lp, flags) \
      +                 ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
      +                 ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
      +                  : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
      +#endif
      +#ifndef SvPV_nolen
      +#  define SvPV_nolen(sv)                 \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? SvPVX(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC))
      +#endif
      +#ifndef SvPV_nolen_const
      +#  define SvPV_nolen_const(sv)           \
      +                 ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                  ? SvPVX_const(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC|SV_CONST_RETURN))
      +#endif
      +#ifndef SvPV_nomg
      +#  define SvPV_nomg(sv, lp)              SvPV_flags(sv, lp, 0)
      +#endif
      +
      +#ifndef SvPV_nomg_const
      +#  define SvPV_nomg_const(sv, lp)        SvPV_flags_const(sv, lp, 0)
      +#endif
      +
      +#ifndef SvPV_nomg_const_nolen
      +#  define SvPV_nomg_const_nolen(sv)      SvPV_flags_const_nolen(sv, 0)
      +#endif
      +
      +#ifndef SvPV_nomg_nolen
      +#  define SvPV_nomg_nolen(sv)            ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
      +                                    ? SvPVX(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, 0))
      +#endif
      +#ifndef SvPV_renew
      +#  define SvPV_renew(sv,n)               STMT_START { SvLEN_set(sv, n); \
      +                 SvPV_set((sv), (char *) saferealloc(          \
      +                       (Malloc_t)SvPVX(sv), (MEM_SIZE)((n)))); \
      +               } STMT_END
      +#endif
      +#ifndef SvMAGIC_set
      +#  define SvMAGIC_set(sv, val)           \
      +                STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
      +                (((XPVMG*) SvANY(sv))->xmg_magic = (val)); } STMT_END
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5009003)
      +#ifndef SvPVX_const
      +#  define SvPVX_const(sv)                ((const char*) (0 + SvPVX(sv)))
      +#endif
      +
      +#ifndef SvPVX_mutable
      +#  define SvPVX_mutable(sv)              (0 + SvPVX(sv))
      +#endif
      +#ifndef SvRV_set
      +#  define SvRV_set(sv, val)              \
      +                STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
      +                (((XRV*) SvANY(sv))->xrv_rv = (val)); } STMT_END
      +#endif
      +
      +#else
      +#ifndef SvPVX_const
      +#  define SvPVX_const(sv)                ((const char*)((sv)->sv_u.svu_pv))
      +#endif
      +
      +#ifndef SvPVX_mutable
      +#  define SvPVX_mutable(sv)              ((sv)->sv_u.svu_pv)
      +#endif
      +#ifndef SvRV_set
      +#  define SvRV_set(sv, val)              \
      +                STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
      +                ((sv)->sv_u.svu_rv = (val)); } STMT_END
      +#endif
      +
      +#endif
      +#ifndef SvSTASH_set
      +#  define SvSTASH_set(sv, val)           \
      +                STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
      +                (((XPVMG*) SvANY(sv))->xmg_stash = (val)); } STMT_END
      +#endif
      +
      +#if (PERL_BCDVERSION < 0x5004000)
      +#ifndef SvUV_set
      +#  define SvUV_set(sv, val)              \
      +                STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
      +                (((XPVIV*) SvANY(sv))->xiv_iv = (IV) (val)); } STMT_END
      +#endif
      +
      +#else
      +#ifndef SvUV_set
      +#  define SvUV_set(sv, val)              \
      +                STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
      +                (((XPVUV*) SvANY(sv))->xuv_uv = (val)); } STMT_END
      +#endif
      +
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(vnewSVpvf)
      +#if defined(NEED_vnewSVpvf)
      +static SV * DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args);
      +static
      +#else
      +extern SV * DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args);
      +#endif
      +
      +#ifdef vnewSVpvf
      +#  undef vnewSVpvf
      +#endif
      +#define vnewSVpvf(a,b) DPPP_(my_vnewSVpvf)(aTHX_ a,b)
      +#define Perl_vnewSVpvf DPPP_(my_vnewSVpvf)
      +
      +#if defined(NEED_vnewSVpvf) || defined(NEED_vnewSVpvf_GLOBAL)
      +
      +SV *
      +DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)
      +{
      +  register SV *sv = newSV(0);
      +  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
      +  return sv;
      +}
      +
      +#endif
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vcatpvf)
      +#  define sv_vcatpvf(sv, pat, args)  sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vsetpvf)
      +#  define sv_vsetpvf(sv, pat, args)  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_catpvf_mg)
      +#if defined(NEED_sv_catpvf_mg)
      +static void DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
      +static
      +#else
      +extern void DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
      +#endif
      +
      +#define Perl_sv_catpvf_mg DPPP_(my_sv_catpvf_mg)
      +
      +#if defined(NEED_sv_catpvf_mg) || defined(NEED_sv_catpvf_mg_GLOBAL)
      +
      +void
      +DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
      +{
      +  va_list args;
      +  va_start(args, pat);
      +  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
      +  SvSETMAGIC(sv);
      +  va_end(args);
      +}
      +
      +#endif
      +#endif
      +
      +#ifdef PERL_IMPLICIT_CONTEXT
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_catpvf_mg_nocontext)
      +#if defined(NEED_sv_catpvf_mg_nocontext)
      +static void DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...);
      +static
      +#else
      +extern void DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...);
      +#endif
      +
      +#define sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)
      +#define Perl_sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)
      +
      +#if defined(NEED_sv_catpvf_mg_nocontext) || defined(NEED_sv_catpvf_mg_nocontext_GLOBAL)
      +
      +void
      +DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...)
      +{
      +  dTHX;
      +  va_list args;
      +  va_start(args, pat);
      +  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
      +  SvSETMAGIC(sv);
      +  va_end(args);
      +}
      +
      +#endif
      +#endif
      +#endif
      +
      +/* sv_catpvf_mg depends on sv_catpvf_mg_nocontext */
      +#ifndef sv_catpvf_mg
      +#  ifdef PERL_IMPLICIT_CONTEXT
      +#    define sv_catpvf_mg   Perl_sv_catpvf_mg_nocontext
      +#  else
      +#    define sv_catpvf_mg   Perl_sv_catpvf_mg
      +#  endif
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vcatpvf_mg)
      +#  define sv_vcatpvf_mg(sv, pat, args)                                     \
      +   STMT_START {                                                            \
      +     sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
      +     SvSETMAGIC(sv);                                                       \
      +   } STMT_END
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_setpvf_mg)
      +#if defined(NEED_sv_setpvf_mg)
      +static void DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
      +static
      +#else
      +extern void DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...);
      +#endif
      +
      +#define Perl_sv_setpvf_mg DPPP_(my_sv_setpvf_mg)
      +
      +#if defined(NEED_sv_setpvf_mg) || defined(NEED_sv_setpvf_mg_GLOBAL)
      +
      +void
      +DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
      +{
      +  va_list args;
      +  va_start(args, pat);
      +  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
      +  SvSETMAGIC(sv);
      +  va_end(args);
      +}
      +
      +#endif
      +#endif
      +
      +#ifdef PERL_IMPLICIT_CONTEXT
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_setpvf_mg_nocontext)
      +#if defined(NEED_sv_setpvf_mg_nocontext)
      +static void DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...);
      +static
      +#else
      +extern void DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...);
      +#endif
      +
      +#define sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)
      +#define Perl_sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)
      +
      +#if defined(NEED_sv_setpvf_mg_nocontext) || defined(NEED_sv_setpvf_mg_nocontext_GLOBAL)
      +
      +void
      +DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...)
      +{
      +  dTHX;
      +  va_list args;
      +  va_start(args, pat);
      +  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
      +  SvSETMAGIC(sv);
      +  va_end(args);
      +}
      +
      +#endif
      +#endif
      +#endif
      +
      +/* sv_setpvf_mg depends on sv_setpvf_mg_nocontext */
      +#ifndef sv_setpvf_mg
      +#  ifdef PERL_IMPLICIT_CONTEXT
      +#    define sv_setpvf_mg   Perl_sv_setpvf_mg_nocontext
      +#  else
      +#    define sv_setpvf_mg   Perl_sv_setpvf_mg
      +#  endif
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(sv_vsetpvf_mg)
      +#  define sv_vsetpvf_mg(sv, pat, args)                                     \
      +   STMT_START {                                                            \
      +     sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
      +     SvSETMAGIC(sv);                                                       \
      +   } STMT_END
      +#endif
      +
      +/* Hint: newSVpvn_share
      + * The SVs created by this function only mimic the behaviour of
      + * shared PVs without really being shared. Only use if you know
      + * what you're doing.
      + */
      +
      +#ifndef newSVpvn_share
      +
      +#if defined(NEED_newSVpvn_share)
      +static SV * DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash);
      +static
      +#else
      +extern SV * DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash);
      +#endif
      +
      +#ifdef newSVpvn_share
      +#  undef newSVpvn_share
      +#endif
      +#define newSVpvn_share(a,b,c) DPPP_(my_newSVpvn_share)(aTHX_ a,b,c)
      +#define Perl_newSVpvn_share DPPP_(my_newSVpvn_share)
      +
      +#if defined(NEED_newSVpvn_share) || defined(NEED_newSVpvn_share_GLOBAL)
      +
      +SV *
      +DPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)
      +{
      +  SV *sv;
      +  if (len < 0)
      +    len = -len;
      +  if (!hash)
      +    PERL_HASH(hash, (char*) src, len);
      +  sv = newSVpvn((char *) src, len);
      +  sv_upgrade(sv, SVt_PVIV);
      +  SvIVX(sv) = hash;
      +  SvREADONLY_on(sv);
      +  SvPOK_on(sv);
      +  return sv;
      +}
      +
      +#endif
      +
      +#endif
      +#ifndef SvSHARED_HASH
      +#  define SvSHARED_HASH(sv)              (0 + SvUVX(sv))
      +#endif
      +#ifndef HvNAME_get
      +#  define HvNAME_get(hv)                 HvNAME(hv)
      +#endif
      +#ifndef HvNAMELEN_get
      +#  define HvNAMELEN_get(hv)              (HvNAME_get(hv) ? (I32)strlen(HvNAME_get(hv)) : 0)
      +#endif
      +
      +#ifndef gv_fetchpvn_flags
      +#if defined(NEED_gv_fetchpvn_flags)
      +static GV* DPPP_(my_gv_fetchpvn_flags)(pTHX_ const char* name, STRLEN len, int flags, int types);
      +static
      +#else
      +extern GV* DPPP_(my_gv_fetchpvn_flags)(pTHX_ const char* name, STRLEN len, int flags, int types);
      +#endif
      +
      +#ifdef gv_fetchpvn_flags
      +#  undef gv_fetchpvn_flags
      +#endif
      +#define gv_fetchpvn_flags(a,b,c,d) DPPP_(my_gv_fetchpvn_flags)(aTHX_ a,b,c,d)
      +#define Perl_gv_fetchpvn_flags DPPP_(my_gv_fetchpvn_flags)
      +
      +#if defined(NEED_gv_fetchpvn_flags) || defined(NEED_gv_fetchpvn_flags_GLOBAL)
      +
      +GV*
      +DPPP_(my_gv_fetchpvn_flags)(pTHX_ const char* name, STRLEN len, int flags, int types) {
      +	char *namepv = savepvn(name, len);
      +	GV* stash = gv_fetchpv(namepv, TRUE, SVt_PVHV);
      +	Safefree(namepv);
      +	return stash;
      +}
      +
      +#endif
      +#endif
      +#ifndef GvSVn
      +#  define GvSVn(gv)                      GvSV(gv)
      +#endif
      +
      +#ifndef isGV_with_GP
      +#  define isGV_with_GP(gv)               isGV(gv)
      +#endif
      +
      +#ifndef gv_fetchsv
      +#  define gv_fetchsv(name, flags, svt)   gv_fetchpv(SvPV_nolen_const(name), flags, svt)
      +#endif
      +#ifndef get_cvn_flags
      +#  define get_cvn_flags(name, namelen, flags) get_cv(name, flags)
      +#endif
      +
      +#ifndef gv_init_pvn
      +#  define gv_init_pvn(gv, stash, ptr, len, flags) gv_init(gv, stash, ptr, len, flags & GV_ADDMULTI ? TRUE : FALSE)
      +#endif
      +#ifndef WARN_ALL
      +#  define WARN_ALL                       0
      +#endif
      +
      +#ifndef WARN_CLOSURE
      +#  define WARN_CLOSURE                   1
      +#endif
      +
      +#ifndef WARN_DEPRECATED
      +#  define WARN_DEPRECATED                2
      +#endif
      +
      +#ifndef WARN_EXITING
      +#  define WARN_EXITING                   3
      +#endif
      +
      +#ifndef WARN_GLOB
      +#  define WARN_GLOB                      4
      +#endif
      +
      +#ifndef WARN_IO
      +#  define WARN_IO                        5
      +#endif
      +
      +#ifndef WARN_CLOSED
      +#  define WARN_CLOSED                    6
      +#endif
      +
      +#ifndef WARN_EXEC
      +#  define WARN_EXEC                      7
      +#endif
      +
      +#ifndef WARN_LAYER
      +#  define WARN_LAYER                     8
      +#endif
      +
      +#ifndef WARN_NEWLINE
      +#  define WARN_NEWLINE                   9
      +#endif
      +
      +#ifndef WARN_PIPE
      +#  define WARN_PIPE                      10
      +#endif
      +
      +#ifndef WARN_UNOPENED
      +#  define WARN_UNOPENED                  11
      +#endif
      +
      +#ifndef WARN_MISC
      +#  define WARN_MISC                      12
      +#endif
      +
      +#ifndef WARN_NUMERIC
      +#  define WARN_NUMERIC                   13
      +#endif
      +
      +#ifndef WARN_ONCE
      +#  define WARN_ONCE                      14
      +#endif
      +
      +#ifndef WARN_OVERFLOW
      +#  define WARN_OVERFLOW                  15
      +#endif
      +
      +#ifndef WARN_PACK
      +#  define WARN_PACK                      16
      +#endif
      +
      +#ifndef WARN_PORTABLE
      +#  define WARN_PORTABLE                  17
      +#endif
      +
      +#ifndef WARN_RECURSION
      +#  define WARN_RECURSION                 18
      +#endif
      +
      +#ifndef WARN_REDEFINE
      +#  define WARN_REDEFINE                  19
      +#endif
      +
      +#ifndef WARN_REGEXP
      +#  define WARN_REGEXP                    20
      +#endif
      +
      +#ifndef WARN_SEVERE
      +#  define WARN_SEVERE                    21
      +#endif
      +
      +#ifndef WARN_DEBUGGING
      +#  define WARN_DEBUGGING                 22
      +#endif
      +
      +#ifndef WARN_INPLACE
      +#  define WARN_INPLACE                   23
      +#endif
      +
      +#ifndef WARN_INTERNAL
      +#  define WARN_INTERNAL                  24
      +#endif
      +
      +#ifndef WARN_MALLOC
      +#  define WARN_MALLOC                    25
      +#endif
      +
      +#ifndef WARN_SIGNAL
      +#  define WARN_SIGNAL                    26
      +#endif
      +
      +#ifndef WARN_SUBSTR
      +#  define WARN_SUBSTR                    27
      +#endif
      +
      +#ifndef WARN_SYNTAX
      +#  define WARN_SYNTAX                    28
      +#endif
      +
      +#ifndef WARN_AMBIGUOUS
      +#  define WARN_AMBIGUOUS                 29
      +#endif
      +
      +#ifndef WARN_BAREWORD
      +#  define WARN_BAREWORD                  30
      +#endif
      +
      +#ifndef WARN_DIGIT
      +#  define WARN_DIGIT                     31
      +#endif
      +
      +#ifndef WARN_PARENTHESIS
      +#  define WARN_PARENTHESIS               32
      +#endif
      +
      +#ifndef WARN_PRECEDENCE
      +#  define WARN_PRECEDENCE                33
      +#endif
      +
      +#ifndef WARN_PRINTF
      +#  define WARN_PRINTF                    34
      +#endif
      +
      +#ifndef WARN_PROTOTYPE
      +#  define WARN_PROTOTYPE                 35
      +#endif
      +
      +#ifndef WARN_QW
      +#  define WARN_QW                        36
      +#endif
      +
      +#ifndef WARN_RESERVED
      +#  define WARN_RESERVED                  37
      +#endif
      +
      +#ifndef WARN_SEMICOLON
      +#  define WARN_SEMICOLON                 38
      +#endif
      +
      +#ifndef WARN_TAINT
      +#  define WARN_TAINT                     39
      +#endif
      +
      +#ifndef WARN_THREADS
      +#  define WARN_THREADS                   40
      +#endif
      +
      +#ifndef WARN_UNINITIALIZED
      +#  define WARN_UNINITIALIZED             41
      +#endif
      +
      +#ifndef WARN_UNPACK
      +#  define WARN_UNPACK                    42
      +#endif
      +
      +#ifndef WARN_UNTIE
      +#  define WARN_UNTIE                     43
      +#endif
      +
      +#ifndef WARN_UTF8
      +#  define WARN_UTF8                      44
      +#endif
      +
      +#ifndef WARN_VOID
      +#  define WARN_VOID                      45
      +#endif
      +
      +#ifndef WARN_ASSERTIONS
      +#  define WARN_ASSERTIONS                46
      +#endif
      +#ifndef packWARN
      +#  define packWARN(a)                    (a)
      +#endif
      +
      +#ifndef ckWARN
      +#  ifdef G_WARN_ON
      +#    define  ckWARN(a)                  (PL_dowarn & G_WARN_ON)
      +#  else
      +#    define  ckWARN(a)                  PL_dowarn
      +#  endif
      +#endif
      +
      +#if (PERL_BCDVERSION >= 0x5004000) && !defined(warner)
      +#if defined(NEED_warner)
      +static void DPPP_(my_warner)(U32 err, const char *pat, ...);
      +static
      +#else
      +extern void DPPP_(my_warner)(U32 err, const char *pat, ...);
      +#endif
      +
      +#define Perl_warner DPPP_(my_warner)
      +
      +#if defined(NEED_warner) || defined(NEED_warner_GLOBAL)
      +
      +void
      +DPPP_(my_warner)(U32 err, const char *pat, ...)
      +{
      +  SV *sv;
      +  va_list args;
      +
      +  PERL_UNUSED_ARG(err);
      +
      +  va_start(args, pat);
      +  sv = vnewSVpvf(pat, &args);
      +  va_end(args);
      +  sv_2mortal(sv);
      +  warn("%s", SvPV_nolen(sv));
      +}
      +
      +#define warner  Perl_warner
      +
      +#define Perl_warner_nocontext  Perl_warner
      +
      +#endif
      +#endif
      +
      +/* concatenating with "" ensures that only literal strings are accepted as argument
      + * note that STR_WITH_LEN() can't be used as argument to macros or functions that
      + * under some configurations might be macros
      + */
      +#ifndef STR_WITH_LEN
      +#  define STR_WITH_LEN(s)                (s ""), (sizeof(s)-1)
      +#endif
      +#ifndef newSVpvs
      +#  define newSVpvs(str)                  newSVpvn(str "", sizeof(str) - 1)
      +#endif
      +
      +#ifndef newSVpvs_flags
      +#  define newSVpvs_flags(str, flags)     newSVpvn_flags(str "", sizeof(str) - 1, flags)
      +#endif
      +
      +#ifndef newSVpvs_share
      +#  define newSVpvs_share(str)            newSVpvn_share(str "", sizeof(str) - 1, 0)
      +#endif
      +
      +#ifndef sv_catpvs
      +#  define sv_catpvs(sv, str)             sv_catpvn(sv, str "", sizeof(str) - 1)
      +#endif
      +
      +#ifndef sv_setpvs
      +#  define sv_setpvs(sv, str)             sv_setpvn(sv, str "", sizeof(str) - 1)
      +#endif
      +
      +#ifndef hv_fetchs
      +#  define hv_fetchs(hv, key, lval)       hv_fetch(hv, key "", sizeof(key) - 1, lval)
      +#endif
      +
      +#ifndef hv_stores
      +#  define hv_stores(hv, key, val)        hv_store(hv, key "", sizeof(key) - 1, val, 0)
      +#endif
      +#ifndef gv_fetchpvs
      +#  define gv_fetchpvs(name, flags, svt)  gv_fetchpvn_flags(name "", sizeof(name) - 1, flags, svt)
      +#endif
      +
      +#ifndef gv_stashpvs
      +#  define gv_stashpvs(name, flags)       gv_stashpvn(name "", sizeof(name) - 1, flags)
      +#endif
      +#ifndef get_cvs
      +#  define get_cvs(name, flags)           get_cvn_flags(name "", sizeof(name)-1, flags)
      +#endif
      +#ifndef SvGETMAGIC
      +#  define SvGETMAGIC(x)                  STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
      +#endif
      +
      +/* Some random bits for sv_unmagicext. These should probably be pulled in for
      +   real and organized at some point */
      +#ifndef HEf_SVKEY
      +#  define HEf_SVKEY                      -2
      +#endif
      +
      +#ifndef MUTABLE_PTR
      +#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
      +#  define MUTABLE_PTR(p) ({ void *_p = (p); _p; })
      +#else
      +#  define MUTABLE_PTR(p) ((void *) (p))
      +#endif
      +#endif
      +#ifndef MUTABLE_SV
      +#  define MUTABLE_SV(p)                  ((SV *)MUTABLE_PTR(p))
      +#endif
      +
      +/* end of random bits */
      +#ifndef PERL_MAGIC_sv
      +#  define PERL_MAGIC_sv                  '\0'
      +#endif
      +
      +#ifndef PERL_MAGIC_overload
      +#  define PERL_MAGIC_overload            'A'
      +#endif
      +
      +#ifndef PERL_MAGIC_overload_elem
      +#  define PERL_MAGIC_overload_elem       'a'
      +#endif
      +
      +#ifndef PERL_MAGIC_overload_table
      +#  define PERL_MAGIC_overload_table      'c'
      +#endif
      +
      +#ifndef PERL_MAGIC_bm
      +#  define PERL_MAGIC_bm                  'B'
      +#endif
      +
      +#ifndef PERL_MAGIC_regdata
      +#  define PERL_MAGIC_regdata             'D'
      +#endif
      +
      +#ifndef PERL_MAGIC_regdatum
      +#  define PERL_MAGIC_regdatum            'd'
      +#endif
      +
      +#ifndef PERL_MAGIC_env
      +#  define PERL_MAGIC_env                 'E'
      +#endif
      +
      +#ifndef PERL_MAGIC_envelem
      +#  define PERL_MAGIC_envelem             'e'
      +#endif
      +
      +#ifndef PERL_MAGIC_fm
      +#  define PERL_MAGIC_fm                  'f'
      +#endif
      +
      +#ifndef PERL_MAGIC_regex_global
      +#  define PERL_MAGIC_regex_global        'g'
      +#endif
      +
      +#ifndef PERL_MAGIC_isa
      +#  define PERL_MAGIC_isa                 'I'
      +#endif
      +
      +#ifndef PERL_MAGIC_isaelem
      +#  define PERL_MAGIC_isaelem             'i'
      +#endif
      +
      +#ifndef PERL_MAGIC_nkeys
      +#  define PERL_MAGIC_nkeys               'k'
      +#endif
      +
      +#ifndef PERL_MAGIC_dbfile
      +#  define PERL_MAGIC_dbfile              'L'
      +#endif
      +
      +#ifndef PERL_MAGIC_dbline
      +#  define PERL_MAGIC_dbline              'l'
      +#endif
      +
      +#ifndef PERL_MAGIC_mutex
      +#  define PERL_MAGIC_mutex               'm'
      +#endif
      +
      +#ifndef PERL_MAGIC_shared
      +#  define PERL_MAGIC_shared              'N'
      +#endif
      +
      +#ifndef PERL_MAGIC_shared_scalar
      +#  define PERL_MAGIC_shared_scalar       'n'
      +#endif
      +
      +#ifndef PERL_MAGIC_collxfrm
      +#  define PERL_MAGIC_collxfrm            'o'
      +#endif
      +
      +#ifndef PERL_MAGIC_tied
      +#  define PERL_MAGIC_tied                'P'
      +#endif
      +
      +#ifndef PERL_MAGIC_tiedelem
      +#  define PERL_MAGIC_tiedelem            'p'
      +#endif
      +
      +#ifndef PERL_MAGIC_tiedscalar
      +#  define PERL_MAGIC_tiedscalar          'q'
      +#endif
      +
      +#ifndef PERL_MAGIC_qr
      +#  define PERL_MAGIC_qr                  'r'
      +#endif
      +
      +#ifndef PERL_MAGIC_sig
      +#  define PERL_MAGIC_sig                 'S'
      +#endif
      +
      +#ifndef PERL_MAGIC_sigelem
      +#  define PERL_MAGIC_sigelem             's'
      +#endif
      +
      +#ifndef PERL_MAGIC_taint
      +#  define PERL_MAGIC_taint               't'
      +#endif
      +
      +#ifndef PERL_MAGIC_uvar
      +#  define PERL_MAGIC_uvar                'U'
      +#endif
      +
      +#ifndef PERL_MAGIC_uvar_elem
      +#  define PERL_MAGIC_uvar_elem           'u'
      +#endif
      +
      +#ifndef PERL_MAGIC_vstring
      +#  define PERL_MAGIC_vstring             'V'
      +#endif
      +
      +#ifndef PERL_MAGIC_vec
      +#  define PERL_MAGIC_vec                 'v'
      +#endif
      +
      +#ifndef PERL_MAGIC_utf8
      +#  define PERL_MAGIC_utf8                'w'
      +#endif
      +
      +#ifndef PERL_MAGIC_substr
      +#  define PERL_MAGIC_substr              'x'
      +#endif
      +
      +#ifndef PERL_MAGIC_defelem
      +#  define PERL_MAGIC_defelem             'y'
      +#endif
      +
      +#ifndef PERL_MAGIC_glob
      +#  define PERL_MAGIC_glob                '*'
      +#endif
      +
      +#ifndef PERL_MAGIC_arylen
      +#  define PERL_MAGIC_arylen              '#'
      +#endif
      +
      +#ifndef PERL_MAGIC_pos
      +#  define PERL_MAGIC_pos                 '.'
      +#endif
      +
      +#ifndef PERL_MAGIC_backref
      +#  define PERL_MAGIC_backref             '<'
      +#endif
      +
      +#ifndef PERL_MAGIC_ext
      +#  define PERL_MAGIC_ext                 '~'
      +#endif
      +
      +/* That's the best we can do... */
      +#ifndef sv_catpvn_nomg
      +#  define sv_catpvn_nomg                 sv_catpvn
      +#endif
      +
      +#ifndef sv_catsv_nomg
      +#  define sv_catsv_nomg                  sv_catsv
      +#endif
      +
      +#ifndef sv_setsv_nomg
      +#  define sv_setsv_nomg                  sv_setsv
      +#endif
      +
      +#ifndef sv_pvn_nomg
      +#  define sv_pvn_nomg                    sv_pvn
      +#endif
      +
      +#ifndef SvIV_nomg
      +#  define SvIV_nomg                      SvIV
      +#endif
      +
      +#ifndef SvUV_nomg
      +#  define SvUV_nomg                      SvUV
      +#endif
      +
      +#ifndef sv_catpv_mg
      +#  define sv_catpv_mg(sv, ptr)          \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_catpv(TeMpSv,ptr);              \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_catpvn_mg
      +#  define sv_catpvn_mg(sv, ptr, len)    \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_catpvn(TeMpSv,ptr,len);         \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_catsv_mg
      +#  define sv_catsv_mg(dsv, ssv)         \
      +   STMT_START {                         \
      +     SV *TeMpSv = dsv;                  \
      +     sv_catsv(TeMpSv,ssv);              \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setiv_mg
      +#  define sv_setiv_mg(sv, i)            \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_setiv(TeMpSv,i);                \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setnv_mg
      +#  define sv_setnv_mg(sv, num)          \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_setnv(TeMpSv,num);              \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setpv_mg
      +#  define sv_setpv_mg(sv, ptr)          \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_setpv(TeMpSv,ptr);              \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setpvn_mg
      +#  define sv_setpvn_mg(sv, ptr, len)    \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_setpvn(TeMpSv,ptr,len);         \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setsv_mg
      +#  define sv_setsv_mg(dsv, ssv)         \
      +   STMT_START {                         \
      +     SV *TeMpSv = dsv;                  \
      +     sv_setsv(TeMpSv,ssv);              \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_setuv_mg
      +#  define sv_setuv_mg(sv, i)            \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_setuv(TeMpSv,i);                \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +
      +#ifndef sv_usepvn_mg
      +#  define sv_usepvn_mg(sv, ptr, len)    \
      +   STMT_START {                         \
      +     SV *TeMpSv = sv;                   \
      +     sv_usepvn(TeMpSv,ptr,len);         \
      +     SvSETMAGIC(TeMpSv);                \
      +   } STMT_END
      +#endif
      +#ifndef SvVSTRING_mg
      +#  define SvVSTRING_mg(sv)               (SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_vstring) : NULL)
      +#endif
      +
      +/* Hint: sv_magic_portable
      + * This is a compatibility function that is only available with
      + * Devel::PPPort. It is NOT in the perl core.
      + * Its purpose is to mimic the 5.8.0 behaviour of sv_magic() when
      + * it is being passed a name pointer with namlen == 0. In that
      + * case, perl 5.8.0 and later store the pointer, not a copy of it.
      + * The compatibility can be provided back to perl 5.004. With
      + * earlier versions, the code will not compile.
      + */
      +
      +#if (PERL_BCDVERSION < 0x5004000)
      +
      +  /* code that uses sv_magic_portable will not compile */
      +
      +#elif (PERL_BCDVERSION < 0x5008000)
      +
      +#  define sv_magic_portable(sv, obj, how, name, namlen)     \
      +   STMT_START {                                             \
      +     SV *SvMp_sv = (sv);                                    \
      +     char *SvMp_name = (char *) (name);                     \
      +     I32 SvMp_namlen = (namlen);                            \
      +     if (SvMp_name && SvMp_namlen == 0)                     \
      +     {                                                      \
      +       MAGIC *mg;                                           \
      +       sv_magic(SvMp_sv, obj, how, 0, 0);                   \
      +       mg = SvMAGIC(SvMp_sv);                               \
      +       mg->mg_len = -42; /* XXX: this is the tricky part */ \
      +       mg->mg_ptr = SvMp_name;                              \
      +     }                                                      \
      +     else                                                   \
      +     {                                                      \
      +       sv_magic(SvMp_sv, obj, how, SvMp_name, SvMp_namlen); \
      +     }                                                      \
      +   } STMT_END
      +
      +#else
      +
      +#  define sv_magic_portable(a, b, c, d, e)  sv_magic(a, b, c, d, e)
      +
      +#endif
      +
      +#if !defined(mg_findext)
      +#if defined(NEED_mg_findext)
      +static MAGIC * DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl);
      +static
      +#else
      +extern MAGIC * DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl);
      +#endif
      +
      +#define mg_findext DPPP_(my_mg_findext)
      +#define Perl_mg_findext DPPP_(my_mg_findext)
      +
      +#if defined(NEED_mg_findext) || defined(NEED_mg_findext_GLOBAL)
      +
      +MAGIC *
      +DPPP_(my_mg_findext)(SV * sv, int type, const MGVTBL *vtbl) {
      +    if (sv) {
      +        MAGIC *mg;
      +
      +#ifdef AvPAD_NAMELIST
      +        assert(!(SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)));
      +#endif
      +
      +        for (mg = SvMAGIC (sv); mg; mg = mg->mg_moremagic) {
      +            if (mg->mg_type == type && mg->mg_virtual == vtbl)
      +                return mg;
      +        }
      +    }
      +
      +    return NULL;
      +}
      +
      +#endif
      +#endif
      +
      +#if !defined(sv_unmagicext)
      +#if defined(NEED_sv_unmagicext)
      +static int DPPP_(my_sv_unmagicext)(pTHX_ SV * const sv, const int type, MGVTBL * vtbl);
      +static
      +#else
      +extern int DPPP_(my_sv_unmagicext)(pTHX_ SV * const sv, const int type, MGVTBL * vtbl);
      +#endif
      +
      +#ifdef sv_unmagicext
      +#  undef sv_unmagicext
      +#endif
      +#define sv_unmagicext(a,b,c) DPPP_(my_sv_unmagicext)(aTHX_ a,b,c)
      +#define Perl_sv_unmagicext DPPP_(my_sv_unmagicext)
      +
      +#if defined(NEED_sv_unmagicext) || defined(NEED_sv_unmagicext_GLOBAL)
      +
      +int
      +DPPP_(my_sv_unmagicext)(pTHX_ SV *const sv, const int type, MGVTBL *vtbl)
      +{
      +    MAGIC* mg;
      +    MAGIC** mgp;
      +
      +    if (SvTYPE(sv) < SVt_PVMG || !SvMAGIC(sv))
      +	return 0;
      +    mgp = &(SvMAGIC(sv));
      +    for (mg = *mgp; mg; mg = *mgp) {
      +	const MGVTBL* const virt = mg->mg_virtual;
      +	if (mg->mg_type == type && virt == vtbl) {
      +	    *mgp = mg->mg_moremagic;
      +	    if (virt && virt->svt_free)
      +		virt->svt_free(aTHX_ sv, mg);
      +	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
      +		if (mg->mg_len > 0)
      +		    Safefree(mg->mg_ptr);
      +		else if (mg->mg_len == HEf_SVKEY) /* Questionable on older perls... */
      +		    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
      +		else if (mg->mg_type == PERL_MAGIC_utf8)
      +		    Safefree(mg->mg_ptr);
      +            }
      +	    if (mg->mg_flags & MGf_REFCOUNTED)
      +		SvREFCNT_dec(mg->mg_obj);
      +	    Safefree(mg);
      +	}
      +	else
      +	    mgp = &mg->mg_moremagic;
      +    }
      +    if (SvMAGIC(sv)) {
      +	if (SvMAGICAL(sv))	/* if we're under save_magic, wait for restore_magic; */
      +	    mg_magical(sv);	/*    else fix the flags now */
      +    }
      +    else {
      +	SvMAGICAL_off(sv);
      +	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
      +    }
      +    return 0;
      +}
      +
      +#endif
      +#endif
      +
      +#ifdef USE_ITHREADS
      +#ifndef CopFILE
      +#  define CopFILE(c)                     ((c)->cop_file)
      +#endif
      +
      +#ifndef CopFILEGV
      +#  define CopFILEGV(c)                   (CopFILE(c) ? gv_fetchfile(CopFILE(c)) : Nullgv)
      +#endif
      +
      +#ifndef CopFILE_set
      +#  define CopFILE_set(c,pv)              ((c)->cop_file = savepv(pv))
      +#endif
      +
      +#ifndef CopFILESV
      +#  define CopFILESV(c)                   (CopFILE(c) ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
      +#endif
      +
      +#ifndef CopFILEAV
      +#  define CopFILEAV(c)                   (CopFILE(c) ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
      +#endif
      +
      +#ifndef CopSTASHPV
      +#  define CopSTASHPV(c)                  ((c)->cop_stashpv)
      +#endif
      +
      +#ifndef CopSTASHPV_set
      +#  define CopSTASHPV_set(c,pv)           ((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
      +#endif
      +
      +#ifndef CopSTASH
      +#  define CopSTASH(c)                    (CopSTASHPV(c) ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
      +#endif
      +
      +#ifndef CopSTASH_set
      +#  define CopSTASH_set(c,hv)             CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
      +#endif
      +
      +#ifndef CopSTASH_eq
      +#  define CopSTASH_eq(c,hv)              ((hv) && (CopSTASHPV(c) == HvNAME(hv) \
      +                                        || (CopSTASHPV(c) && HvNAME(hv) \
      +                                        && strEQ(CopSTASHPV(c), HvNAME(hv)))))
      +#endif
      +
      +#else
      +#ifndef CopFILEGV
      +#  define CopFILEGV(c)                   ((c)->cop_filegv)
      +#endif
      +
      +#ifndef CopFILEGV_set
      +#  define CopFILEGV_set(c,gv)            ((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
      +#endif
      +
      +#ifndef CopFILE_set
      +#  define CopFILE_set(c,pv)              CopFILEGV_set((c), gv_fetchfile(pv))
      +#endif
      +
      +#ifndef CopFILESV
      +#  define CopFILESV(c)                   (CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
      +#endif
      +
      +#ifndef CopFILEAV
      +#  define CopFILEAV(c)                   (CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
      +#endif
      +
      +#ifndef CopFILE
      +#  define CopFILE(c)                     (CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
      +#endif
      +
      +#ifndef CopSTASH
      +#  define CopSTASH(c)                    ((c)->cop_stash)
      +#endif
      +
      +#ifndef CopSTASH_set
      +#  define CopSTASH_set(c,hv)             ((c)->cop_stash = (hv))
      +#endif
      +
      +#ifndef CopSTASHPV
      +#  define CopSTASHPV(c)                  (CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
      +#endif
      +
      +#ifndef CopSTASHPV_set
      +#  define CopSTASHPV_set(c,pv)           CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
      +#endif
      +
      +#ifndef CopSTASH_eq
      +#  define CopSTASH_eq(c,hv)              (CopSTASH(c) == (hv))
      +#endif
      +
      +#endif /* USE_ITHREADS */
      +
      +#if (PERL_BCDVERSION >= 0x5006000)
      +#ifndef caller_cx
      +
      +# if defined(NEED_caller_cx) || defined(NEED_caller_cx_GLOBAL)
      +static I32
      +DPPP_dopoptosub_at(const PERL_CONTEXT *cxstk, I32 startingblock)
      +{
      +    I32 i;
      +
      +    for (i = startingblock; i >= 0; i--) {
      +	register const PERL_CONTEXT * const cx = &cxstk[i];
      +	switch (CxTYPE(cx)) {
      +	default:
      +	    continue;
      +	case CXt_EVAL:
      +	case CXt_SUB:
      +	case CXt_FORMAT:
      +	    return i;
      +	}
      +    }
      +    return i;
      +}
      +# endif
      +
      +# if defined(NEED_caller_cx)
      +static const PERL_CONTEXT * DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp);
      +static
      +#else
      +extern const PERL_CONTEXT * DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp);
      +#endif
      +
      +#ifdef caller_cx
      +#  undef caller_cx
      +#endif
      +#define caller_cx(a,b) DPPP_(my_caller_cx)(aTHX_ a,b)
      +#define Perl_caller_cx DPPP_(my_caller_cx)
      +
      +#if defined(NEED_caller_cx) || defined(NEED_caller_cx_GLOBAL)
      +
      +const PERL_CONTEXT *
      +DPPP_(my_caller_cx)(pTHX_ I32 count, const PERL_CONTEXT **dbcxp)
      +{
      +    register I32 cxix = DPPP_dopoptosub_at(cxstack, cxstack_ix);
      +    register const PERL_CONTEXT *cx;
      +    register const PERL_CONTEXT *ccstack = cxstack;
      +    const PERL_SI *top_si = PL_curstackinfo;
      +
      +    for (;;) {
      +	/* we may be in a higher stacklevel, so dig down deeper */
      +	while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
      +	    top_si = top_si->si_prev;
      +	    ccstack = top_si->si_cxstack;
      +	    cxix = DPPP_dopoptosub_at(ccstack, top_si->si_cxix);
      +	}
      +	if (cxix < 0)
      +	    return NULL;
      +	/* caller() should not report the automatic calls to &DB::sub */
      +	if (PL_DBsub && GvCV(PL_DBsub) && cxix >= 0 &&
      +		ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))
      +	    count++;
      +	if (!count--)
      +	    break;
      +	cxix = DPPP_dopoptosub_at(ccstack, cxix - 1);
      +    }
      +
      +    cx = &ccstack[cxix];
      +    if (dbcxp) *dbcxp = cx;
      +
      +    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
      +        const I32 dbcxix = DPPP_dopoptosub_at(ccstack, cxix - 1);
      +	/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the
      +	   field below is defined for any cx. */
      +	/* caller() should not report the automatic calls to &DB::sub */
      +	if (PL_DBsub && GvCV(PL_DBsub) && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
      +	    cx = &ccstack[dbcxix];
      +    }
      +
      +    return cx;
      +}
      +
      +# endif
      +#endif /* caller_cx */
      +#endif /* 5.6.0 */
      +#ifndef IN_PERL_COMPILETIME
      +#  define IN_PERL_COMPILETIME            (PL_curcop == &PL_compiling)
      +#endif
      +
      +#ifndef IN_LOCALE_RUNTIME
      +#  define IN_LOCALE_RUNTIME              (PL_curcop->op_private & HINT_LOCALE)
      +#endif
      +
      +#ifndef IN_LOCALE_COMPILETIME
      +#  define IN_LOCALE_COMPILETIME          (PL_hints & HINT_LOCALE)
      +#endif
      +
      +#ifndef IN_LOCALE
      +#  define IN_LOCALE                      (IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
      +#endif
      +#ifndef IS_NUMBER_IN_UV
      +#  define IS_NUMBER_IN_UV                0x01
      +#endif
      +
      +#ifndef IS_NUMBER_GREATER_THAN_UV_MAX
      +#  define IS_NUMBER_GREATER_THAN_UV_MAX  0x02
      +#endif
      +
      +#ifndef IS_NUMBER_NOT_INT
      +#  define IS_NUMBER_NOT_INT              0x04
      +#endif
      +
      +#ifndef IS_NUMBER_NEG
      +#  define IS_NUMBER_NEG                  0x08
      +#endif
      +
      +#ifndef IS_NUMBER_INFINITY
      +#  define IS_NUMBER_INFINITY             0x10
      +#endif
      +
      +#ifndef IS_NUMBER_NAN
      +#  define IS_NUMBER_NAN                  0x20
      +#endif
      +#ifndef GROK_NUMERIC_RADIX
      +#  define GROK_NUMERIC_RADIX(sp, send)   grok_numeric_radix(sp, send)
      +#endif
      +#ifndef PERL_SCAN_GREATER_THAN_UV_MAX
      +#  define PERL_SCAN_GREATER_THAN_UV_MAX  0x02
      +#endif
      +
      +#ifndef PERL_SCAN_SILENT_ILLDIGIT
      +#  define PERL_SCAN_SILENT_ILLDIGIT      0x04
      +#endif
      +
      +#ifndef PERL_SCAN_ALLOW_UNDERSCORES
      +#  define PERL_SCAN_ALLOW_UNDERSCORES    0x01
      +#endif
      +
      +#ifndef PERL_SCAN_DISALLOW_PREFIX
      +#  define PERL_SCAN_DISALLOW_PREFIX      0x02
      +#endif
      +
      +#ifndef grok_numeric_radix
      +#if defined(NEED_grok_numeric_radix)
      +static bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
      +static
      +#else
      +extern bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
      +#endif
      +
      +#ifdef grok_numeric_radix
      +#  undef grok_numeric_radix
      +#endif
      +#define grok_numeric_radix(a,b) DPPP_(my_grok_numeric_radix)(aTHX_ a,b)
      +#define Perl_grok_numeric_radix DPPP_(my_grok_numeric_radix)
      +
      +#if defined(NEED_grok_numeric_radix) || defined(NEED_grok_numeric_radix_GLOBAL)
      +bool
      +DPPP_(my_grok_numeric_radix)(pTHX_ const char **sp, const char *send)
      +{
      +#ifdef USE_LOCALE_NUMERIC
      +#ifdef PL_numeric_radix_sv
      +    if (PL_numeric_radix_sv && IN_LOCALE) {
      +        STRLEN len;
      +        char* radix = SvPV(PL_numeric_radix_sv, len);
      +        if (*sp + len <= send && memEQ(*sp, radix, len)) {
      +            *sp += len;
      +            return TRUE;
      +        }
      +    }
      +#else
      +    /* older perls don't have PL_numeric_radix_sv so the radix
      +     * must manually be requested from locale.h
      +     */
      +#include <locale.h>
      +    dTHR;  /* needed for older threaded perls */
      +    struct lconv *lc = localeconv();
      +    char *radix = lc->decimal_point;
      +    if (radix && IN_LOCALE) {
      +        STRLEN len = strlen(radix);
      +        if (*sp + len <= send && memEQ(*sp, radix, len)) {
      +            *sp += len;
      +            return TRUE;
      +        }
      +    }
      +#endif
      +#endif /* USE_LOCALE_NUMERIC */
      +    /* always try "." if numeric radix didn't match because
      +     * we may have data from different locales mixed */
      +    if (*sp < send && **sp == '.') {
      +        ++*sp;
      +        return TRUE;
      +    }
      +    return FALSE;
      +}
      +#endif
      +#endif
      +
      +#ifndef grok_number
      +#if defined(NEED_grok_number)
      +static int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
      +static
      +#else
      +extern int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
      +#endif
      +
      +#ifdef grok_number
      +#  undef grok_number
      +#endif
      +#define grok_number(a,b,c) DPPP_(my_grok_number)(aTHX_ a,b,c)
      +#define Perl_grok_number DPPP_(my_grok_number)
      +
      +#if defined(NEED_grok_number) || defined(NEED_grok_number_GLOBAL)
      +int
      +DPPP_(my_grok_number)(pTHX_ const char *pv, STRLEN len, UV *valuep)
      +{
      +  const char *s = pv;
      +  const char *send = pv + len;
      +  const UV max_div_10 = UV_MAX / 10;
      +  const char max_mod_10 = UV_MAX % 10;
      +  int numtype = 0;
      +  int sawinf = 0;
      +  int sawnan = 0;
      +
      +  while (s < send && isSPACE(*s))
      +    s++;
      +  if (s == send) {
      +    return 0;
      +  } else if (*s == '-') {
      +    s++;
      +    numtype = IS_NUMBER_NEG;
      +  }
      +  else if (*s == '+')
      +  s++;
      +
      +  if (s == send)
      +    return 0;
      +
      +  /* next must be digit or the radix separator or beginning of infinity */
      +  if (isDIGIT(*s)) {
      +    /* UVs are at least 32 bits, so the first 9 decimal digits cannot
      +       overflow.  */
      +    UV value = *s - '0';
      +    /* This construction seems to be more optimiser friendly.
      +       (without it gcc does the isDIGIT test and the *s - '0' separately)
      +       With it gcc on arm is managing 6 instructions (6 cycles) per digit.
      +       In theory the optimiser could deduce how far to unroll the loop
      +       before checking for overflow.  */
      +    if (++s < send) {
      +      int digit = *s - '0';
      +      if (digit >= 0 && digit <= 9) {
      +        value = value * 10 + digit;
      +        if (++s < send) {
      +          digit = *s - '0';
      +          if (digit >= 0 && digit <= 9) {
      +            value = value * 10 + digit;
      +            if (++s < send) {
      +              digit = *s - '0';
      +              if (digit >= 0 && digit <= 9) {
      +                value = value * 10 + digit;
      +                if (++s < send) {
      +                  digit = *s - '0';
      +                  if (digit >= 0 && digit <= 9) {
      +                    value = value * 10 + digit;
      +                    if (++s < send) {
      +                      digit = *s - '0';
      +                      if (digit >= 0 && digit <= 9) {
      +                        value = value * 10 + digit;
      +                        if (++s < send) {
      +                          digit = *s - '0';
      +                          if (digit >= 0 && digit <= 9) {
      +                            value = value * 10 + digit;
      +                            if (++s < send) {
      +                              digit = *s - '0';
      +                              if (digit >= 0 && digit <= 9) {
      +                                value = value * 10 + digit;
      +                                if (++s < send) {
      +                                  digit = *s - '0';
      +                                  if (digit >= 0 && digit <= 9) {
      +                                    value = value * 10 + digit;
      +                                    if (++s < send) {
      +                                      /* Now got 9 digits, so need to check
      +                                         each time for overflow.  */
      +                                      digit = *s - '0';
      +                                      while (digit >= 0 && digit <= 9
      +                                             && (value < max_div_10
      +                                                 || (value == max_div_10
      +                                                     && digit <= max_mod_10))) {
      +                                        value = value * 10 + digit;
      +                                        if (++s < send)
      +                                          digit = *s - '0';
      +                                        else
      +                                          break;
      +                                      }
      +                                      if (digit >= 0 && digit <= 9
      +                                          && (s < send)) {
      +                                        /* value overflowed.
      +                                           skip the remaining digits, don't
      +                                           worry about setting *valuep.  */
      +                                        do {
      +                                          s++;
      +                                        } while (s < send && isDIGIT(*s));
      +                                        numtype |=
      +                                          IS_NUMBER_GREATER_THAN_UV_MAX;
      +                                        goto skip_value;
      +                                      }
      +                                    }
      +                                  }
      +                                }
      +                              }
      +                            }
      +                          }
      +                        }
      +                      }
      +                    }
      +                  }
      +                }
      +              }
      +            }
      +          }
      +        }
      +      }
      +    }
      +    numtype |= IS_NUMBER_IN_UV;
      +    if (valuep)
      +      *valuep = value;
      +
      +  skip_value:
      +    if (GROK_NUMERIC_RADIX(&s, send)) {
      +      numtype |= IS_NUMBER_NOT_INT;
      +      while (s < send && isDIGIT(*s))  /* optional digits after the radix */
      +        s++;
      +    }
      +  }
      +  else if (GROK_NUMERIC_RADIX(&s, send)) {
      +    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */
      +    /* no digits before the radix means we need digits after it */
      +    if (s < send && isDIGIT(*s)) {
      +      do {
      +        s++;
      +      } while (s < send && isDIGIT(*s));
      +      if (valuep) {
      +        /* integer approximation is valid - it's 0.  */
      +        *valuep = 0;
      +      }
      +    }
      +    else
      +      return 0;
      +  } else if (*s == 'I' || *s == 'i') {
      +    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      +    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;
      +    s++; if (s < send && (*s == 'I' || *s == 'i')) {
      +      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      +      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;
      +      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;
      +      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;
      +      s++;
      +    }
      +    sawinf = 1;
      +  } else if (*s == 'N' || *s == 'n') {
      +    /* XXX TODO: There are signaling NaNs and quiet NaNs. */
      +    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;
      +    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      +    s++;
      +    sawnan = 1;
      +  } else
      +    return 0;
      +
      +  if (sawinf) {
      +    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
      +    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
      +  } else if (sawnan) {
      +    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
      +    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
      +  } else if (s < send) {
      +    /* we can have an optional exponent part */
      +    if (*s == 'e' || *s == 'E') {
      +      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      +      numtype &= IS_NUMBER_NEG;
      +      numtype |= IS_NUMBER_NOT_INT;
      +      s++;
      +      if (s < send && (*s == '-' || *s == '+'))
      +        s++;
      +      if (s < send && isDIGIT(*s)) {
      +        do {
      +          s++;
      +        } while (s < send && isDIGIT(*s));
      +      }
      +      else
      +      return 0;
      +    }
      +  }
      +  while (s < send && isSPACE(*s))
      +    s++;
      +  if (s >= send)
      +    return numtype;
      +  if (len == 10 && memEQ(pv, "0 but true", 10)) {
      +    if (valuep)
      +      *valuep = 0;
      +    return IS_NUMBER_IN_UV;
      +  }
      +  return 0;
      +}
      +#endif
      +#endif
      +
      +/*
      + * The grok_* routines have been modified to use warn() instead of
      + * Perl_warner(). Also, 'hexdigit' was the former name of PL_hexdigit,
      + * which is why the stack variable has been renamed to 'xdigit'.
      + */
      +
      +#ifndef grok_bin
      +#if defined(NEED_grok_bin)
      +static UV DPPP_(my_grok_bin)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +static
      +#else
      +extern UV DPPP_(my_grok_bin)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +#endif
      +
      +#ifdef grok_bin
      +#  undef grok_bin
      +#endif
      +#define grok_bin(a,b,c,d) DPPP_(my_grok_bin)(aTHX_ a,b,c,d)
      +#define Perl_grok_bin DPPP_(my_grok_bin)
      +
      +#if defined(NEED_grok_bin) || defined(NEED_grok_bin_GLOBAL)
      +UV
      +DPPP_(my_grok_bin)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
      +{
      +    const char *s = start;
      +    STRLEN len = *len_p;
      +    UV value = 0;
      +    NV value_nv = 0;
      +
      +    const UV max_div_2 = UV_MAX / 2;
      +    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
      +    bool overflowed = FALSE;
      +
      +    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
      +        /* strip off leading b or 0b.
      +           for compatibility silently suffer "b" and "0b" as valid binary
      +           numbers. */
      +        if (len >= 1) {
      +            if (s[0] == 'b') {
      +                s++;
      +                len--;
      +            }
      +            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {
      +                s+=2;
      +                len-=2;
      +            }
      +        }
      +    }
      +
      +    for (; len-- && *s; s++) {
      +        char bit = *s;
      +        if (bit == '0' || bit == '1') {
      +            /* Write it in this wonky order with a goto to attempt to get the
      +               compiler to make the common case integer-only loop pretty tight.
      +               With gcc seems to be much straighter code than old scan_bin.  */
      +          redo:
      +            if (!overflowed) {
      +                if (value <= max_div_2) {
      +                    value = (value << 1) | (bit - '0');
      +                    continue;
      +                }
      +                /* Bah. We're just overflowed.  */
      +                warn("Integer overflow in binary number");
      +                overflowed = TRUE;
      +                value_nv = (NV) value;
      +            }
      +            value_nv *= 2.0;
      +            /* If an NV has not enough bits in its mantissa to
      +             * represent a UV this summing of small low-order numbers
      +             * is a waste of time (because the NV cannot preserve
      +             * the low-order bits anyway): we could just remember when
      +             * did we overflow and in the end just multiply value_nv by the
      +             * right amount. */
      +            value_nv += (NV)(bit - '0');
      +            continue;
      +        }
      +        if (bit == '_' && len && allow_underscores && (bit = s[1])
      +            && (bit == '0' || bit == '1'))
      +            {
      +                --len;
      +                ++s;
      +                goto redo;
      +            }
      +        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
      +            warn("Illegal binary digit '%c' ignored", *s);
      +        break;
      +    }
      +
      +    if (   ( overflowed && value_nv > 4294967295.0)
      +#if UVSIZE > 4
      +        || (!overflowed && value > 0xffffffff  )
      +#endif
      +        ) {
      +        warn("Binary number > 0b11111111111111111111111111111111 non-portable");
      +    }
      +    *len_p = s - start;
      +    if (!overflowed) {
      +        *flags = 0;
      +        return value;
      +    }
      +    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
      +    if (result)
      +        *result = value_nv;
      +    return UV_MAX;
      +}
      +#endif
      +#endif
      +
      +#ifndef grok_hex
      +#if defined(NEED_grok_hex)
      +static UV DPPP_(my_grok_hex)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +static
      +#else
      +extern UV DPPP_(my_grok_hex)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +#endif
      +
      +#ifdef grok_hex
      +#  undef grok_hex
      +#endif
      +#define grok_hex(a,b,c,d) DPPP_(my_grok_hex)(aTHX_ a,b,c,d)
      +#define Perl_grok_hex DPPP_(my_grok_hex)
      +
      +#if defined(NEED_grok_hex) || defined(NEED_grok_hex_GLOBAL)
      +UV
      +DPPP_(my_grok_hex)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
      +{
      +    const char *s = start;
      +    STRLEN len = *len_p;
      +    UV value = 0;
      +    NV value_nv = 0;
      +
      +    const UV max_div_16 = UV_MAX / 16;
      +    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
      +    bool overflowed = FALSE;
      +    const char *xdigit;
      +
      +    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
      +        /* strip off leading x or 0x.
      +           for compatibility silently suffer "x" and "0x" as valid hex numbers.
      +        */
      +        if (len >= 1) {
      +            if (s[0] == 'x') {
      +                s++;
      +                len--;
      +            }
      +            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {
      +                s+=2;
      +                len-=2;
      +            }
      +        }
      +    }
      +
      +    for (; len-- && *s; s++) {
      +        xdigit = strchr((char *) PL_hexdigit, *s);
      +        if (xdigit) {
      +            /* Write it in this wonky order with a goto to attempt to get the
      +               compiler to make the common case integer-only loop pretty tight.
      +               With gcc seems to be much straighter code than old scan_hex.  */
      +          redo:
      +            if (!overflowed) {
      +                if (value <= max_div_16) {
      +                    value = (value << 4) | ((xdigit - PL_hexdigit) & 15);
      +                    continue;
      +                }
      +                warn("Integer overflow in hexadecimal number");
      +                overflowed = TRUE;
      +                value_nv = (NV) value;
      +            }
      +            value_nv *= 16.0;
      +            /* If an NV has not enough bits in its mantissa to
      +             * represent a UV this summing of small low-order numbers
      +             * is a waste of time (because the NV cannot preserve
      +             * the low-order bits anyway): we could just remember when
      +             * did we overflow and in the end just multiply value_nv by the
      +             * right amount of 16-tuples. */
      +            value_nv += (NV)((xdigit - PL_hexdigit) & 15);
      +            continue;
      +        }
      +        if (*s == '_' && len && allow_underscores && s[1]
      +                && (xdigit = strchr((char *) PL_hexdigit, s[1])))
      +            {
      +                --len;
      +                ++s;
      +                goto redo;
      +            }
      +        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
      +            warn("Illegal hexadecimal digit '%c' ignored", *s);
      +        break;
      +    }
      +
      +    if (   ( overflowed && value_nv > 4294967295.0)
      +#if UVSIZE > 4
      +        || (!overflowed && value > 0xffffffff  )
      +#endif
      +        ) {
      +        warn("Hexadecimal number > 0xffffffff non-portable");
      +    }
      +    *len_p = s - start;
      +    if (!overflowed) {
      +        *flags = 0;
      +        return value;
      +    }
      +    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
      +    if (result)
      +        *result = value_nv;
      +    return UV_MAX;
      +}
      +#endif
      +#endif
      +
      +#ifndef grok_oct
      +#if defined(NEED_grok_oct)
      +static UV DPPP_(my_grok_oct)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +static
      +#else
      +extern UV DPPP_(my_grok_oct)(pTHX_ const char * start, STRLEN * len_p, I32 * flags, NV * result);
      +#endif
      +
      +#ifdef grok_oct
      +#  undef grok_oct
      +#endif
      +#define grok_oct(a,b,c,d) DPPP_(my_grok_oct)(aTHX_ a,b,c,d)
      +#define Perl_grok_oct DPPP_(my_grok_oct)
      +
      +#if defined(NEED_grok_oct) || defined(NEED_grok_oct_GLOBAL)
      +UV
      +DPPP_(my_grok_oct)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
      +{
      +    const char *s = start;
      +    STRLEN len = *len_p;
      +    UV value = 0;
      +    NV value_nv = 0;
      +
      +    const UV max_div_8 = UV_MAX / 8;
      +    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
      +    bool overflowed = FALSE;
      +
      +    for (; len-- && *s; s++) {
      +         /* gcc 2.95 optimiser not smart enough to figure that this subtraction
      +            out front allows slicker code.  */
      +        int digit = *s - '0';
      +        if (digit >= 0 && digit <= 7) {
      +            /* Write it in this wonky order with a goto to attempt to get the
      +               compiler to make the common case integer-only loop pretty tight.
      +            */
      +          redo:
      +            if (!overflowed) {
      +                if (value <= max_div_8) {
      +                    value = (value << 3) | digit;
      +                    continue;
      +                }
      +                /* Bah. We're just overflowed.  */
      +                warn("Integer overflow in octal number");
      +                overflowed = TRUE;
      +                value_nv = (NV) value;
      +            }
      +            value_nv *= 8.0;
      +            /* If an NV has not enough bits in its mantissa to
      +             * represent a UV this summing of small low-order numbers
      +             * is a waste of time (because the NV cannot preserve
      +             * the low-order bits anyway): we could just remember when
      +             * did we overflow and in the end just multiply value_nv by the
      +             * right amount of 8-tuples. */
      +            value_nv += (NV)digit;
      +            continue;
      +        }
      +        if (digit == ('_' - '0') && len && allow_underscores
      +            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))
      +            {
      +                --len;
      +                ++s;
      +                goto redo;
      +            }
      +        /* Allow \octal to work the DWIM way (that is, stop scanning
      +         * as soon as non-octal characters are seen, complain only iff
      +         * someone seems to want to use the digits eight and nine). */
      +        if (digit == 8 || digit == 9) {
      +            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
      +                warn("Illegal octal digit '%c' ignored", *s);
      +        }
      +        break;
      +    }
      +
      +    if (   ( overflowed && value_nv > 4294967295.0)
      +#if UVSIZE > 4
      +        || (!overflowed && value > 0xffffffff  )
      +#endif
      +        ) {
      +        warn("Octal number > 037777777777 non-portable");
      +    }
      +    *len_p = s - start;
      +    if (!overflowed) {
      +        *flags = 0;
      +        return value;
      +    }
      +    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
      +    if (result)
      +        *result = value_nv;
      +    return UV_MAX;
      +}
      +#endif
      +#endif
      +
      +#if !defined(my_snprintf)
      +#if defined(NEED_my_snprintf)
      +static int DPPP_(my_my_snprintf)(char * buffer, const Size_t len, const char * format, ...);
      +static
      +#else
      +extern int DPPP_(my_my_snprintf)(char * buffer, const Size_t len, const char * format, ...);
      +#endif
      +
      +#define my_snprintf DPPP_(my_my_snprintf)
      +#define Perl_my_snprintf DPPP_(my_my_snprintf)
      +
      +#if defined(NEED_my_snprintf) || defined(NEED_my_snprintf_GLOBAL)
      +
      +int
      +DPPP_(my_my_snprintf)(char *buffer, const Size_t len, const char *format, ...)
      +{
      +    dTHX;
      +    int retval;
      +    va_list ap;
      +    va_start(ap, format);
      +#ifdef HAS_VSNPRINTF
      +    retval = vsnprintf(buffer, len, format, ap);
      +#else
      +    retval = vsprintf(buffer, format, ap);
      +#endif
      +    va_end(ap);
      +    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
      +        Perl_croak(aTHX_ "panic: my_snprintf buffer overflow");
      +    return retval;
      +}
      +
      +#endif
      +#endif
      +
      +#if !defined(my_sprintf)
      +#if defined(NEED_my_sprintf)
      +static int DPPP_(my_my_sprintf)(char * buffer, const char * pat, ...);
      +static
      +#else
      +extern int DPPP_(my_my_sprintf)(char * buffer, const char * pat, ...);
      +#endif
      +
      +#define my_sprintf DPPP_(my_my_sprintf)
      +#define Perl_my_sprintf DPPP_(my_my_sprintf)
      +
      +#if defined(NEED_my_sprintf) || defined(NEED_my_sprintf_GLOBAL)
      +
      +int
      +DPPP_(my_my_sprintf)(char *buffer, const char* pat, ...)
      +{
      +    va_list args;
      +    va_start(args, pat);
      +    vsprintf(buffer, pat, args);
      +    va_end(args);
      +    return strlen(buffer);
      +}
      +
      +#endif
      +#endif
      +
      +#ifdef NO_XSLOCKS
      +#  ifdef dJMPENV
      +#    define dXCPT             dJMPENV; int rEtV = 0
      +#    define XCPT_TRY_START    JMPENV_PUSH(rEtV); if (rEtV == 0)
      +#    define XCPT_TRY_END      JMPENV_POP;
      +#    define XCPT_CATCH        if (rEtV != 0)
      +#    define XCPT_RETHROW      JMPENV_JUMP(rEtV)
      +#  else
      +#    define dXCPT             Sigjmp_buf oldTOP; int rEtV = 0
      +#    define XCPT_TRY_START    Copy(top_env, oldTOP, 1, Sigjmp_buf); rEtV = Sigsetjmp(top_env, 1); if (rEtV == 0)
      +#    define XCPT_TRY_END      Copy(oldTOP, top_env, 1, Sigjmp_buf);
      +#    define XCPT_CATCH        if (rEtV != 0)
      +#    define XCPT_RETHROW      Siglongjmp(top_env, rEtV)
      +#  endif
      +#endif
      +
      +#if !defined(my_strlcat)
      +#if defined(NEED_my_strlcat)
      +static Size_t DPPP_(my_my_strlcat)(char * dst, const char * src, Size_t size);
      +static
      +#else
      +extern Size_t DPPP_(my_my_strlcat)(char * dst, const char * src, Size_t size);
      +#endif
      +
      +#define my_strlcat DPPP_(my_my_strlcat)
      +#define Perl_my_strlcat DPPP_(my_my_strlcat)
      +
      +#if defined(NEED_my_strlcat) || defined(NEED_my_strlcat_GLOBAL)
      +
      +Size_t
      +DPPP_(my_my_strlcat)(char *dst, const char *src, Size_t size)
      +{
      +    Size_t used, length, copy;
      +
      +    used = strlen(dst);
      +    length = strlen(src);
      +    if (size > 0 && used < size - 1) {
      +        copy = (length >= size - used) ? size - used - 1 : length;
      +        memcpy(dst + used, src, copy);
      +        dst[used + copy] = '\0';
      +    }
      +    return used + length;
      +}
      +#endif
      +#endif
      +
      +#if !defined(my_strlcpy)
      +#if defined(NEED_my_strlcpy)
      +static Size_t DPPP_(my_my_strlcpy)(char * dst, const char * src, Size_t size);
      +static
      +#else
      +extern Size_t DPPP_(my_my_strlcpy)(char * dst, const char * src, Size_t size);
      +#endif
      +
      +#define my_strlcpy DPPP_(my_my_strlcpy)
      +#define Perl_my_strlcpy DPPP_(my_my_strlcpy)
      +
      +#if defined(NEED_my_strlcpy) || defined(NEED_my_strlcpy_GLOBAL)
      +
      +Size_t
      +DPPP_(my_my_strlcpy)(char *dst, const char *src, Size_t size)
      +{
      +    Size_t length, copy;
      +
      +    length = strlen(src);
      +    if (size > 0) {
      +        copy = (length >= size) ? size - 1 : length;
      +        memcpy(dst, src, copy);
      +        dst[copy] = '\0';
      +    }
      +    return length;
      +}
      +
      +#endif
      +#endif
      +#ifndef PERL_PV_ESCAPE_QUOTE
      +#  define PERL_PV_ESCAPE_QUOTE           0x0001
      +#endif
      +
      +#ifndef PERL_PV_PRETTY_QUOTE
      +#  define PERL_PV_PRETTY_QUOTE           PERL_PV_ESCAPE_QUOTE
      +#endif
      +
      +#ifndef PERL_PV_PRETTY_ELLIPSES
      +#  define PERL_PV_PRETTY_ELLIPSES        0x0002
      +#endif
      +
      +#ifndef PERL_PV_PRETTY_LTGT
      +#  define PERL_PV_PRETTY_LTGT            0x0004
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_FIRSTCHAR
      +#  define PERL_PV_ESCAPE_FIRSTCHAR       0x0008
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_UNI
      +#  define PERL_PV_ESCAPE_UNI             0x0100
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_UNI_DETECT
      +#  define PERL_PV_ESCAPE_UNI_DETECT      0x0200
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_ALL
      +#  define PERL_PV_ESCAPE_ALL             0x1000
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_NOBACKSLASH
      +#  define PERL_PV_ESCAPE_NOBACKSLASH     0x2000
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_NOCLEAR
      +#  define PERL_PV_ESCAPE_NOCLEAR         0x4000
      +#endif
      +
      +#ifndef PERL_PV_ESCAPE_RE
      +#  define PERL_PV_ESCAPE_RE              0x8000
      +#endif
      +
      +#ifndef PERL_PV_PRETTY_NOCLEAR
      +#  define PERL_PV_PRETTY_NOCLEAR         PERL_PV_ESCAPE_NOCLEAR
      +#endif
      +#ifndef PERL_PV_PRETTY_DUMP
      +#  define PERL_PV_PRETTY_DUMP            PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
      +#endif
      +
      +#ifndef PERL_PV_PRETTY_REGPROP
      +#  define PERL_PV_PRETTY_REGPROP         PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE
      +#endif
      +
      +/* Hint: pv_escape
      + * Note that unicode functionality is only backported to
      + * those perl versions that support it. For older perl
      + * versions, the implementation will fall back to bytes.
      + */
      +
      +#ifndef pv_escape
      +#if defined(NEED_pv_escape)
      +static char * DPPP_(my_pv_escape)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
      +static
      +#else
      +extern char * DPPP_(my_pv_escape)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
      +#endif
      +
      +#ifdef pv_escape
      +#  undef pv_escape
      +#endif
      +#define pv_escape(a,b,c,d,e,f) DPPP_(my_pv_escape)(aTHX_ a,b,c,d,e,f)
      +#define Perl_pv_escape DPPP_(my_pv_escape)
      +
      +#if defined(NEED_pv_escape) || defined(NEED_pv_escape_GLOBAL)
      +
      +char *
      +DPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,
      +  const STRLEN count, const STRLEN max,
      +  STRLEN * const escaped, const U32 flags)
      +{
      +    const char esc = flags & PERL_PV_ESCAPE_RE ? '%' : '\\';
      +    const char dq = flags & PERL_PV_ESCAPE_QUOTE ? '"' : esc;
      +    char octbuf[32] = "%123456789ABCDF";
      +    STRLEN wrote = 0;
      +    STRLEN chsize = 0;
      +    STRLEN readsize = 1;
      +#if defined(is_utf8_string) && defined(utf8_to_uvchr)
      +    bool isuni = flags & PERL_PV_ESCAPE_UNI ? 1 : 0;
      +#endif
      +    const char *pv  = str;
      +    const char * const end = pv + count;
      +    octbuf[0] = esc;
      +
      +    if (!(flags & PERL_PV_ESCAPE_NOCLEAR))
      +        sv_setpvs(dsv, "");
      +
      +#if defined(is_utf8_string) && defined(utf8_to_uvchr)
      +    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))
      +        isuni = 1;
      +#endif
      +
      +    for (; pv < end && (!max || wrote < max) ; pv += readsize) {
      +        const UV u =
      +#if defined(is_utf8_string) && defined(utf8_to_uvchr)
      +                     isuni ? utf8_to_uvchr((U8*)pv, &readsize) :
      +#endif
      +                             (U8)*pv;
      +        const U8 c = (U8)u & 0xFF;
      +
      +        if (u > 255 || (flags & PERL_PV_ESCAPE_ALL)) {
      +            if (flags & PERL_PV_ESCAPE_FIRSTCHAR)
      +                chsize = my_snprintf(octbuf, sizeof octbuf,
      +                                      "%" UVxf, u);
      +            else
      +                chsize = my_snprintf(octbuf, sizeof octbuf,
      +                                      "%cx{%" UVxf "}", esc, u);
      +        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {
      +            chsize = 1;
      +        } else {
      +            if (c == dq || c == esc || !isPRINT(c)) {
      +                chsize = 2;
      +                switch (c) {
      +                case '\\' : /* fallthrough */
      +                case '%'  : if (c == esc)
      +                                octbuf[1] = esc;
      +                            else
      +                                chsize = 1;
      +                            break;
      +                case '\v' : octbuf[1] = 'v'; break;
      +                case '\t' : octbuf[1] = 't'; break;
      +                case '\r' : octbuf[1] = 'r'; break;
      +                case '\n' : octbuf[1] = 'n'; break;
      +                case '\f' : octbuf[1] = 'f'; break;
      +                case '"'  : if (dq == '"')
      +                                octbuf[1] = '"';
      +                            else
      +                                chsize = 1;
      +                            break;
      +                default:    chsize = my_snprintf(octbuf, sizeof octbuf,
      +                                pv < end && isDIGIT((U8)*(pv+readsize))
      +                                ? "%c%03o" : "%c%o", esc, c);
      +                }
      +            } else {
      +                chsize = 1;
      +            }
      +        }
      +        if (max && wrote + chsize > max) {
      +            break;
      +        } else if (chsize > 1) {
      +            sv_catpvn(dsv, octbuf, chsize);
      +            wrote += chsize;
      +        } else {
      +            char tmp[2];
      +            my_snprintf(tmp, sizeof tmp, "%c", c);
      +            sv_catpvn(dsv, tmp, 1);
      +            wrote++;
      +        }
      +        if (flags & PERL_PV_ESCAPE_FIRSTCHAR)
      +            break;
      +    }
      +    if (escaped != NULL)
      +        *escaped= pv - str;
      +    return SvPVX(dsv);
      +}
      +
      +#endif
      +#endif
      +
      +#ifndef pv_pretty
      +#if defined(NEED_pv_pretty)
      +static char * DPPP_(my_pv_pretty)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
      +static
      +#else
      +extern char * DPPP_(my_pv_pretty)(pTHX_ SV * dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
      +#endif
      +
      +#ifdef pv_pretty
      +#  undef pv_pretty
      +#endif
      +#define pv_pretty(a,b,c,d,e,f,g) DPPP_(my_pv_pretty)(aTHX_ a,b,c,d,e,f,g)
      +#define Perl_pv_pretty DPPP_(my_pv_pretty)
      +
      +#if defined(NEED_pv_pretty) || defined(NEED_pv_pretty_GLOBAL)
      +
      +char *
      +DPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,
      +  const STRLEN max, char const * const start_color, char const * const end_color,
      +  const U32 flags)
      +{
      +    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '"' : '%';
      +    STRLEN escaped;
      +
      +    if (!(flags & PERL_PV_PRETTY_NOCLEAR))
      +        sv_setpvs(dsv, "");
      +
      +    if (dq == '"')
      +        sv_catpvs(dsv, "\"");
      +    else if (flags & PERL_PV_PRETTY_LTGT)
      +        sv_catpvs(dsv, "<");
      +
      +    if (start_color != NULL)
      +        sv_catpv(dsv, D_PPP_CONSTPV_ARG(start_color));
      +
      +    pv_escape(dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR);
      +
      +    if (end_color != NULL)
      +        sv_catpv(dsv, D_PPP_CONSTPV_ARG(end_color));
      +
      +    if (dq == '"')
      +        sv_catpvs(dsv, "\"");
      +    else if (flags & PERL_PV_PRETTY_LTGT)
      +        sv_catpvs(dsv, ">");
      +
      +    if ((flags & PERL_PV_PRETTY_ELLIPSES) && escaped < count)
      +        sv_catpvs(dsv, "...");
      +
      +    return SvPVX(dsv);
      +}
      +
      +#endif
      +#endif
      +
      +#ifndef pv_display
      +#if defined(NEED_pv_display)
      +static char * DPPP_(my_pv_display)(pTHX_ SV * dsv, const char * pv, STRLEN cur, STRLEN len, STRLEN pvlim);
      +static
      +#else
      +extern char * DPPP_(my_pv_display)(pTHX_ SV * dsv, const char * pv, STRLEN cur, STRLEN len, STRLEN pvlim);
      +#endif
      +
      +#ifdef pv_display
      +#  undef pv_display
      +#endif
      +#define pv_display(a,b,c,d,e) DPPP_(my_pv_display)(aTHX_ a,b,c,d,e)
      +#define Perl_pv_display DPPP_(my_pv_display)
      +
      +#if defined(NEED_pv_display) || defined(NEED_pv_display_GLOBAL)
      +
      +char *
      +DPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
      +{
      +    pv_pretty(dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);
      +    if (len > cur && pv[cur] == '\0')
      +        sv_catpvs(dsv, "\\0");
      +    return SvPVX(dsv);
      +}
      +
      +#endif
      +#endif
      +
      +#endif /* _P_P_PORTABILITY_H_ */
      +
      +/* End of File ppport.h */
      diff --git a/ref.xs b/ref.xs
      index 834ddd8..8284958 100644
      --- a/ref.xs
      +++ b/ref.xs
      @@ -1,6 +1,7 @@
       #include "EXTERN.h"
       #include "perl.h"
       #include "XSUB.h"
      +#include "ppport.h"
       
       typedef OP	*B__OP;
       
      @@ -89,9 +90,9 @@ void universal_ref_fixupop( OP* o ) {
           universal_ref_fixupop(cUNOPx(o)->op_first);
         }
       
      -  if ( o->op_sibling ) {
      -    UNIVERSAL_REF_DEBUG(printf("# ->sibling=%x\n",o->op_sibling));
      -    universal_ref_fixupop(o->op_sibling);
      +  if ( OpHAS_SIBLING(o) ) {
      +    UNIVERSAL_REF_DEBUG(printf("# ->sibling=%x\n",OpSIBLING(o)));
      +    universal_ref_fixupop(OpSIBLING(o));
         }
       }
       
      -- 
      2.9.4

    name: UNIVERSAL-ref-0.14-Fix-building-with-Perl-5.25.1.patch
    opt: -p1
perl-Unix-Mknod:
  '0.04':
  - content: |+
      From 1669d02d5425a01e08aaa4584d0c5fe61a0cb7a8 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Mon, 5 Mar 2018 17:14:27 +0100
      Subject: [PATCH] Include <sys/sysmacros.h> on glibc
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      glibc-2.27.9000 changed something in header files and minor() symbol
      is not defined without including <sys/sysmacros.h> now:

      + make test
      "/usr/bin/perl" -MExtUtils::Command::MM -e 'cp_nonempty' -- Mknod.bs blib/arch/auto/Unix/M
      knod/Mknod.bs 644
      PERL_DL_NONLAZY=1 "/usr/bin/perl" "-MExtUtils::Command::MM" "-MTest::Harness" "-e" "undef
      *Test::Harness::Switches; test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
      Can't load '/home/test/fedora/perl-Unix-Mknod/Unix-Mknod-0.04/blib/arch/auto/Unix/Mknod/Mk
      nod.so' for module Unix::Mknod: /home/test/fedora/perl-Unix-Mknod/Unix-Mknod-0.04/blib/arc
      h/auto/Unix/Mknod/Mknod.so: undefined symbol: minor at /usr/lib64/perl5/DynaLoader.pm line
       193.

      This patch fixes it by including <sys/sysmacros.h> on systems with glibc.

      CPAN RT#124687

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      ---
       Makefile.PL | 2 ++
       Mknod.xs    | 3 +++
       2 files changed, 5 insertions(+)

      diff --git a/Makefile.PL b/Makefile.PL
      index a78f929..f0fe012 100644
      --- a/Makefile.PL
      +++ b/Makefile.PL
      @@ -4,6 +4,8 @@ use Config(%Config);
       
       $defines= '-DHAS_SYSMKDEV'
       	if ($Config{osname} eq 'solaris');
      +$defines= '-DHAS_SYSSYSMACROS'
      +	if (defined $Config{d_gnulibc});
       
       # See lib/ExtUtils/MakeMaker.pm for details of how to influence
       # the contents of the Makefile that is written.
      diff --git a/Mknod.xs b/Mknod.xs
      index 3b9f55f..263614e 100644
      --- a/Mknod.xs
      +++ b/Mknod.xs
      @@ -11,6 +11,9 @@ extern "C" {
       #ifdef HAS_SYSMKDEV
       #include <sys/mkdev.h>
       #endif
      +#ifdef HAS_SYSSYSMACROS
      +#include <sys/sysmacros.h>
      +#endif
       
       #ifdef __cplusplus
       }
      -- 
      2.13.6

    name: Unix-Mknod-0.04-Include-sys-sysmacros.h-on-glibc.patch
    opt: null
perl-WWW-Mechanize-PhantomJS:
  '0.24':
  - content: |
      diff -ur WWW-Mechanize-PhantomJS-0.24/lib/WWW/Mechanize/PhantomJS.pm WWW-Mechanize-PhantomJS-0.24_fix/lib/WWW/Mechanize/PhantomJS.pm
      --- WWW-Mechanize-PhantomJS-0.24/lib/WWW/Mechanize/PhantomJS.pm	2020-09-11 19:48:39.000000000 +0200
      +++ WWW-Mechanize-PhantomJS-0.24_fix/lib/WWW/Mechanize/PhantomJS.pm	2020-10-18 13:45:25.080485798 +0200
      @@ -3,7 +3,6 @@
       use 5.010;
       use warnings;
       
      -use Filter::signatures;
       no warnings 'experimental::signatures';
       use feature 'signatures';
       
    name: nosig.diff
    opt: -p1
perl-Web-Machine:
  '0.17':
  - content: |
      Index: Web-Machine-0.17/t/010-resource-tests.t
      ===================================================================
      --- Web-Machine-0.17.orig/t/010-resource-tests.t
      +++ Web-Machine-0.17/t/010-resource-tests.t
      @@ -530,54 +530,54 @@ my @tests = (
           # M20 via L15,M16
           {
               resource => 'M20',
      -        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 202, [ 'Content-Encoding' => 'gzip', 'Content-Type' => 'text/plain' ], [] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,m20,m20b'
           },
           {
               resource => 'M20b',
      -        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 500, [ 'Content-Encoding' => 'gzip', 'Content-Type' => 'text/plain' ], ['Internal Server Error'] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,m20'
           },
           # O20
           {
               resource => 'O20c',
      -        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 204, [ 'Content-Encoding' => 'gzip', 'Content-Type' => 'text/plain' ], [] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,m20,m20b,o20'
           },
           # O18
           {
               resource => 'O18c',
      -        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'DELETE', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 200, [ 'Content-Encoding' => 'gzip', 'Content-Type' => 'text/plain' ], [ 'HELLO WORLD' ] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,m20,m20b,o20,o18,o18b'
           },
           # N11
           {
               resource => 'N11h',
      -        request  => { REQUEST_METHOD => 'POST', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'POST', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 303, [ 'Location' => '/foo/bar', 'Content-Encoding' => 'gzip', 'Content-Type' => 'text/plain' ], [] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,n16,n11'
           },
           # O14
           {
               resource => 'O14',
      -        request  => { REQUEST_METHOD => 'PUT', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'PUT', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 409, [ 'Content-Type' => 'text/plain' ], ['Conflict'] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,n16,o16,o14'
           },
           {
               resource => 'O14b',
      -        request  => { REQUEST_METHOD => 'PUT', CONTENT_TYPE => 'text/plain', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'PUT', CONTENT_TYPE => 'text/plain', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 500, [ 'Content-Type' => 'text/plain' ], ['Internal Server Error'] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,n16,o16,o14'
           },
           # P11
           {
               resource => 'P11e',
      -        request  => { REQUEST_METHOD => 'PUT', CONTENT_TYPE => 'text/plain', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2036 15:49:00 GMT' },
      +        request  => { REQUEST_METHOD => 'PUT', CONTENT_TYPE => 'text/plain', HTTP_IF_NONE_MATCH => '0xDEADPORK', HTTP_IF_MODIFIED_SINCE => '18 Mar 2936 15:49:00 GMT' },
               response => [ 201, [ 'Location' => '/foo/bar', 'Content-Type' => 'text/plain' ], [] ],
               trace    => 'b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,c3,d4,e5,f6,g7,g8,h10,i12,i13,k13,l13,l14,l15,m16,n16,o16,o14,p11'
           },
    name: fix-tests-2036.patch
    opt: -p1
perl-Wx:
  '0.9932':
  - content: |+
      From cfb24d6c3de259ad46fdc96099419fed22636c28 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Stefan=20Br=C3=BCns?= <stefan.bruens@rwth-aachen.de>
      Date: Tue, 21 Feb 2017 06:37:03 +0100
      Subject: [PATCH 1/2] Sort output of dumped dictionaries for reproducible
       builds
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      By default, dictionaries are dumped in hash order, with a random hash
      initialization value.
      Also sort export list and make entries unique, exports may be declared
      in multiple files.

      Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
      ---
       build/Wx/build/MakeMaker/Any_OS.pm |  2 ++
       build/Wx/build/Options.pm          |  2 ++
       script/fix_alien_path.pl           |  2 ++
       script/make_exp_list.pl            | 13 ++++++++++---
       4 files changed, 16 insertions(+), 3 deletions(-)

      diff --git a/build/Wx/build/MakeMaker/Any_OS.pm b/build/Wx/build/MakeMaker/Any_OS.pm
      index 55d3b7b..5dd2a2f 100644
      --- a/build/Wx/build/MakeMaker/Any_OS.pm
      +++ b/build/Wx/build/MakeMaker/Any_OS.pm
      @@ -200,6 +200,8 @@ sub postamble_core {
         # strictly necessary, but it's better to keep them in case the
         # dependencies here are changed
         require Data::Dumper;
      +  # sort output for reproducible builds
      +  $Data::Dumper::Sortkeys = 1;
         Wx::build::Utils::write_string( 'files.lst',
                                         Data::Dumper->Dump( [ \%files ] ) );
         # $exp and fix_alien depend on wxt_copy_files to ensure that blib/lib/Wx
      diff --git a/build/Wx/build/Options.pm b/build/Wx/build/Options.pm
      index 578bec5..a0fb8da 100644
      --- a/build/Wx/build/Options.pm
      +++ b/build/Wx/build/Options.pm
      @@ -163,6 +163,8 @@ sub write_config_file {
         my $file = shift;
       
         require Data::Dumper;
      +  # sort output for reproducible builds
      +  $Data::Dumper::Sortkeys = 1;
         my $str = Data::Dumper->Dump( [ { extra_libs   => $extra_libs,
                                           extra_cflags => $extra_cflags,
                                           alien_key    => $alien_key,
      diff --git a/script/fix_alien_path.pl b/script/fix_alien_path.pl
      index 99aca90..83266a7 100644
      --- a/script/fix_alien_path.pl
      +++ b/script/fix_alien_path.pl
      @@ -30,6 +30,8 @@ my $key = Alien::wxWidgets->key;
       my $version = Alien::wxWidgets->version;
       my @libs = Alien::wxWidgets->library_keys;
       my %libs; @libs{@libs} = Alien::wxWidgets->shared_libraries( @libs );
      +# sort output for reproducible builds
      +$Data::Dumper::Sortkeys = 1;
       my $libs = Data::Dumper::Dumper( \%libs );
       
       my $keyd;
      diff --git a/script/make_exp_list.pl b/script/make_exp_list.pl
      index 211a484..9b32dbd 100644
      --- a/script/make_exp_list.pl
      +++ b/script/make_exp_list.pl
      @@ -22,6 +22,11 @@ my %packages;
       my $tag;
       my $package;
       
      +sub unique_sorted {
      +  my %v = %{ { map { ($_ => 1) } @{$_[0]} } };
      +  sort keys %v;
      +}
      +
       sub add_to_exports {
         my( $values, $tags ) = @_;
       
      @@ -91,11 +96,12 @@ package Wx::Wx_Exp; # for RPM
       EOT
       
       foreach my $package ( sort keys %packages ) {
      -print OUT <<EOT;
      +  my @exp = unique_sorted( $packages{$package}{exp_ok} );
      +  print OUT <<EOT;
       
       package ${package};
       
      -push \@EXPORT_OK, qw(@{$packages{$package}{exp_ok}});
      +push \@EXPORT_OK, qw(@exp);
       
       \$EXPORT_TAGS{'everything'} = \\\@EXPORT_OK;
       
      @@ -103,8 +109,9 @@ EOT
       
         foreach my $tag ( sort keys %{ $packages{$package}{tags} } ) {
           next unless length $tag;
      +    my @pkgtags = unique_sorted( $packages{$package}{tags}{$tag} );
           print OUT <<EOT;
      -\$EXPORT_TAGS{'$tag'} = [ qw(@{ $packages{$package}{tags}{$tag} }) ];
      +\$EXPORT_TAGS{'$tag'} = [ qw(@pkgtags) ];
       EOT
         }
       }
      -- 
      2.11.1

    name: 0001-Sort-output-of-dumped-dictionaries-for-reproducible-.patch
    opt: -p1
  - content: |+
      From bebdd9566fb806cb29aeaa8256658f583def4f48 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Stefan=20Br=C3=83=C2=BCns?= <stefan.bruens@rwth-aachen.de>
      Date: Sun, 19 Mar 2017 05:45:08 +0100
      Subject: [PATCH] fix incomplete Wx_Exp.pm due to missing dependecy in
       generated Makefile
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
      ---
       build/Wx/build/MakeMaker/Any_OS.pm | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/build/Wx/build/MakeMaker/Any_OS.pm b/build/Wx/build/MakeMaker/Any_OS.pm
      index 5dd2a2f..2671339 100644
      --- a/build/Wx/build/MakeMaker/Any_OS.pm
      +++ b/build/Wx/build/MakeMaker/Any_OS.pm
      @@ -122,7 +122,7 @@ sub depend_core {
       
         my %files = $this->files_to_install();
         my %depend = ( _depend_common( $this ),
      -                 $exp              => join( ' ', $this->files_with_constants, ),
      +                 $exp              => join( ' ', $this->files_with_constants, 'subdirs', ),
                        'wxt_fix_alien'   => 'pm_to_blib',
                        'pm_to_blib'      => 'wxt_copy_files',
                        'blibdirs'        => 'wxt_copy_files',
      -- 
      2.12.0

    name: 0001-fix-incomplete-Wx_Exp.pm-due-to-missing-dependecy-in.patch
    opt: -p1
  - content: |+
      From 5b46e838686eaf039942892dbe471c48e8818bc1 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Stefan=20Br=C3=BCns?= <stefan.bruens@rwth-aachen.de>
      Date: Mon, 27 Feb 2017 20:47:08 +0100
      Subject: [PATCH 2/2] Provide overload methods to XSpp in sorted order
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
      ---
       build/Wx/XSP/Overload.pm | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/build/Wx/XSP/Overload.pm b/build/Wx/XSP/Overload.pm
      index 34f89e9..40e1c77 100644
      --- a/build/Wx/XSP/Overload.pm
      +++ b/build/Wx/XSP/Overload.pm
      @@ -85,7 +85,7 @@ sub post_process {
                   $node->add_methods( ExtUtils::XSpp::Node::Raw->new( rows => [ '#include "cpp/overload.h"' ] ) );
               }
       
      -        foreach my $method_name ( @ovl_methods ) {
      +        foreach my $method_name ( sort @ovl_methods ) {
                   _add_overload( $self, $node, $all_methods{$method_name} );
               }
           }
      -- 
      2.11.1

    name: 0002-Provide-overload-methods-to-XSpp-in-sorted-order.patch
    opt: -p1
  - content: |+
      From ce957a4fdf2cb6fc6821b6ee791f6d3876e88b17 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Stefan=20Br=C3=BCns?= <stefan.bruens@rwth-aachen.de>
      Date: Fri, 15 Jun 2018 00:58:32 +0200
      Subject: [PATCH 3/3] Define overload constants in sorted order
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
      ---
       build/Wx/Overload/Driver.pm | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/build/Wx/Overload/Driver.pm b/build/Wx/Overload/Driver.pm
      index 0d2d383..8d49ba2 100644
      --- a/build/Wx/Overload/Driver.pm
      +++ b/build/Wx/Overload/Driver.pm
      @@ -174,7 +174,7 @@ EOT
       
       EOT
       
      -    foreach my $i ( grep { $name2type{$_} ne '1' } keys %name2type ) {
      +    foreach my $i ( grep { $name2type{$_} ne '1' } sort keys %name2type ) {
             print $out <<EOT;
       #define wxPliOvl${i} "$name2type{$i}"
       EOT
      -- 
      2.17.1

    name: 0003-Define-overload-constants-in-sorted-order.patch
    opt: -p1
  - content: |+
      From d16adc83898678e33ce094c71440d7204530a628 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Stefan=20Br=C3=BCns?= <stefan.bruens@rwth-aachen.de>
      Date: Fri, 15 Jun 2018 01:39:44 +0200
      Subject: [PATCH 4/4] Define enum values in sorted order
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
      ---
       build/Wx/XSP/Enum.pm | 3 ++-
       1 file changed, 2 insertions(+), 1 deletion(-)

      diff --git a/build/Wx/XSP/Enum.pm b/build/Wx/XSP/Enum.pm
      index efaf9ba..9f55b9c 100644
      --- a/build/Wx/XSP/Enum.pm
      +++ b/build/Wx/XSP/Enum.pm
      @@ -45,7 +45,8 @@ sub post_process {
           ( my $name = File::Basename::basename( $parser->current_file ) ) =~ tr/./_/;
           my $file = "xspp/const_$name.h";
           my @defines;
      -    while( my( $k, $v ) = each %constants ) {
      +    foreach my $k (sort keys %constants) {
      +        my $v = $constants{$k};
               if( $v->[0] ) {
                   push @defines, "#ifdef $v->[0]",
                                  "    r( $k );",
      -- 
      2.17.1

    name: 0004-Define-enum-values-in-sorted-order.patch
    opt: -p1
  - content: |
      diff --git a/XS/PropertySheetDialog.xsp b/XS/PropertySheetDialog.xsp
      index 5164a13..4e72673 100644
      --- a/XS/PropertySheetDialog.xsp
      +++ b/XS/PropertySheetDialog.xsp
      @@ -49,7 +49,13 @@
           void SetBookCtrl( wxBookCtrlBase* book );
           wxBookCtrlBase* GetBookCtrl() const;
       
      +#if WXPERL_W_VERSION_GE( 3, 0, 3 )
      +    void SetInnerSizer( wxSizer* sizer );
      +    %name{SetInnerSize} void SetInnerSizer( wxSizer* sizer );
      +#else
           void SetInnerSize( wxSizer* sizer );
      +    %name{SetInnerSizer} void SetInnerSize( wxSizer* sizer );
      +#endif
           wxSizer* GetInnerSizer() const;
       
       #if WXPERL_W_VERSION_GE( 2, 7, 2 )
    name: fix_wxWidgets_3_0_3_API_break.patch
    opt: -p1
perl-XML-Hash-LX:
  '0.07':
  - content: |+
      From 19c3c8bbb1646dc5bfe7f0d3df5efb3ba58ada80 Mon Sep 17 00:00:00 2001
      From: =?UTF-8?q?Petr=20P=C3=ADsa=C5=99?= <ppisar@redhat.com>
      Date: Mon, 9 Jun 2014 17:41:32 +0200
      Subject: [PATCH] Fix unpredictable order at 'empty attr' test
      MIME-Version: 1.0
      Content-Type: text/plain; charset=UTF-8
      Content-Transfer-Encoding: 8bit

      RT#81645

      Signed-off-by: Petr PÃ­saÅ <ppisar@redhat.com>
      ---
       t/01-conv.t | 2 +-
       1 file changed, 1 insertion(+), 1 deletion(-)

      diff --git a/t/01-conv.t b/t/01-conv.t
      index f7b06c5..30f24dc 100644
      --- a/t/01-conv.t
      +++ b/t/01-conv.t
      @@ -297,7 +297,7 @@ our $xml = qq{<?xml version="1.0" encoding="utf-8"?>\n};
       }
       {
       	like
      -		$data = hash2xml( { node => { -attr => undef, '#cdata' => undef, '/' => undef, x=>undef } }, cdata => '#cdata', comm => '/' ),
      +		$data = hash2xml( { node => [ { -attr => undef }, { '#cdata' => undef }, { '/' => undef }, { x=>undef } ] }, cdata => '#cdata', comm => '/' ),
       		qr{^\Q$xml<node attr="">\E(?:<!----><x/>|<x/><!---->)</node>\n},
       		'empty attr',
       	;
      -- 
      1.9.3

    name: XML-Hash-LX-0.0603-Fix-unpredictable-order-at-empty-attr-test.patch
    opt: -p1
perl-XML-Parser:
  2.470.0:
  - content: |
      --- samples/canonical
      +++ samples/canonical
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl -w
      +#!/usr/bin/perl -w
       #
       # Copyright 1999 Clark Cooper <coopercc@netheaven.com>
       # All rights reserved.
      --- samples/xmlcomments
      +++ samples/xmlcomments
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl -w
      +#!/usr/bin/perl -w
       #
       # $Revision: 1.1.1.1 $
       #
      --- samples/xmlfilter
      +++ samples/xmlfilter
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl -w
      +#!/usr/bin/perl -w
       #
       # $Revision: 1.1.1.1 $
       #
      --- samples/xmlstats
      +++ samples/xmlstats
      @@ -1,4 +1,4 @@
      -#!/usr/local/bin/perl -w
      +#!/usr/bin/perl -w
       #
       # $Revision: 1.1.1.1 $
       #
    name: XML-Parser-2.40.diff
    opt: -p0
perl-XML-Quick:
  '0.07':
  - content: |
      diff -ur XML-Quick-0.07/lib/XML/Quick.pm XML-Quick-0.07_fix/lib/XML/Quick.pm
      --- XML-Quick-0.07/lib/XML/Quick.pm	2015-11-19 22:53:43.000000000 +0100
      +++ XML-Quick-0.07_fix/lib/XML/Quick.pm	2022-05-17 10:16:20.507882041 +0200
      @@ -2,7 +2,7 @@
       $XML::Quick::VERSION = '0.07';
       # ABSTRACT: Generate XML from hashes (and other data)
       
      -use 5.008_001;
      +use 5.008001;
       use warnings;
       use strict;
       
      Nur in XML-Quick-0.07_fix/lib/XML: Quick.pm~.
      diff -ur XML-Quick-0.07/Makefile.PL XML-Quick-0.07_fix/Makefile.PL
      --- XML-Quick-0.07/Makefile.PL	2015-11-19 22:53:43.000000000 +0100
      +++ XML-Quick-0.07_fix/Makefile.PL	2022-05-17 10:16:26.419955656 +0200
      @@ -2,7 +2,7 @@
       use strict;
       use warnings;
       
      -use 5.008_001;
      +use 5.008001;
       
       use ExtUtils::MakeMaker;
       
      @@ -15,7 +15,7 @@
         "DISTNAME" => "XML-Quick",
         "EXE_FILES" => [],
         "LICENSE" => "perl",
      -  "MIN_PERL_VERSION" => "5.008_001",
      +  "MIN_PERL_VERSION" => "5.008001",
         "NAME" => "XML::Quick",
         "PREREQ_PM" => {
           "Exporter" => 0,
      Nur in XML-Quick-0.07_fix/: Makefile.PL~.
      diff -ur XML-Quick-0.07/META.json XML-Quick-0.07_fix/META.json
      --- XML-Quick-0.07/META.json	2015-11-19 22:53:43.000000000 +0100
      +++ XML-Quick-0.07_fix/META.json	2022-05-17 10:16:01.387643972 +0200
      @@ -24,7 +24,7 @@
                   "Exporter" : "0",
                   "Scalar::Util" : "0",
                   "base" : "0",
      -            "perl" : "5.008_001",
      +            "perl" : "5.008001",
                   "strict" : "0",
                   "warnings" : "0"
                }
      Nur in XML-Quick-0.07_fix/: META.json~.
      diff -ur XML-Quick-0.07/META.yml XML-Quick-0.07_fix/META.yml
      --- XML-Quick-0.07/META.yml	2015-11-19 22:53:43.000000000 +0100
      +++ XML-Quick-0.07_fix/META.yml	2022-05-17 10:15:46.755461790 +0200
      @@ -19,7 +19,7 @@
         Exporter: '0'
         Scalar::Util: '0'
         base: '0'
      -  perl: 5.008_001
      +  perl: 5.008001
         strict: '0'
         warnings: '0'
       resources:
      Nur in XML-Quick-0.07_fix/: META.yml~.
    name: fixperlversion.diff
    opt: -p1 PATCH-FIX-UPSTREAM specify perl 5.008001 instead of 5.008_001
perl-XML-SAX:
  '1.02':
  - content: |
      --- lib/XML/SAX/PurePerl/Reader/Stream.pm
      +++ lib/XML/SAX/PurePerl/Reader/Stream.pm
      @@ -70,6 +70,54 @@
           my $self = shift;
           my ($encoding) = @_;
           # warn("set encoding to: $encoding\n");
      +
      +    # make sure that the buffer used to detect the encoding 
      +    # does not end in the middle of a utf8 sequence
      +    if ($encoding eq 'UTF-8' && 
      +         !$self->[EOF] && 
      +         !utf8::is_utf8($self->[BUFFER]) && # make sure we do not do it twice
      +         length($self->[BUFFER]) > 5) {
      +
      +	my $x = reverse(substr($self->[BUFFER], -5));
      +	my $y = 0;
      +	
      +	# skip the all the bytes at the end of buffer
      +	# starting with bits 10 (continuation bytes of utf8 sequence)
      +	while ($x ne "" && (ord($x) & 0xc0) == 0x80) {
      +	    $y--;
      +	    $x = substr($x, 1);
      +	}
      +
      +        # if $x is ascii character, do nothing
      +	# otherwise we must take a look how many
      +	# continuation bytes we need
      +	if ((ord($x) & 0xc0) == 0xc0) {
      +	  $x = ord($x);
      +	  if (($x & 0xe0) == 0xc0) { # the sequence contains one more byte
      +	    $y++;
      +	  } elsif (($x & 0xf0) == 0xe0) { # ...2 bytes
      +	    $y += 2;
      +	  } elsif (($x & 0xf8) == 0xf0) { # ...3 bytes
      +	    $y += 3;
      +	  } elsif (($x & 0xfc) == 0xf8) { # ...4 bytes
      +	    $y += 4;
      +	  } elsif (($x & 0xfe) == 0xfc) { # ...5 bytes
      +	    $y += 5;
      +	  }
      +
      +          # read the last sequence in the buffer completely, if needed
      +	  if ($y > 0) {
      +	    my $buf;
      +	    my $bytesread = read($self->[FH], $buf, $y);
      +	    if ($bytesread) {
      +		$self->[BUFFER] .= $buf;
      +	    } elsif (defined($bytesread)) {
      +		$self->[EOF]++;
      +	    }
      +	  }
      +	}
      +      }
      +
           XML::SAX::PurePerl::Reader::switch_encoding_stream($self->[FH], $encoding);
           XML::SAX::PurePerl::Reader::switch_encoding_string($self->[BUFFER], $encoding);
           $self->[ENCODING] = $encoding;
    name: perl-XML-SAX-0.96-utf8.diff
    opt: -p0
perl-XML-Twig:
  '3.52':
  - content: |
      Description: Update documentation for XML::Twig.
       Mention problems with expand_external_ents and add
       information about new no_xxe argument.
       .
       Additionally add tests for both expand_external_ents and no_xxe.
      Origin: vendor
      Bug: https://rt.cpan.org/Public/Bug/Display.html?id=118097
      Bug-Debian: https://bugs.debian.org/842893
      Author: gregor herrmann <gregoa@debian.org>
      Last-Update: 2019-03-30

      --- a/Twig_pm.slow
      +++ b/Twig_pm.slow
      @@ -10454,6 +10454,15 @@
       pubid => <pubid> }). Yes, this is a bit of a hack, but it's useful in some
       cases.  
       
      +B<WARNING>: setting expand_external_ents to 0 or -1 currently doesn't work
      +as expected; cf. L<https://rt.cpan.org/Public/Bug/Display.html?id=118097>.
      +To completely turn off expanding external entities use C<no_xxe>.
      +
      +=item no_xxe
      +
      +If this argument is set to a true value, expanding of external entities is
      +turned off.
      +
       =item load_DTD
       
       If this argument is set to a true value, C<parse> or C<parsefile> on the twig
      --- /dev/null
      +++ b/t/CVE-2016-9180.t
      @@ -0,0 +1,41 @@
      +#!/usr/bin/perl
      +
      +use strict;
      +use warnings;
      +use Test::More;
      +use Test::Exception;
      +
      +BEGIN { use_ok('XML::Twig'); }
      +
      +my $twig = XML::Twig->new( expand_external_ents => 1 );
      +$twig->parsefile('t/CVE-2016-9180.xml');
      +my $result = $twig->sprint;
      +like( $result, qr/Boom/, 'external entity expanded (expand_external_ents 1)' );
      +
      +TODO: {
      +    local $TODO = 'This test currently fails: https://rt.cpan.org/Public/Bug/Display.html?id=118097';
      +
      +$twig = XML::Twig->new( expand_external_ents => 0 );
      +$twig->parsefile('t/CVE-2016-9180.xml');
      +$result = $twig->sprint;
      +unlike( $result, qr/Boom/,
      +    'external entity not expanded (expand_external_ents 0)' );
      +
      +$twig = XML::Twig->new( expand_external_ents => -1 );
      +$twig->parsefile('t/CVE-2016-9180.xml');
      +$result = $twig->sprint;
      +unlike( $result, qr/Boom/,
      +    'external entity not expanded and no fail (expand_external_ents -1)' );
      +
      +}
      +
      +$twig = XML::Twig->new( no_xxe => 1 );
      +throws_ok { $twig->parsefile('t/CVE-2016-9180.xml') } qr/cannot expand &xxe;/,
      +    'external entity not expanded (no_xxe 1)';
      +
      +$twig = XML::Twig->new( no_xxe => 0 );
      +$twig->parsefile('t/CVE-2016-9180.xml');
      +$result = $twig->sprint;
      +like( $result, qr/Boom/, 'external entity expanded (no_xxe 0)' );
      +
      +done_testing();
      --- /dev/null
      +++ b/t/CVE-2016-9180.txt
      @@ -0,0 +1 @@
      +Boom
      --- /dev/null
      +++ b/t/CVE-2016-9180.xml
      @@ -0,0 +1,5 @@
      +<?xml version="1.0"?>
      +<!DOCTYPE foo [
      +	<!ENTITY xxe PUBLIC "bar" "CVE-2016-9180.txt">
      +]>
      +<root>&xxe;</root>
    name: perl-XML-Twig-CVE-2016-9180.patch
    opt: -p1
